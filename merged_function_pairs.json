[
    {
        "JavaCode": "     /**\n     * Sets the X axis phase of the animation.\n     *\n     * @param phase float value between 0 - 1\n     */\n    public void setPhaseX(float phase) {\n        if (phase > 1f) {\n            phase = 1f;\n        } else if (phase < 0f) {\n            phase = 0f;\n        }\n        mPhaseX = phase;\n    }",
        "TranslatedCode": "   /**\n   * Sets the X axis phase of the animation.\n   *\n   * @param phase float value between 0 - 1\n   */\n  public setPhaseX(phase: number) {\n    if (phase > 1) {\n      phase = 1;\n    } else if (phase < 0) {\n      phase = 0;\n    }\n    this.mPhaseX = phase;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "     /**\n     * Gets the X axis phase of the animation.\n     *\n     * @return float value of {@link #mPhaseX}\n     */\n    public float getPhaseX() {\n        return mPhaseX;\n    }",
        "TranslatedCode": "   /**\n   * Gets the X axis phase of the animation.\n   *\n   * @return float value of {@link #mPhaseX}\n   */\n  public getPhaseX(): number {\n    return this.mPhaseX;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "     /**\n     * Sets the Y axis phase of the animation.\n     *\n     * @param phase float value between 0 - 1\n     */\n    public void setPhaseY(float phase) {\n        if (phase > 1f) {\n            phase = 1f;\n        } else if (phase < 0f) {\n            phase = 0f;\n        }\n        mPhaseY = phase;\n    }",
        "TranslatedCode": "   /**\n   * Sets the Y axis phase of the animation.\n   *\n   * @param phase float value between 0 - 1\n   */\n  public setPhaseY(phase: number) {\n    if (phase > 1) {\n      phase = 1;\n    } else if (phase < 0) {\n      phase = 0;\n    }\n    this.mPhaseY = phase;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "     /**\n     * Gets the Y axis phase of the animation.\n     *\n     * @return float value of {@link #mPhaseY}\n     */\n    public float getPhaseY() {\n        return mPhaseY;\n    }",
        "TranslatedCode": "   /**\n   * Gets the Y axis phase of the animation.\n   *\n   * @return float value of {@link #mPhaseY}\n   */\n  public getPhaseY(): number {\n    return this.mPhaseY;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/** limits the drawing on the x-axis */\n    public void limitFrom(int from) {\n        if (from < 0)\n            from = 0;\n        mFrom = from;\n    }",
        "TranslatedCode": "/** limits the drawing on the x-axis */\n  public limitFrom(from: number): void {\n    if (from < 0)\n      from = 0;\n    this.mFrom = from;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/** limits the drawing on the x-axis */\n    public void limitTo(int to) {\n        if (to < 0)\n            to = 0;\n        mTo = to;\n    }",
        "TranslatedCode": "/** limits the drawing on the x-axis */\n  public limitTo(to: number): void {\n    if (to < 0)\n      to = 0;\n    this.mTo = to;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Resets the buffer index to 0 and makes the buffer reusable.\n     */\n    public void reset() {\n        index = 0;\n    }",
        "TranslatedCode": "/**\n   * Resets the buffer index to 0 and makes the buffer reusable.\n   */\n  public reset(): void {\n    this.index = 0;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the size (length) of the buffer array.\n     *\n     * @return\n     */\n    public int size() {\n        return buffer.length;\n    }",
        "TranslatedCode": "/**\n   * Returns the size (length) of the buffer array.\n   *\n   * @return\n   */\n  public size(): number {\n    return this.buffer.length;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Set the phases used for animations.\n     *\n     * @param phaseX\n     * @param phaseY\n     */\n    public void setPhases(float phaseX, float phaseY) {\n        this.phaseX = phaseX;\n        this.phaseY = phaseY;\n    }",
        "TranslatedCode": "/**\n   * Set the phases used for animations.\n   *\n   * @param phaseX\n   * @param phaseY\n   */\n  public setPhases(phaseX: number, phaseY: number): void {\n    this.phaseX = phaseX;\n    this.phaseY = phaseY;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Initialization with buffer-size.\n     *\n     * @param size\n     */\n    public AbstractBuffer(int size) {\n        index = 0;\n        buffer = new float[size];\n    }",
        "TranslatedCode": "/**\n   * Initialization with buffer-size.\n   *\n   * @param size\n   */\n  constructor(size: number) {\n    this.index = 0;\n    for (let i = 0; i < size; i++) {\n      this.buffer = new Array<number>();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BarBuffer(int size, int dataSetCount, boolean containsStacks) {\n        super(size);\n        this.mDataSetCount = dataSetCount;\n        this.mContainsStacks = containsStacks;\n    }",
        "TranslatedCode": "constructor(size: number, dataSetCount: number, containsStacks: boolean) {\n    super(size);\n    this.mDataSetCount = dataSetCount;\n    this.mContainsStacks = containsStacks;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setBarWidth(float barWidth) {\n        this.mBarWidth = barWidth;\n    }",
        "TranslatedCode": "public setBarWidth(barWidth: number): void {\n    this.mBarWidth = barWidth;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setDataSet(int index) {\n        this.mDataSetIndex = index;\n    }",
        "TranslatedCode": "public setDataSet(index: number): void {\n    this.mDataSetIndex = index;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setInverted(boolean inverted) {\n        this.mInverted = inverted;\n    }",
        "TranslatedCode": "public setInverted(inverted: boolean): void {\n    this.mInverted = inverted;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void addBar(float left, float top, float right, float bottom) {\n\n        buffer[index++] = left;\n        buffer[index++] = top;\n        buffer[index++] = right;\n        buffer[index++] = bottom;\n    }",
        "TranslatedCode": "protected addBar(left: number, top: number, right: number, bottom: number): void {\n\n    this.buffer[this.index++] = left;\n    this.buffer[this.index++] = top;\n    this.buffer[this.index++] = right;\n    this.buffer[this.index++] = bottom;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "@Override\n    public void feed(IBarDataSet data) {\n\n        float size = data.getEntryCount() * phaseX;\n        float barWidthHalf = mBarWidth / 2f;\n\n        for (int i = 0; i < size; i++) {\n\n            BarEntry e = data.getEntryForIndex(i);\n\n            if(e == null)\n                continue;\n\n            float x = e.getX();\n            float y = e.getY();\n            float[] vals = e.getYVals();\n\n            if (!mContainsStacks || vals == null) {\n\n                float left = x - barWidthHalf;\n                float right = x + barWidthHalf;\n                float bottom, top;\n\n                if (mInverted) {\n                    bottom = y >= 0 ? y : 0;\n                    top = y <= 0 ? y : 0;\n                } else {\n                    top = y >= 0 ? y : 0;\n                    bottom = y <= 0 ? y : 0;\n                }\n\n                // multiply the height of the rect with the phase\n                if (top > 0)\n                    top *= phaseY;\n                else\n                    bottom *= phaseY;\n\n                addBar(left, top, right, bottom);\n\n            } else {\n\n                float posY = 0f;\n                float negY = -e.getNegativeSum();\n                float yStart = 0f;\n\n                // fill the stack\n                for (int k = 0; k < vals.length; k++) {\n\n                    float value = vals[k];\n\n                    if (value == 0.0f && (posY == 0.0f || negY == 0.0f)) {\n                        // Take care of the situation of a 0.0 value, which overlaps a non-zero bar\n                        y = value;\n                        yStart = y;\n                    } else if (value >= 0.0f) {\n                        y = posY;\n                        yStart = posY + value;\n                        posY = yStart;\n                    } else {\n                        y = negY;\n                        yStart = negY + Math.abs(value);\n                        negY += Math.abs(value);\n                    }\n\n                    float left = x - barWidthHalf;\n                    float right = x + barWidthHalf;\n                    float bottom, top;\n\n                    if (mInverted) {\n                        bottom = y >= yStart ? y : yStart;\n                        top = y <= yStart ? y : yStart;\n                    } else {\n                        top = y >= yStart ? y : yStart;\n                        bottom = y <= yStart ? y : yStart;\n                    }\n\n                    // multiply the height of the rect with the phase\n                    top *= phaseY;\n                    bottom *= phaseY;\n\n                    addBar(left, top, right, bottom);\n                }\n            }\n        }\n\n        reset();\n    }",
        "TranslatedCode": "public feed(data: IBarDataSet): void {\n\n    let size: number = data.getEntryCount() * this.phaseX;\n    let barWidthHalf: number = this.mBarWidth / 2;\n\n    for (let i = 0; i < size; i++) {\n\n      let e: BarEntry | null = data.getEntryForIndex(i);\n\n      if (e == null)\n        continue;\n\n      let x: number = e.getX();\n      let y: number = e.getY();\n      let values: number[] | null = e.getYVals();\n\n      if (!this.mContainsStacks || values == null) {\n\n        let left: number = x - barWidthHalf;\n        let right: number = x + barWidthHalf;\n        let bottom: number = 0;\n        let top: number = 0;\n\n        if (this.mInverted) {\n          bottom = y >= 0 ? y : 0;\n          top = y <= 0 ? y : 0;\n        } else {\n          top = y >= 0 ? y : 0;\n          bottom = y <= 0 ? y : 0;\n        }\n\n        // multiply the height of the rect with the phase\n        if (top > 0)\n          top *= this.phaseY;\n        else\n          bottom *= this.phaseY;\n\n        this.addBar(left, top, right, bottom);\n\n      } else {\n\n        let posY: number = 0;\n        let negY: number = -e.getNegativeSum();\n        let yStart: number = 0;\n\n        // fill the stack\n        for (let k = 0; k < values.length; k++) {\n\n          let value: number = values[k];\n\n          if (value == 0.0 && (posY == 0.0 || negY == 0.0)) {\n            // Take care of the situation of a 0.0 value, which overlaps a non-zero bar\n            y = value;\n            yStart = y;\n          } else if (value >= 0.0) {\n            y = posY;\n            yStart = posY + value;\n            posY = yStart;\n          } else {\n            y = negY;\n            yStart = negY + Math.abs(value);\n            negY += Math.abs(value);\n          }\n\n          let left: number = x - barWidthHalf;\n          let right: number = x + barWidthHalf;\n          let bottom: number = 0;\n          let top: number = 0;\n\n          if (this.mInverted) {\n            bottom = y >= yStart ? y : yStart;\n            top = y <= yStart ? y : yStart;\n          } else {\n            top = y >= yStart ? y : yStart;\n            bottom = y <= yStart ? y : yStart;\n          }\n\n          // multiply the height of the rect with the phase\n          top *= this.phaseY;\n          bottom *= this.phaseY;\n\n          this.addBar(left, top, right, bottom);\n        }\n      }\n    }\n\n    this.reset();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "@Override\n    public void feed(IBarDataSet data) {\n\n        float size = data.getEntryCount() * phaseX;\n        float barWidthHalf = mBarWidth / 2f;\n\n        for (int i = 0; i < size; i++) {\n\n            BarEntry e = data.getEntryForIndex(i);\n\n            if(e == null)\n                continue;\n\n            float x = e.getX();\n            float y = e.getY();\n            float[] vals = e.getYVals();\n\n            if (!mContainsStacks || vals == null) {\n\n                float bottom = x - barWidthHalf;\n                float top = x + barWidthHalf;\n                float left, right;\n                if (mInverted) {\n                    left = y >= 0 ? y : 0;\n                    right = y <= 0 ? y : 0;\n                } else {\n                    right = y >= 0 ? y : 0;\n                    left = y <= 0 ? y : 0;\n                }\n\n                // multiply the height of the rect with the phase\n                if (right > 0)\n                    right *= phaseY;\n                else\n                    left *= phaseY;\n\n                addBar(left, top, right, bottom);\n\n            } else {\n\n                float posY = 0f;\n                float negY = -e.getNegativeSum();\n                float yStart = 0f;\n\n                // fill the stack\n                for (int k = 0; k < vals.length; k++) {\n\n                    float value = vals[k];\n\n                    if (value >= 0f) {\n                        y = posY;\n                        yStart = posY + value;\n                        posY = yStart;\n                    } else {\n                        y = negY;\n                        yStart = negY + Math.abs(value);\n                        negY += Math.abs(value);\n                    }\n\n                    float bottom = x - barWidthHalf;\n                    float top = x + barWidthHalf;\n                    float left, right;\n                    if (mInverted) {\n                        left = y >= yStart ? y : yStart;\n                        right = y <= yStart ? y : yStart;\n                    } else {\n                        right = y >= yStart ? y : yStart;\n                        left = y <= yStart ? y : yStart;\n                    }\n\n                    // multiply the height of the rect with the phase\n                    right *= phaseY;\n                    left *= phaseY;\n\n                    addBar(left, top, right, bottom);\n                }\n            }\n        }\n\n        reset();\n    }",
        "TranslatedCode": "feed(data: IBarDataSet) {\n    let size: number = data.getEntryCount() * this.phaseX;\n    let barWidthHalf = this.mBarWidth / 2;\n\n    for (let i = 0; i < size; i++) {\n      let e: BarEntry = data.getEntryForIndex(i);\n      if (e == null)\n        continue;\n      let x: number = e.getX();\n      let y: number = e.getY();\n      let vals = e.getYVals();\n\n      if (!this.mContainsStacks || vals == null) {\n        let bottom = x - barWidthHalf;\n        let top = x + barWidthHalf;\n        let left: number = 0, right: number = 0;\n        if (this.mInverted) {\n          left = y >= 0 ? y : 0;\n          right = y <= 0 ? y : 0;\n        } else {\n          right = y >= 0 ? y : 0;\n          left = y <= 0 ? y : 0;\n        }\n\n        // multiply the height of the rect with the phase\n        if (right > 0)\n          right *= this.phaseY;\n        else\n          left *= this.phaseY;\n\n        this.addBar(left, top, right, bottom);\n      } else {\n        let posY = 0;\n        let negY = -e.getNegativeSum();\n        let yStart = 0;\n\n        //fill the stack\n        for (let k = 0; k < vals.length; k++) {\n          let value = vals[k];\n\n          if (value >= 0) {\n            y = posY;\n            yStart = posY + value;\n            posY = yStart;\n          } else {\n            y = negY;\n            yStart = negY + Math.abs(value);\n            negY += Math.abs(value);\n          }\n\n          let bottom = x - barWidthHalf;\n          let top = x + barWidthHalf;\n          let left: number = 0, right: number = 0;\n          if (this.mInverted) {\n            left = y >= yStart ? y : yStart;\n            right = y <= yStart ? y : yStart;\n          } else {\n            right = y >= yStart ? y : yStart;\n            left = y <= yStart ? y : yStart;\n          }\n\n          // multiply the height of the rect with the phase\n          right *= this.phaseY;\n          left *= this.phaseY;\n\n          this.addBar(left, top, right, bottom);\n        }\n      }\n    }\n    this.reset();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the id of the given pool instance.\n     *\n     * @return an integer ID belonging to this pool instance.\n     */\n    public int getPoolId(){\n        return poolId;\n    }",
        "TranslatedCode": "/**\n   * Returns the id of the given pool instance.\n   *\n   * @return an integer ID belonging to this pool instance.\n   */\n  public getPoolId(): number {\n    return this.poolId;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns an ObjectPool instance, of a given starting capacity, that recycles instances of a given Poolable object.\n     *\n     * @param withCapacity A positive integer value.\n     * @param object An instance of the object that the pool should recycle.\n     * @return\n     */\n    public static synchronized ObjectPool create(int withCapacity, Poolable object){\n        ObjectPool result = new ObjectPool(withCapacity, object);\n        result.poolId = ids;\n        ids++;\n\n        return result;\n    }",
        "TranslatedCode": "/**\n   * Returns an ObjectPool instance, of a given starting capacity, that recycles instances of a given Poolable object.\n   *\n   * @param withCapacity A positive integer value.\n   * @param object An instance of the object that the pool should recycle.\n   * @return\n   */\n  public static create(withCapacity: number, object: Poolable) {\n    let result = new ObjectPool<Poolable>(withCapacity, object);\n    result.poolId = ObjectPool.ids;\n    ObjectPool.ids++;\n\n    return result;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private ObjectPool(int withCapacity, T object){\n        if(withCapacity <= 0){\n            throw new IllegalArgumentException(\"Object Pool must be instantiated with a capacity greater than 0!\");\n        }\n        this.desiredCapacity = withCapacity;\n        this.objects = new Object[this.desiredCapacity];\n        this.objectsPointer = 0;\n        this.modelObject = object;\n        this.replenishPercentage = 1.0f;\n        this.refillPool();\n    }",
        "TranslatedCode": "constructor(withCapacity: number, object: T) {\n    if (withCapacity <= 0) {\n      throw new Error(\"Object Pool must be instantiated with a capacity greater than 0!\");\n    }\n    this.desiredCapacity = withCapacity;\n    this.objects = new Array<Object>(this.desiredCapacity);\n    this.objectsPointer = 0;\n    this.modelObject = object;\n    this.replenishPercentage = 1.0;\n    this.refillPool();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Set the percentage of the pool to replenish on empty.  Valid values are between\n     * 0.00f and 1.00f\n     *\n     * @param percentage a value between 0 and 1, representing the percentage of the pool to replenish.\n     */\n    public void setReplenishPercentage(float percentage){\n        float p = percentage;\n        if(p > 1){\n            p = 1;\n        }\n        else if(p < 0f){\n            p = 0f;\n        }\n        this.replenishPercentage = p;\n    }",
        "TranslatedCode": "/**\n   * Set the percentage of the pool to replenish on empty.  Valid values are between\n   * 0.00f and 1.00f\n   *\n   * @param percentage a value between 0 and 1, representing the percentage of the pool to replenish.\n   */\n  public setReplenishPercentage(percentage: number) {\n    let p = percentage;\n    if (p > 1) {\n      p = 1;\n    }\n    else if (p < 0) {\n      p = 0;\n    }\n    this.replenishPercentage = p;\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getReplenishPercentage(){\n        return replenishPercentage;\n    }",
        "TranslatedCode": "public getReplenishPercentage(): number {\n\n    return this.replenishPercentage;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void refillPool(){\n        this.refillPool(this.replenishPercentage);\n    }\n\n    private void refillPool(float percentage){\n        int portionOfCapacity = (int) (desiredCapacity * percentage);\n\n        if(portionOfCapacity < 1){\n            portionOfCapacity = 1;\n        }else if(portionOfCapacity > desiredCapacity){\n            portionOfCapacity = desiredCapacity;\n        }\n\n        for(int i = 0 ; i < portionOfCapacity ; i++){\n            this.objects[i] = modelObject.instantiate();\n        }\n        objectsPointer = portionOfCapacity - 1;\n    }",
        "TranslatedCode": "private refillPool(percentage?: number) {\n\n    if (percentage == null) {\n      percentage = this.replenishPercentage\n    }\n\n    let portionOfCapacity = (this.desiredCapacity * percentage);\n\n    if (portionOfCapacity < 1) {\n      portionOfCapacity = 1;\n    } else if (portionOfCapacity > this.desiredCapacity) {\n      portionOfCapacity = this.desiredCapacity;\n    }\n\n    for (let i = 0; i < portionOfCapacity; i++) {\n      if (this.objects && this.modelObject) {\n        let poolableObj = this.modelObject.instantiate();\n        if (poolableObj !== null) {\n          this.objects[i] = poolableObj;\n        }\n\n      }\n    }\n    this.objectsPointer = portionOfCapacity - 1;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns an instance of Poolable.  If get() is called with an empty pool, the pool will be\n     * replenished.  If the pool capacity is sufficiently large, this could come at a performance\n     * cost.\n     *\n     * @return An instance of Poolable object T\n     */\n    public synchronized T get(){\n\n        if(this.objectsPointer == -1 && this.replenishPercentage > 0.0f){\n            this.refillPool();\n        }\n\n        T result = (T)objects[this.objectsPointer];\n        result.currentOwnerId = Poolable.NO_OWNER;\n        this.objectsPointer--;\n\n        return result;\n    }",
        "TranslatedCode": "/**\n\n   * Returns an instance of Poolable.  If get() is called with an empty pool, the pool will be\n\n   * replenished.  If the pool capacity is sufficiently large, this could come at a performance\n\n   * cost.\n\n   *\n\n   * @return An instance of Poolable object T\n\n   */\n\n  public get(): T {\n\n\n\n    if (this.objectsPointer == -1 && this.replenishPercentage > 0.0) {\n\n      this.refillPool();\n\n    }\n\n\n\n    if (!this.objects) {\n\n      this.objects = new Array<Poolable>(this.desiredCapacity);\n\n    }\n\n    let result: T = this.objects[this.objectsPointer] as T;\n\n    result.currentOwnerId = Poolable.NO_OWNER;\n\n    this.objectsPointer--;\n\n\n\n    return result;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Recycle an instance of Poolable that this pool is capable of generating.\n     * The T instance passed must not already exist inside this or any other ObjectPool instance.\n     *\n     * @param object An object of type T to recycle\n     */\n    public synchronized void recycle(T object){\n        if(object.currentOwnerId != Poolable.NO_OWNER){\n            if(object.currentOwnerId == this.poolId){\n                throw new IllegalArgumentException(\"The object passed is already stored in this pool!\");\n            }else {\n                throw new IllegalArgumentException(\"The object to recycle already belongs to poolId \" + object.currentOwnerId + \".  Object cannot belong to two different pool instances simultaneously!\");\n            }\n        }\n\n        this.objectsPointer++;\n        if(this.objectsPointer >= objects.length){\n            this.resizePool();\n        }\n\n        object.currentOwnerId = this.poolId;\n        objects[this.objectsPointer] = object;\n\n    }",
        "TranslatedCode": "/**\n\n   * Recycle an instance of Poolable that this pool is capable of generating.\n\n   * The T instance passed must not already exist inside this or any other ObjectPool instance.\n\n   *\n\n   * @param object An object of type T to recycle\n\n   */\n\n  public recycle(object: T) {\n\n    if (object.currentOwnerId != Poolable.NO_OWNER) {\n\n      if (object.currentOwnerId == this.poolId) {\n\n        throw new Error(\"The object passed is already stored in this pool!\");\n\n      } else {\n\n        throw new Error(\"The object to recycle already belongs to poolId \" + object.currentOwnerId + \".  Object cannot belong to two different pool instances simultaneously!\");\n\n      }\n\n    }\n\n\n\n    this.objectsPointer++;\n\n    if (this.objects) {\n\n      if (this.objectsPointer >= this.objects.length) {\n\n        this.resizePool();\n\n      }\n\n      object.currentOwnerId = this.poolId;\n\n      this.objects[this.objectsPointer] = object;\n\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Recycle a List of Poolables that this pool is capable of generating.\n     * The T instances passed must not already exist inside this or any other ObjectPool instance.\n     *\n     * @param objects A list of objects of type T to recycle\n     */\n    public synchronized void recycle(List<T> objects){\n        while(objects.size() + this.objectsPointer + 1 > this.desiredCapacity){\n            this.resizePool();\n        }\n        final int objectsListSize = objects.size();\n\n        // Not relying on recycle(T object) because this is more performant.\n        for(int i = 0 ; i < objectsListSize ; i++){\n            T object = objects.get(i);\n            if(object.currentOwnerId != Poolable.NO_OWNER){\n                if(object.currentOwnerId == this.poolId){\n                    throw new IllegalArgumentException(\"The object passed is already stored in this pool!\");\n                }else {\n                    throw new IllegalArgumentException(\"The object to recycle already belongs to poolId \" + object.currentOwnerId + \".  Object cannot belong to two different pool instances simultaneously!\");\n                }\n            }\n            object.currentOwnerId = this.poolId;\n            this.objects[this.objectsPointer + 1 + i] = object;\n        }\n        this.objectsPointer += objectsListSize;\n    }\n\n    private void resizePool() {\n        final int oldCapacity = this.desiredCapacity;\n        this.desiredCapacity *= 2;\n        Object[] temp = new Object[this.desiredCapacity];\n        for(int i = 0 ; i < oldCapacity ; i++){\n            temp[i] = this.objects[i];\n        }\n        this.objects = temp;\n    }",
        "TranslatedCode": "/**\n\n   * Recycle a List of Poolables that this pool is capable of generating.\n\n   * The T instances passed must not already exist inside this or any other ObjectPool instance.\n\n   *\n\n   * @param objects A list of objects of type T to recycle\n\n   */\n\n  public recycleArray(objects: JArrayList<T>) {\n\n    while (objects.size() + this.objectsPointer + 1 > this.desiredCapacity) {\n\n      this.resizePool();\n\n    }\n\n    let objectsListSize = objects.size();\n\n\n\n    // Not relying on recycle(T object) because this is more performant.\n\n    if (this.objects) {\n\n      for (let i = 0; i < objectsListSize; i++) {\n\n        let object: T = objects.get(i);\n\n        if (object.currentOwnerId != Poolable.NO_OWNER) {\n\n          if (object.currentOwnerId == this.poolId) {\n\n            throw new Error(\"The object passed is already stored in this pool!\");\n\n          } else {\n\n            throw new Error(\"The object to recycle already belongs to poolId \" + object.currentOwnerId + \".  Object cannot belong to two different pool instances simultaneously!\");\n\n          }\n\n        }\n\n        object.currentOwnerId = this.poolId;\n\n        this.objects[this.objectsPointer + 1 + i] = object;\n\n      }\n\n    }\n\n    this.objectsPointer += objectsListSize;\n\n  }\n\n\n\n  private resizePool() {\n\n    let oldCapacity = this.desiredCapacity;\n\n    this.desiredCapacity *= 2;\n\n    let temp: Object[] = new Array<Object>(this.desiredCapacity);\n\n    if (this.objects) {\n\n      for (let i = 0; i < oldCapacity; i++) {\n\n        temp[i] = this.objects[i];\n\n      }\n\n    }\n\n    this.objects = temp;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the capacity of this object pool.  Note : The pool will automatically resize\n     * to contain additional objects if the user tries to add more objects than the pool's\n     * capacity allows, but this comes at a performance cost.\n     *\n     * @return The capacity of the pool.\n     */\n    public int getPoolCapacity(){\n        return this.objects.length;\n    }",
        "TranslatedCode": "/**\n   * Returns the capacity of this object pool.  Note : The pool will automatically resize\n   * to contain additional objects if the user tries to add more objects than the pool's\n   * capacity allows, but this comes at a performance cost.\n   *\n   * @return The capacity of the pool.\n   */\n  public getPoolCapacity(): number {\n    return this.objects ? this.objects.length : 0;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the number of objects remaining in the pool, for diagnostic purposes.\n     *\n     * @return The number of objects remaining in the pool.\n     */\n    public int getPoolCount(){\n        return this.objectsPointer + 1;\n    }",
        "TranslatedCode": "/**\n   * Returns the number of objects remaining in the pool, for diagnostic purposes.\n   *\n   * @return The number of objects remaining in the pool.\n   */\n  public getPoolCount(): number {\n    return this.objectsPointer + 1;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public static FSize getInstance(final float width, final float height){\n        FSize result = pool.get();\n        result.width = width;\n        result.height = height;\n        return result;\n    }",
        "TranslatedCode": "public static getInstance(width: number, height: number): FSize {\n    let result: FSize = FSize.pool.get();\n    result.width = width;\n    result.height = height;\n    return result;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean equals(final Object obj) {\n        if (obj == null) {\n            return false;\n        }\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FSize) {\n            final FSize other = (FSize) obj;\n            return width == other.width && height == other.height;\n        }\n        return false;\n    }",
        "TranslatedCode": "public equals(obj: Object): boolean {\n    if (obj == null) {\n      return false;\n    }\n    if (this == obj) {\n      return true;\n    }\n    if (obj instanceof FSize) {\n      let other: FSize = obj as FSize;\n      return this.width == other.width && this.height == other.height;\n    }\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public String toString() {\n        return width + \"x\" + height;\n    }",
        "TranslatedCode": "public toString(): string {\n    return this.width + \"x\" + this.height;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void calculateFinalColor()\n    {\n        if (mColor == null)\n        {\n            mFinalColor = null;\n        } else\n        {\n            int alpha = (int) Math.floor(((mColor >> 24) / 255.0) * (mAlpha / 255.0) * 255.0);\n            mFinalColor = (alpha << 24) | (mColor & 0xffffff);\n        }\n    }",
        "TranslatedCode": "private calculateFinalColor(): void {\n\n    if (this.mColor == 0) {\n      this.mFinalColor = 0;\n    } else {\n      if (typeof this.mColor == 'number') {\n        let alpha: number = Math.floor(((this.mColor >> 24) / 255.0) * (this.mAlpha / 255.0) * 255.0);\n        this.mFinalColor = (alpha << 24) | (this.mColor & 0xffffff);\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void fillRect(Canvas c, Paint paint,\n                         float left, float top, float right, float bottom,\n                         Direction gradientDirection)\n    {\n        switch (mType)\n        {\n            case EMPTY:\n                return;\n\n            case COLOR:\n            {\n                if (mFinalColor == null) return;\n\n                if (isClipPathSupported())\n                {\n                    int save = c.save();\n\n                    c.clipRect(left, top, right, bottom);\n                    c.drawColor(mFinalColor);\n\n                    c.restoreToCount(save);\n                }\n                else\n                {\n                    // save\n                    Paint.Style previous = paint.getStyle();\n                    int previousColor = paint.getColor();\n\n                    // set\n                    paint.setStyle(Paint.Style.FILL);\n                    paint.setColor(mFinalColor);\n\n                    c.drawRect(left, top, right, bottom, paint);\n\n                    // restore\n                    paint.setColor(previousColor);\n                    paint.setStyle(previous);\n                }\n            }\n            break;\n\n            case LINEAR_GRADIENT:\n            {\n                if (mGradientColors == null) return;\n\n                LinearGradient gradient = new LinearGradient(\n                        (int) (gradientDirection == Direction.RIGHT\n                                ? right\n                                : gradientDirection == Direction.LEFT\n                                ? left\n                                : left),\n                        (int) (gradientDirection == Direction.UP\n                                ? bottom\n                                : gradientDirection == Direction.DOWN\n                                ? top\n                                : top),\n                        (int) (gradientDirection == Direction.RIGHT\n                                ? left\n                                : gradientDirection == Direction.LEFT\n                                ? right\n                                : left),\n                        (int) (gradientDirection == Direction.UP\n                                ? top\n                                : gradientDirection == Direction.DOWN\n                                ? bottom\n                                : top),\n                        mGradientColors,\n                        mGradientPositions,\n                        android.graphics.Shader.TileMode.MIRROR);\n\n                paint.setShader(gradient);\n\n                c.drawRect(left, top, right, bottom, paint);\n            }\n            break;\n\n            case DRAWABLE:\n            {\n                if (mDrawable == null) return;\n\n                mDrawable.setBounds((int) left, (int) top, (int) right, (int) bottom);\n                mDrawable.draw(c);\n            }\n            break;\n        }\n    }",
        "TranslatedCode": "public async fillRect(c: CanvasRenderingContext2D, paint: Paint, left: number, top: number, right: number, bottom: number,\n                  gradientDirection: FillDirection, radius?: number, cornerType: RoundCornerType = 'up'): Promise<void> {\n    switch (this.mType) {\n      case FillType.EMPTY:\n        return;\n      case FillType.COLOR:\n        if (this.mFinalColor == null) return;\n        if (this.isClipPathSupported()) {\n\n          c.save();\n          if (radius != undefined && radius > 0) {\n            Utils.fillRoundedRect(c, left, top, right - left, bottom - top, radius, cornerType);\n          }else{\n            c.rect(left, top, right - left, bottom - top);\n          }\n          c.clip();\n          c.fillStyle = this.mFinalColor;\n          c.fill();\n          c.restore()\n        } else {\n          // save\n          let previous: Style = paint.getStyle();\n          let previousColor: number = (paint.getColor() as number);\n\n          // set\n          paint.setStyle(Style.FILL);\n          paint.setColor(this.mFinalColor);\n          Utils.resetContext2DWithoutFont(c, paint);\n          c.beginPath();\n          if(radius != undefined && radius > 0){\n            Utils.fillRoundedRect(c, left, top, right - left, bottom - top, radius, cornerType);\n          }else{\n            c.fillRect(left, top, right - left, bottom - top);\n          }\n          c.closePath();\n\n          // restore\n          paint.setColor(previousColor);\n          paint.setStyle(previous);\n          // return rectP;\n\n        }\n        break;\n      case FillType.LINEAR_GRADIENT:\n\n        let gradient = c.createLinearGradient(Math.floor(gradientDirection == FillDirection.RIGHT ? right : gradientDirection == FillDirection.LEFT ? left : left),\n          Math.floor(gradientDirection == FillDirection.UP ? bottom : gradientDirection == FillDirection.DOWN ? top : top),\n          Math.floor(gradientDirection == FillDirection.RIGHT ? left : gradientDirection == FillDirection.LEFT ? right : left),\n          Math.floor(gradientDirection == FillDirection.UP ? top : gradientDirection == FillDirection.DOWN ? bottom : top))\n        if (this.mGradientColors && this.mGradientColors.length == 2) {\n          for (let i = 0; i < this.mGradientColors.length; i++) {\n            gradient.addColorStop(i, this.mGradientColors[i]);\n          }\n        }\n\n        paint.setFillStyle(gradient);\n        Utils.resetContext2DWithoutFont(c, paint);\n        c.beginPath();\n        if(radius != undefined && radius > 0){\n          Utils.fillRoundedRect(c, left, top, right - left, bottom - top, radius, cornerType);\n        }else{\n          c.rect(left, top, right - left, bottom - top);\n        }\n        c.fill();\n        c.closePath();\n        break;\n\n      case FillType.DRAWABLE:\n        if (this.mDrawable == null) return;\n        c.drawImage(await this.mDrawable.getIcon(), left, top, right - left, bottom - top);\n        break;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void fillPath(Canvas c, Path path, Paint paint,\n                         @Nullable RectF clipRect)\n    {\n        switch (mType)\n        {\n            case EMPTY:\n                return;\n\n            case COLOR:\n            {\n                if (mFinalColor == null) return;\n\n                if (clipRect != null && isClipPathSupported())\n                {\n                    int save = c.save();\n\n                    c.clipPath(path);\n                    c.drawColor(mFinalColor);\n\n                    c.restoreToCount(save);\n                }\n                else\n                {\n                    // save\n                    Paint.Style previous = paint.getStyle();\n                    int previousColor = paint.getColor();\n\n                    // set\n                    paint.setStyle(Paint.Style.FILL);\n                    paint.setColor(mFinalColor);\n\n                    c.drawPath(path, paint);\n\n                    // restore\n                    paint.setColor(previousColor);\n                    paint.setStyle(previous);\n                }\n            }\n            break;\n\n            case LINEAR_GRADIENT:\n            {\n                if (mGradientColors == null) return;\n\n                LinearGradient gradient = new LinearGradient(\n                        0,\n                        0,\n                        c.getWidth(),\n                        c.getHeight(),\n                        mGradientColors,\n                        mGradientPositions,\n                        android.graphics.Shader.TileMode.MIRROR);\n\n                paint.setShader(gradient);\n\n                c.drawPath(path, paint);\n            }\n            break;\n\n            case DRAWABLE:\n            {\n                if (mDrawable == null) return;\n\n                ensureClipPathSupported();\n\n                int save = c.save();\n                c.clipPath(path);\n\n                mDrawable.setBounds(\n                        clipRect == null ? 0 : (int) clipRect.left,\n                        clipRect == null ? 0 : (int) clipRect.top,\n                        clipRect == null ? c.getWidth() : (int) clipRect.right,\n                        clipRect == null ? c.getHeight() : (int) clipRect.bottom);\n                mDrawable.draw(c);\n\n                c.restoreToCount(save);\n            }\n            break;\n        }\n    }",
        "TranslatedCode": "public async fillPath(c: CanvasRenderingContext2D, path: Path2D, paint: Paint, clipRect: MyRect): Promise<void> {\n    // let defaultRect:BackGroundPaint=new BackGroundPaint();\n    switch (this.mType) {\n      case FillType.EMPTY:\n        return;\n\n      case FillType.COLOR:\n        if (this.mFinalColor == null || this.mFinalColor == undefined) return;\n\n        if (clipRect != null && this.isClipPathSupported()) {\n          c.save();\n          c.beginPath();\n          c.fill(path);\n          c.clip();\n          c.fillStyle = this.mFinalColor;\n          c.fill()\n          c.closePath();\n          c.restore();\n\n        } else {\n          // save\n          let previous: Style = paint.getStyle();\n          let previousColor = paint.getColor();\n\n          // set\n          paint.setStyle(Style.FILL);\n          paint.setColor(this.mFinalColor);\n          Utils.resetContext2DWithoutFont(c, paint);\n          c.beginPath();\n          c.fill(path);\n          c.closePath();\n\n          paint.setColor(previousColor);\n          if (previous) {\n            paint.setStyle(previous);\n          }\n\n        }\n        break;\n      case FillType.LINEAR_GRADIENT:\n        if (this.mGradientColors == null) return;\n        let gradient = c.createLinearGradient(0, 0, c.width, c.height);\n        if (this.mGradientColors && this.mGradientColors.length == 2) {\n          for (let i = 0; i < this.mGradientColors.length; i++) {\n            gradient.addColorStop(i, this.mGradientColors[i]);\n          }\n        }\n        paint.setFillStyle(gradient);\n        Utils.resetContext2DWithoutFont(c, paint);\n        c.beginPath();\n        c.fill(path);\n        c.closePath();\n        break;\n      case FillType.DRAWABLE:\n        if (this.mDrawable == null) return;\n\n        this.ensureClipPathSupported();\n\n        c.save();\n        c.beginPath();\n        c.fill(path);\n        c.clip();\n        c.closePath();\n        let leftBounds: number = clipRect == null ? 0 : clipRect.left;\n        let topBounds: number = clipRect == null ? 0 : clipRect.top;\n        let rightBounds: number = clipRect == null ? c.width : clipRect.right;\n        let bottomBounds: number = clipRect == null ? c.height : clipRect.bottom;\n        let icon= await this.mDrawable.getIcon()\n        if (icon) {\n          c.drawImage(icon, leftBounds, topBounds, rightBounds - leftBounds, bottomBounds - topBounds);\n        }\n        c.restore();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void ensureClipPathSupported()\n    {\n        if (Utils.getSDKInt() < 18)\n        {\n            throw new RuntimeException(\"Fill-drawables not (yet) supported below API level 18, \" +\n                    \"this code was run on API level \" + Utils.getSDKInt() + \".\");\n        }\n    }",
        "TranslatedCode": "private ensureClipPathSupported(): void {\n    if (Utils.getSDKInt() < 8) {\n      throw new Error(\"Fill-drawables not (yet) supported below API level 18, \" +\n      \"this code was run on API level \" + Utils.getSDKInt() + \".\");\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Prepares the matrix that transforms values to pixels. Calculates the\n     * scale factors from the charts size and offsets.\n     *\n     * @param xChartMin\n     * @param deltaX\n     * @param deltaY\n     * @param yChartMin\n     */\n    public void prepareMatrixValuePx(float xChartMin, float deltaX, float deltaY, float yChartMin) {\n\n        float scaleX = (float) ((mViewPortHandler.contentWidth()) / deltaX);\n        float scaleY = (float) ((mViewPortHandler.contentHeight()) / deltaY);\n\n        if (Float.isInfinite(scaleX)) {\n            scaleX = 0;\n        }\n        if (Float.isInfinite(scaleY)) {\n            scaleY = 0;\n        }\n\n        // setup all matrices\n        mMatrixValueToPx.reset();\n        mMatrixValueToPx.postTranslate(-xChartMin, -yChartMin);\n        mMatrixValueToPx.postScale(scaleX, -scaleY);\n    }",
        "TranslatedCode": "/**\n   * Prepares the matrix that transforms values to pixels. Calculates the\n   * scale factors from the charts size and offsets.\n   *\n   * @param xChartMin\n   * @param deltaX\n   * @param deltaY\n   * @param yChartMin\n   */\n  public prepareMatrixValuePx(xChartMin: number, deltaX: number, deltaY: number, yChartMin: number) {\n\n    let scaleX: number = this.mViewPortHandler.contentWidth() / deltaX;\n    let scaleY: number = this.mViewPortHandler.contentHeight() / deltaY;\n\n    if (scaleX == Number.MAX_VALUE) {\n      scaleX = 0;\n    }\n    if (scaleY == Number.MAX_VALUE) {\n      scaleY = 0;\n    }\n\n    // setup all matrices\n    this.mMatrixValueToPx.reset();\n    this.mMatrixValueToPx.postTranslate(-xChartMin, -yChartMin);\n    this.mMatrixValueToPx.postScale(scaleX, -scaleY);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Prepares the matrix that contains all offsets.\n     *\n     * @param inverted\n     */\n    public void prepareMatrixOffset(boolean inverted) {\n\n        mMatrixOffset.reset();\n\n        // offset.postTranslate(mOffsetLeft, getHeight() - mOffsetBottom);\n\n        if (!inverted)\n            mMatrixOffset.postTranslate(mViewPortHandler.offsetLeft(),\n                    mViewPortHandler.getChartHeight() - mViewPortHandler.offsetBottom());\n        else {\n            mMatrixOffset\n                    .setTranslate(mViewPortHandler.offsetLeft(), -mViewPortHandler.offsetTop());\n            mMatrixOffset.postScale(1.0f, -1.0f);\n        }\n    }",
        "TranslatedCode": "/**\n   * Prepares the matrix that contains all offsets.\n   *\n   * @param inverted\n   */\n  public prepareMatrixOffset(inverted: boolean) {\n\n    this.mMatrixOffset.reset();\n\n    // offset.postTranslate(mOffsetLeft, getHeight() - mOffsetBottom);\n\n    if (!inverted)\n      this.mMatrixOffset.postTranslate(this.mViewPortHandler.offsetLeft(),\n        this.mViewPortHandler.getChartHeight() - this.mViewPortHandler.offsetBottom());\n    else {\n      this.mMatrixOffset\n        .setTranslate(this.mViewPortHandler.offsetLeft(), -this.mViewPortHandler.offsetTop());\n      this.mMatrixOffset.postScale(1.0, -1.0);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Transforms an List of Entry into a float array containing the x and\n     * y values transformed with all matrices for the BUBBLECHART.\n     *\n     * @param data\n     * @return\n     */\n    public float[] generateTransformedValuesBubble(IBubbleDataSet data, float phaseY, int from, int to) {\n\n        final int count = (to - from + 1) * 2; // (int) Math.ceil((to - from) * phaseX) * 2;\n\n        if (valuePointsForGenerateTransformedValuesBubble.length != count) {\n            valuePointsForGenerateTransformedValuesBubble = new float[count];\n        }\n        float[] valuePoints = valuePointsForGenerateTransformedValuesBubble;\n\n        for (int j = 0; j < count; j += 2) {\n\n            Entry e = data.getEntryForIndex(j / 2 + from);\n\n            if (e != null) {\n                valuePoints[j] = e.getX();\n                valuePoints[j + 1] = e.getY() * phaseY;\n            } else {\n                valuePoints[j] = 0;\n                valuePoints[j + 1] = 0;\n            }\n        }\n\n        getValueToPixelMatrix().mapPoints(valuePoints);\n\n        return valuePoints;\n    }",
        "TranslatedCode": "/**\n   * Transforms an List of Entry into a float array containing the x and\n   * y values transformed with all matrices for the BUBBLECHART.\n   *\n   * @param data\n   * @return\n   */\n  public generateTransformedValuesBubble(data: IBubbleDataSet, phaseY: number, from: number, to: number): number[] {\n\n    const count = (to - from + 1) * 2; // (int) Math.ceil((to - from) * phaseX) * 2;\n\n    if (this.valuePointsForGenerateTransformedValuesBubble.length != count) {\n      this.valuePointsForGenerateTransformedValuesBubble = new Array<number>(count);\n    }\n    let valuePoints: number[] = this.valuePointsForGenerateTransformedValuesBubble;\n\n    for (let j = 0; j < count; j += 2) {\n\n      let e: Entry | null = data.getEntryForIndex(j / 2 + from);\n\n      if (e != null) {\n        valuePoints[j] = e.getX();\n        valuePoints[j + 1] = e.getY() * phaseY;\n      } else {\n        valuePoints[j] = 0;\n        valuePoints[j + 1] = 0;\n      }\n    }\n\n    this.getValueToPixelMatrix().mapPoints(valuePoints);\n\n    return valuePoints;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Transforms an List of Entry into a float array containing the x and\n     * y values transformed with all matrices for the LINECHART.\n     *\n     * @param data\n     * @return\n     */\n    public float[] generateTransformedValuesLine(ILineDataSet data,\n                                                 float phaseX, float phaseY,\n                                                 int min, int max) {\n\n        final int count = ((int) ((max - min) * phaseX) + 1) * 2;\n\n        if (valuePointsForGenerateTransformedValuesLine.length != count) {\n            valuePointsForGenerateTransformedValuesLine = new float[count];\n        }\n        float[] valuePoints = valuePointsForGenerateTransformedValuesLine;\n\n        for (int j = 0; j < count; j += 2) {\n\n            Entry e = data.getEntryForIndex(j / 2 + min);\n\n            if (e != null) {\n                valuePoints[j] = e.getX();\n                valuePoints[j + 1] = e.getY() * phaseY;\n            } else {\n                valuePoints[j] = 0;\n                valuePoints[j + 1] = 0;\n            }\n        }\n\n        getValueToPixelMatrix().mapPoints(valuePoints);\n\n        return valuePoints;\n    }",
        "TranslatedCode": "/**\n   * Transforms an List of Entry into a float array containing the x and\n   * y values transformed with all matrices for the LINECHART.\n   *\n   * @param data\n   * @return\n   */\n  public generateTransformedValuesLine(data: ILineDataSet,\n                                       phaseX: number, phaseY: number,\n                                       min: number, max: number): number[] {\n\n    const count: number = Math.floor((((max - min) * phaseX) + 1) * 2);\n\n    if (this.valuePointsForGenerateTransformedValuesLine.length != count) {\n      this.valuePointsForGenerateTransformedValuesLine = new Array<number>(count);\n    }\n    let valuePoints: number[] = this.valuePointsForGenerateTransformedValuesLine;\n\n    for (let j = 0; j < count; j += 2) {\n\n      let e: Entry | null = data.getEntryForIndex(j / 2 + min);\n\n      if (e != null) {\n        valuePoints[j] = e.getX();\n        valuePoints[j + 1] = e.getY() * phaseY;\n      } else {\n        valuePoints[j] = 0;\n        valuePoints[j + 1] = 0;\n      }\n    }\n\n    this.getValueToPixelMatrix().mapPoints(valuePoints);\n\n    return valuePoints;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Transforms an List of Entry into a float array containing the x and\n     * y values transformed with all matrices for the CANDLESTICKCHART.\n     *\n     * @param data\n     * @return\n     */\n    public float[] generateTransformedValuesCandle(ICandleDataSet data,\n                                                   float phaseX, float phaseY, int from, int to) {\n\n        final int count = (int) ((to - from) * phaseX + 1) * 2;\n\n        if (valuePointsForGenerateTransformedValuesCandle.length != count) {\n            valuePointsForGenerateTransformedValuesCandle = new float[count];\n        }\n        float[] valuePoints = valuePointsForGenerateTransformedValuesCandle;\n\n        for (int j = 0; j < count; j += 2) {\n\n            CandleEntry e = data.getEntryForIndex(j / 2 + from);\n\n            if (e != null) {\n                valuePoints[j] = e.getX();\n                valuePoints[j + 1] = e.getHigh() * phaseY;\n            } else {\n                valuePoints[j] = 0;\n                valuePoints[j + 1] = 0;\n            }\n        }\n\n        getValueToPixelMatrix().mapPoints(valuePoints);\n\n        return valuePoints;\n    }",
        "TranslatedCode": "/**\n   * Transforms an List of Entry into a float array containing the x and\n   * y values transformed with all matrices for the CANDLESTICKCHART.\n   *\n   * @param data\n   * @return\n   */\n  public generateTransformedValuesCandle(data: ICandleDataSet,\n                                         phaseX: number, phaseY: number, fromValue: number, toValue: number): number[] {\n\n    const count: number = Math.floor(((toValue - fromValue) * phaseX + 1) * 2);\n\n    if (this.valuePointsForGenerateTransformedValuesCandle.length != count) {\n      this.valuePointsForGenerateTransformedValuesCandle = new Array<number>(count);\n    }\n    let valuePoints: number[] = this.valuePointsForGenerateTransformedValuesCandle;\n\n    for (let j = 0; j < count; j += 2) {\n\n      let e: CandleEntry | null = data.getEntryForIndex(j / 2 + fromValue);\n\n      if (e != null) {\n        valuePoints[j] = e.getX();\n        valuePoints[j + 1] = e.getHigh() * phaseY;\n      } else {\n        valuePoints[j] = 0;\n        valuePoints[j + 1] = 0;\n      }\n    }\n\n    this.getValueToPixelMatrix().mapPoints(valuePoints);\n\n    return valuePoints;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean hasChartDimens() {\n        if (mChartHeight > 0 && mChartWidth > 0)\n            return true;\n        else\n            return false;\n    }",
        "TranslatedCode": "public hasChartDimens(): boolean {\n    if (this.mChartHeight > 0 && this.mChartWidth > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the smallest extension of the content rect (width or height).\n     *\n     * @return\n     */\n    public float getSmallestContentExtension() {\n        return Math.min(mContentRect.width(), mContentRect.height());\n    }",
        "TranslatedCode": "/**\n   * Returns the smallest extension of the content rect (width or height).\n   *\n   * @return\n   */\n  public getSmallestContentExtension(): number {\n    return Math.min(this.mContentRect.width(), this.mContentRect.height());\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Groups all BarDataSet objects this data object holds together by modifying the x-value of their entries.\n     * Previously set x-values of entries will be overwritten. Leaves space between bars and groups as specified\n     * by the parameters.\n     * Do not forget to call notifyDataSetChanged() on your BarChart object after calling this method.\n     *\n     * @param fromX      the starting point on the x-axis where the grouping should begin\n     * @param groupSpace the space between groups of bars in values (not pixels) e.g. 0.8f for bar width 1f\n     * @param barSpace   the space between individual bars in values (not pixels) e.g. 0.1f for bar width 1f\n     */\n    public void groupBars(float fromX, float groupSpace, float barSpace) {\n\n        int setCount = mDataSets.size();\n        if (setCount <= 1) {\n            throw new RuntimeException(\"BarData needs to hold at least 2 BarDataSets to allow grouping.\");\n        }\n\n        IBarDataSet max = getMaxEntryCountSet();\n        int maxEntryCount = max.getEntryCount();\n\n        float groupSpaceWidthHalf = groupSpace / 2f;\n        float barSpaceHalf = barSpace / 2f;\n        float barWidthHalf = mBarWidth / 2f;\n\n        float interval = getGroupWidth(groupSpace, barSpace);\n\n        for (int i = 0; i < maxEntryCount; i++) {\n\n            float start = fromX;\n            fromX += groupSpaceWidthHalf;\n\n            for (IBarDataSet set : mDataSets) {\n\n                fromX += barSpaceHalf;\n                fromX += barWidthHalf;\n\n                if (i < set.getEntryCount()) {\n\n                    BarEntry entry = set.getEntryForIndex(i);\n\n                    if (entry != null) {\n                        entry.setX(fromX);\n                    }\n                }\n\n                fromX += barWidthHalf;\n                fromX += barSpaceHalf;\n            }\n\n            fromX += groupSpaceWidthHalf;\n            float end = fromX;\n            float innerInterval = end - start;\n            float diff = interval - innerInterval;\n\n            // correct rounding errors\n            if (diff > 0 || diff < 0) {\n                fromX += diff;\n            }\n        }\n\n        notifyDataChanged();\n    }",
        "TranslatedCode": "/**\n   * Groups all BarDataSet objects this data object holds together by modifying the x-value of their entries.\n   * Previously set x-values of entries will be overwritten. Leaves space between bars and groups as specified\n   * by the parameters.\n   * Do not forget to call notifyDataSetChanged() on your BarChart object after calling this method.\n   *\n   * @param fromX      the starting point on the x-axis where the grouping should begin\n   * @param groupSpace the space between groups of bars in values (not pixels) e.g. 0.8f for bar width 1f\n   * @param barSpace   the space between individual bars in values (not pixels) e.g. 0.1f for bar width 1f\n   */\n  public groupBars(fromX: number, groupSpace: number, barSpace: number): void {\n    let dataSets = this.mDataSets;\n    if (dataSets) {\n      let setCount: number = dataSets.size();\n      if (setCount <= 1) {\n        throw new Error(\"BarData needs to hold at least 2 BarDataSets to allow grouping.\");\n      }\n\n      let max: IBarDataSet | null = this.getMaxEntryCountSet();\n      if (max) {\n        let maxEntryCount: number = max.getEntryCount();\n\n        let groupSpaceWidthHalf: number = groupSpace / 2;\n        let barSpaceHalf: number = barSpace / 2;\n        let barWidthHalf: number = this.mBarWidth / 2;\n\n        let interval: number = this.getGroupWidth(groupSpace, barSpace);\n\n        for (let i = 0; i < maxEntryCount; i++) {\n\n          let start: number = fromX;\n          fromX += groupSpaceWidthHalf;\n\n          //for (IBarDataSet set : mDataSets) {\n\n          for (let j = 0; j < dataSets.size(); j++) {\n            let dataSet: IBarDataSet = dataSets.get(j);\n            fromX += barSpaceHalf;\n            fromX += barWidthHalf;\n\n\n            if (i < dataSet.getEntryCount() && dataSet != undefined) {\n\n              let entry: BarEntry = dataSet.getEntryForIndex(i) as BarEntry;\n\n              if (entry) {\n                entry.setX(fromX);\n              }\n            }\n\n            fromX += barWidthHalf;\n            fromX += barSpaceHalf;\n          }\n\n          fromX += groupSpaceWidthHalf;\n          let end: number = fromX;\n          let innerInterval: number = end - start;\n          let diff: number = interval - innerInterval;\n\n\n          // correct rounding errors\n          if (diff > 0 || diff < 0) {\n            fromX += diff;\n          }\n        }\n\n        this.notifyDataChanged();\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "    public DataSet<BarEntry> copy() {\n        List<BarEntry> entries = new ArrayList<BarEntry>();\n        for (int i = 0; i < mEntries.size(); i++) {\n            entries.add(mEntries.get(i).copy());\n        }\n        BarDataSet copied = new BarDataSet(entries, getLabel());\n        copy(copied);\n        return copied;\n    }",
        "TranslatedCode": "public copy(): DataSet<BarEntry> {\n\n    let entries = new JArrayList<BarEntry>();\n\n    if (this.mEntries != null) {\n\n      for (let i = 0; i < this.mEntries.size(); i++) {\n\n        entries.add(this.mEntries.get(i).copy());\n\n      }\n\n    }\n\n    let copied = new BarDataSet(entries, this.getLabel());\n\n    this.copyTo(copied);\n\n    return copied;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void copy(BarDataSet barDataSet) {\n        super.copy(barDataSet);\n        barDataSet.mStackSize = mStackSize;\n        barDataSet.mBarShadowColor = mBarShadowColor;\n        barDataSet.mBarBorderWidth = mBarBorderWidth;\n        barDataSet.mStackLabels = mStackLabels;\n        barDataSet.mHighLightAlpha = mHighLightAlpha;\n    }",
        "TranslatedCode": "protected copyTo(barDataSet: BarDataSet): void {\n\n    super.copyTo(barDataSet);\n\n    barDataSet.mStackSize = this.mStackSize;\n\n    barDataSet.mBarShadowColor = this.mBarShadowColor;\n\n    barDataSet.mBarBorderWidth = this.mBarBorderWidth;\n\n    barDataSet.mStackLabels = this.mStackLabels;\n\n    barDataSet.mHighLightAlpha = this.mHighLightAlpha;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Calculates the total number of entries this DataSet represents, including\n     * stacks. All values belonging to a stack are calculated separately.\n     */\n    private void calcEntryCountIncludingStacks(List<BarEntry> yVals) {\n\n        mEntryCountStacks = 0;\n\n        for (int i = 0; i < yVals.size(); i++) {\n\n            float[] vals = yVals.get(i).getYVals();\n\n            if (vals == null)\n                mEntryCountStacks++;\n            else\n                mEntryCountStacks += vals.length;\n        }\n    }",
        "TranslatedCode": "/**\n\n   * Calculates the total number of entries this DataSet represents, including\n\n   * stacks. All values belonging to a stack are calculated separately.\n\n   */\n\n  private calcEntryCountIncludingStacks(yVals: JList<BarEntry>): void {\n\n\n\n    this.mEntryCountStacks = 0;\n\n\n\n    for (let i = 0; i < yVals.length(); i++) {\n\n\n\n      let vals: number[] | null = yVals.get(i).getYVals();\n\n\n\n      if (!vals)\n\n        this.mEntryCountStacks++;\n\n      else\n\n        this.mEntryCountStacks += vals.length;\n\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * calculates the maximum stacksize that occurs in the Entries array of this\n     * DataSet\n     */\n    private void calcStackSize(List<BarEntry> yVals) {\n\n        for (int i = 0; i < yVals.size(); i++) {\n\n            float[] vals = yVals.get(i).getYVals();\n\n            if (vals != null && vals.length > mStackSize)\n                mStackSize = vals.length;\n        }\n    }",
        "TranslatedCode": "/**\n\n   * calculates the maximum stacksize that occurs in the Entries array of this\n\n   * DataSet\n\n   */\n\n  private calcStackSize(yVals: JList<BarEntry>): void {\n\n\n\n    for (let i = 0; i < yVals.length(); i++) {\n\n\n\n      let vals: number[] | null = yVals.get(i).getYVals();\n\n\n\n      if (vals != null && vals.length > this.mStackSize)\n\n        this.mStackSize = vals.length;\n\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void calcMinMax(BarEntry e) {\n\n        if (e != null && !Float.isNaN(e.getY())) {\n\n            if (e.getYVals() == null) {\n\n                if (e.getY() < mYMin)\n                    mYMin = e.getY();\n\n                if (e.getY() > mYMax)\n                    mYMax = e.getY();\n            } else {\n\n                if (-e.getNegativeSum() < mYMin)\n                    mYMin = -e.getNegativeSum();\n\n                if (e.getPositiveSum() > mYMax)\n                    mYMax = e.getPositiveSum();\n            }\n\n            calcMinMaxX(e);\n        }\n    }",
        "TranslatedCode": "public myCalcMinMax(e: BarEntry): void {\n\n    if (e != null && !Number.isNaN(e.getY())) {\n\n\n\n      if (!e.getYVals()) {\n\n\n\n        if (e.getY() < this.mYMin)\n\n          this.mYMin = e.getY();\n\n\n\n        if (e.getY() > this.mYMax)\n\n          this.mYMax = e.getY();\n\n      } else {\n\n\n\n        if (-e.getNegativeSum() < this.mYMin)\n\n          this.mYMin = -e.getNegativeSum();\n\n\n\n        if (e.getPositiveSum() > this.mYMax)\n\n          this.mYMax = e.getPositiveSum();\n\n      }\n\n      this.calcMinMaxX(e);\n\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getSumBelow(int stackIndex) {\n\n        if (mYVals == null)\n            return 0;\n\n        float remainder = 0f;\n        int index = mYVals.length - 1;\n\n        while (index > stackIndex && index >= 0) {\n            remainder += mYVals[index];\n            index--;\n        }\n\n        return remainder;\n    }",
        "TranslatedCode": "public getSumBelow(stackIndex: number): number {\n\n    if (!this.mYVals)\n\n      return 0;\n\n    let remainder: number = 0;\n\n    let index = this.mYVals.length\n\n\n\n    while (index > stackIndex && index >= 0) {\n\n      remainder += this.mYVals[index];\n\n      index--;\n\n    }\n\n    return remainder;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void calcPosNegSum() {\n\n        if (mYVals == null) {\n            mNegativeSum = 0;\n            mPositiveSum = 0;\n            return;\n        }\n\n        float sumNeg = 0f;\n        float sumPos = 0f;\n\n        for (float f : mYVals) {\n            if (f <= 0f)\n                sumNeg += Math.abs(f);\n            else\n                sumPos += f;\n        }\n\n        mNegativeSum = sumNeg;\n        mPositiveSum = sumPos;\n    }",
        "TranslatedCode": "private calcPosNegSum(): void {\n\n\n\n    if (this.mYVals == null) {\n\n      this.mNegativeSum = 0;\n\n      this.mPositiveSum = 0;\n\n      return;\n\n    }\n\n\n\n    let sumNeg: number = 0;\n\n    let sumPos: number = 0;\n\n\n\n    for (let f of this.mYVals) {\n\n      if (f <= 0)\n\n        sumNeg += Math.abs(f);\n\n      else\n\n        sumPos += f;\n\n    }\n\n\n\n    this.mNegativeSum = sumNeg;\n\n    this.mPositiveSum = sumPos;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Calculates the sum across all values of the given stack.\n     *\n     * @param vals\n     * @return\n     */\n    private static float calcSum(float[] vals) {\n\n        if (vals == null)\n            return 0f;\n\n        float sum = 0f;\n\n        for (float f : vals)\n            sum += f;\n\n        return sum;\n    }",
        "TranslatedCode": "/**\n\n   * Calculates the sum across all values of the given stack.\n\n   *\n\n   * @param vals\n\n   * @return\n\n   */\n\n  public static calcSum(vals: number[]): number {\n\n\n\n    if (vals == null)\n\n      return 0;\n\n    let sum: number = 0;\n\n    for (let f of vals)\n\n      sum += f;\n\n    return sum;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void calcRanges() {\n\n        float[] values = getYVals();\n\n        if (values == null || values.length == 0)\n            return;\n\n        mRanges = new Range[values.length];\n\n        float negRemain = -getNegativeSum();\n        float posRemain = 0f;\n\n        for (int i = 0; i < mRanges.length; i++) {\n\n            float value = values[i];\n\n            if (value < 0) {\n                mRanges[i] = new Range(negRemain, negRemain - value);\n                negRemain -= value;\n            } else {\n                mRanges[i] = new Range(posRemain, posRemain + value);\n                posRemain += value;\n            }\n        }\n    }",
        "TranslatedCode": "protected calcRanges(): void {\n\n\n\n    let values: number[] | null = this.getYVals();\n\n\n\n    if (values == null || values.length == 0)\n\n      return;\n\n\n\n    this.mRanges = new Array(values.length);\n\n\n\n    let negRemain: number = -this.getNegativeSum();\n\n    let posRemain: number = 0;\n\n\n\n    for (let i = 0; i < this.mRanges.length; i++) {\n\n\n\n      let value: number = values[i];\n\n\n\n      if (value < 0) {\n\n        this.mRanges[i] = new Range(negRemain, negRemain - value);\n\n        negRemain -= value;\n\n      } else {\n\n        this.mRanges[i] = new Range(posRemain, posRemain + value);\n\n        posRemain += value;\n\n      }\n\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Sets the colors that should be used fore this DataSet. Colors are reused\n     * as soon as the number of Entries the DataSet represents is higher than\n     * the size of the colors array. You can use\n     * \"new int[] { R.color.red, R.color.green, ... }\" to provide colors for\n     * this method. Internally, the colors are resolved using\n     * getResources().getColor(...)\n     *\n     * @param colors\n     */\n    public void setColors(int[] colors, Context c) {\n\n        if (mColors == null) {\n            mColors = new ArrayList<>();\n        }\n\n        mColors.clear();\n\n        for (int color : colors) {\n            mColors.add(c.getResources().getColor(color));\n        }\n    }",
        "TranslatedCode": "/**\n\n   * Sets the colors that should be used fore this DataSet. Colors are reused\n\n   * as soon as the number of Entries the DataSet represents is higher than\n\n   * the size of the colors array. You can use\n\n   * \"new int[] { R.color.red, R.color.green, ... }\" to provide colors for\n\n   * this method. Internally, the colors are resolved using\n\n   * getResources().getColor(...)\n\n   *\n\n   * @param colors\n\n   */\n\n  public setColorsByArr(colors: number[]): void {\n\n\n\n    if (this.mColors == null) {\n\n      this.mColors = new JArrayList <Number>();\n\n    }\n\n    this.mColors.clear();\n\n    for (let color of colors) {\n\n      this.mColors.add(color);\n\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Adds a new color to the colors array of the DataSet.\n     *\n     * @param color\n     */\n    public void addColor(int color) {\n        if (mColors == null)\n            mColors = new ArrayList<Integer>();\n        mColors.add(color);\n    }",
        "TranslatedCode": "/**\n\n   * Adds a new color to the colors array of the DataSet.\n\n   *\n\n   * @param color\n\n   */\n\n  public addColor(color: number): void {\n\n    if (this.mColors == null) {\n\n      this.mColors = new JArrayList<Number>();\n\n    }\n\n    this.mColors.add(color);\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setValueFormatter(IValueFormatter f) {\n\n        if (f == null)\n            return;\n        else\n            mValueFormatter = f;\n    }",
        "TranslatedCode": "public setValueFormatter(f: IValueFormatter): void {\n\n\n\n    if (f == null)\n\n      return;\n\n    else\n\n      this.mValueFormatter = f;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public IValueFormatter getValueFormatter() {\n        if (needsFormatter())\n            return Utils.getDefaultValueFormatter();\n        return mValueFormatter;\n    }",
        "TranslatedCode": "public getValueFormatter(): IValueFormatter | null {\n\n    if (this.needsFormatter()) {\n\n      return Utils.getDefaultValueFormatter();\n\n    }\n\n    return this.mValueFormatter;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setValueTextColor(int color) {\n        mValueColors.clear();\n        mValueColors.add(color);\n    }",
        "TranslatedCode": "public setValueTextColor(color: number): void {\n\n    if (this.mValueColors) {\n\n      this.mValueColors.clear();\n\n      this.mValueColors.add(color);\n\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int getIndexInEntries(int xIndex) {\n\n        for (int i = 0; i < getEntryCount(); i++) {\n            if (xIndex == getEntryForIndex(i).getX())\n                return i;\n        }\n\n        return -1;\n    }",
        "TranslatedCode": "public getIndexInEntries(xIndex: number): number {\n    for (let i = 0; i < this.getEntryCount(); i++) {\n      let dataArray: T | null = this.getEntryForIndex(i);\n      if (dataArray) {\n        if (xIndex == dataArray.getX()) {\n          return i;\n        } else {\n          return -1;\n        }\n      }\n    }\n    return -1;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean removeFirst() {\n\n        if (getEntryCount() > 0) {\n\n            T entry = getEntryForIndex(0);\n            return removeEntry(entry);\n        } else\n            return false;\n    }",
        "TranslatedCode": "public removeFirst(): boolean {\n    if (this.getEntryCount() > 0) {\n      let entry: T | null = this.getEntryForIndex(0);\n      if (entry) {\n        return this.removeEntry(entry);\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean removeLast() {\n\n        if (getEntryCount() > 0) {\n\n            T e = getEntryForIndex(getEntryCount() - 1);\n            return removeEntry(e);\n        } else\n            return false;\n    }",
        "TranslatedCode": "public removeLast(): boolean {\n    if (this.getEntryCount() > 0) {\n      let e: T | null = this.getEntryForIndex(this.getEntryCount() - 1);\n      if (e) {\n        return this.removeEntry(e);\n      }\n      return true;\n    } else\n      return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean contains(T e) {\n\n        for (int i = 0; i < getEntryCount(); i++) {\n            if (getEntryForIndex(i).equals(e))\n                return true;\n        }\n\n        return false;\n    }",
        "TranslatedCode": "public contains(e: T): boolean {\n    for (let i = 0; i < this.getEntryCount(); i++) {\n      if (this.getEntryForIndex(i) == e)\n        return true;\n    }\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean removeEntry(int index) {\n\n        T e = getEntryForIndex(index);\n        return removeEntry(e);\n    }",
        "TranslatedCode": "public removeEntryByIndex(index: number): boolean {\n    let e: T | null = this.getEntryForIndex(index);\n    if (e) {\n      return this.removeEntry(e);\n    }\n    return true;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void calcMinMax(BubbleEntry e) {\n        super.calcMinMax(e);\n\n        final float size = e.getSize();\n\n        if (size > mMaxSize) {\n            mMaxSize = size;\n        }\n    }",
        "TranslatedCode": "public myCalcMinMax(e ?: BubbleEntry): void {\n    super.myCalcMinMax(e);\n    if (e) {\n      let size: number = e.getSize();\n      if (size > BubbleDataSet.mMaxSize) {\n        BubbleDataSet.mMaxSize = size;\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DataSet<BubbleEntry> copy() {\n        List<BubbleEntry> entries = new ArrayList<BubbleEntry>();\n        for (int i = 0; i < mEntries.size(); i++) {\n            entries.add(mEntries.get(i).copy());\n        }\n        BubbleDataSet copied = new BubbleDataSet(entries, getLabel());\n        copy(copied);\n        return copied;\n    }",
        "TranslatedCode": "public copy(): DataSet<BubbleEntry> {\n    let entries: JArrayList<BubbleEntry> = new JArrayList<BubbleEntry>();\n    if (this.mEntries != null) {\n      for (let i: number = 0; i < this.mEntries.size(); i++) {\n        entries.add(this.mEntries.get(i).copy());\n      }\n    }\n    let copied = new BubbleDataSet(entries, this.getLabel());\n    this.copyDataSet(copied);\n    return copied;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BubbleEntry copy() {\n\n        BubbleEntry c = new BubbleEntry(getX(), getY(), mSize, getData());\n        return c;\n    }",
        "TranslatedCode": "public copy(): BubbleEntry {\n    let data: Object | null = this.getData();\n    if (!data) {\n      return new BubbleEntry(this.getX(), this.getY(), this.mSize);\n    } else {\n      return new BubbleEntry(this.getX(), this.getY(), this.mSize, undefined, data);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getSize() {\n        return mSize;\n    }",
        "TranslatedCode": "public getSize(): number {\n    return this.mSize;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DataSet<CandleEntry> copy() {\n        List<CandleEntry> entries = new ArrayList<CandleEntry>();\n        for (int i = 0; i < mEntries.size(); i++) {\n            entries.add(mEntries.get(i).copy());\n        }\n        CandleDataSet copied = new CandleDataSet(entries, getLabel());\n        copy(copied);\n        return copied;\n    }",
        "TranslatedCode": "public copy(): DataSet<CandleEntry> {\n    let entries = new JArrayList<CandleEntry>();\n    if (this.mEntries != null) {\n      for (let i = 0; i < this.mEntries.size(); i++) {\n        entries.add(this.mEntries.get(i).copy());\n      }\n    }\n    let copied = new CandleDataSet(entries, this.getLabel());\n    this.copyTo(copied);\n    return copied;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void calcMinMax(CandleEntry e) {\n\n        if (e.getLow() < mYMin)\n            mYMin = e.getLow();\n\n        if (e.getHigh() > mYMax)\n            mYMax = e.getHigh();\n\n        calcMinMaxX(e);\n    }",
        "TranslatedCode": "public myCalcMinMax(e: CandleEntry): void {\n\n    if (e.getLow() < this.mYMin)\n      this.mYMin = e.getLow();\n\n    if (e.getHigh() > this.mYMax)\n      this.mYMax = e.getHigh();\n\n    this.calcMinMaxX(e);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void calcMinMaxY(CandleEntry e) {\n\n        if (e.getHigh() < mYMin)\n            mYMin = e.getHigh();\n\n        if (e.getHigh() > mYMax)\n            mYMax = e.getHigh();\n\n        if (e.getLow() < mYMin)\n            mYMin = e.getLow();\n\n        if (e.getLow() > mYMax)\n            mYMax = e.getLow();\n    }",
        "TranslatedCode": "protected myCalcMinMaxY(e: CandleEntry): void {\n\n    if (e.getHigh() < this.mYMin)\n      this.mYMin = e.getHigh();\n\n    if (e.getHigh() > this.mYMax)\n      this.mYMax = e.getHigh();\n\n    if (e.getLow() < this.mYMin)\n      this.mYMin = e.getLow();\n\n    if (e.getLow() > this.mYMax)\n      this.mYMax = e.getLow();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Sets the space that is left out on the left and right side of each\n     * candle, default 0.1f (10%), max 0.45f, min 0f\n     *\n     * @param space\n     */\n    public void setBarSpace(float space) {\n\n        if (space < 0f)\n            space = 0f;\n        if (space > 0.45f)\n            space = 0.45f;\n\n        mBarSpace = space;\n    }",
        "TranslatedCode": "/**\n   * Sets the space that is left out on the left and right side of each\n   * candle, default 0.1f (10%), max 0.45f, min 0f\n   *\n   * @param space\n   */\n  public setBarSpace(space: number): void {\n\n    if (space < 0)\n      space = 0;\n    if (space > 0.45)\n      space = 0.45;\n\n    this.mBarSpace = space;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getShadowWidth() {\n        return mShadowWidth;\n    }",
        "TranslatedCode": "public getShadowWidth(): number {\n    return this.mShadowWidth;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the overall range (difference) between shadow-high and\n     * shadow-low.\n     *\n     * @return\n     */\n    public float getShadowRange() {\n        return Math.abs(mShadowHigh - mShadowLow);\n    }",
        "TranslatedCode": "public getShadowRange(): number {\n\n    return Math.abs(this.mShadowHigh - this.mShadowLow);\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the body size (difference between open and close).\n     *\n     * @return\n     */\n    public float getBodyRange() {\n        return Math.abs(mOpen - mClose);\n    }",
        "TranslatedCode": "public getBodyRange(): number {\n    return Math.abs(this.mOpen - this.mClose);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Created because Arrays.asList(...) does not support modification.\n     *\n     * @param array\n     * @return\n     */\n    private List<T> arrayToList(T[] array) {\n\n        List<T> list = new ArrayList<>();\n\n        for (T set : array) {\n            list.add(set);\n        }\n\n        return list;\n    }",
        "TranslatedCode": "/**\n   * Created because Arrays.asList(...) does not support modification.\n   *\n   * @param array\n   * @return\n   */\n  private arrayToList(array: T[]): JArrayList<T> {\n\n    let list = new JArrayList<T>();\n\n    for (let i = 0; i < array.length; i++) {\n      let data: T = array[i];\n      list.add(data);\n    }\n\n    return list;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Calc minimum and maximum y-values over all DataSets.\n     * Tell DataSets to recalculate their min and max y-values, this is only needed for autoScaleMinMax.\n     *\n     * @param fromX the x-value to start the calculation from\n     * @param toX   the x-value to which the calculation should be performed\n     */\n    public void calcMinMaxY(float fromX, float toX) {\n\n        for (T set : mDataSets) {\n            set.calcMinMaxY(fromX, toX);\n        }\n\n        // apply the new data\n        calcMinMax();\n    }",
        "TranslatedCode": "/**\n   * Calc minimum and maximum y-values over all DataSets.\n   * Tell DataSets to recalculate their min and max y-values, this is only needed for autoScaleMinMax.\n   *\n   * @param fromX the x-value to start the calculation from\n   * @param toX   the x-value to which the calculation should be performed\n   */\n  public calcMinMaxY(fromX: number, toX: number): void {\n    if (this.mDataSets) {\n      for (let i = 0; i < this.mDataSets.listSize; i++) {\n        let data: T = this.mDataSets.at(i);\n        data.calcMinMaxY(fromX, toX);\n      }\n      // apply the new data\n      this.calcMinMax();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Calc minimum and maximum values (both x and y) over all DataSets.\n     */\n    protected void calcMinMax() {\n\n        if (mDataSets == null)\n            return;\n\n        mYMax = -Float.MAX_VALUE;\n        mYMin = Float.MAX_VALUE;\n        mXMax = -Float.MAX_VALUE;\n        mXMin = Float.MAX_VALUE;\n\n        for (T set : mDataSets) {\n            calcMinMax(set);\n        }\n\n        mLeftAxisMax = -Float.MAX_VALUE;\n        mLeftAxisMin = Float.MAX_VALUE;\n        mRightAxisMax = -Float.MAX_VALUE;\n        mRightAxisMin = Float.MAX_VALUE;\n\n        // left axis\n        T firstLeft = getFirstLeft(mDataSets);\n\n        if (firstLeft != null) {\n\n            mLeftAxisMax = firstLeft.getYMax();\n            mLeftAxisMin = firstLeft.getYMin();\n\n            for (T dataSet : mDataSets) {\n                if (dataSet.getAxisDependency() == AxisDependency.LEFT) {\n                    if (dataSet.getYMin() < mLeftAxisMin)\n                        mLeftAxisMin = dataSet.getYMin();\n\n                    if (dataSet.getYMax() > mLeftAxisMax)\n                        mLeftAxisMax = dataSet.getYMax();\n                }\n            }\n        }\n\n        // right axis\n        T firstRight = getFirstRight(mDataSets);\n\n        if (firstRight != null) {\n\n            mRightAxisMax = firstRight.getYMax();\n            mRightAxisMin = firstRight.getYMin();\n\n            for (T dataSet : mDataSets) {\n                if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {\n                    if (dataSet.getYMin() < mRightAxisMin)\n                        mRightAxisMin = dataSet.getYMin();\n\n                    if (dataSet.getYMax() > mRightAxisMax)\n                        mRightAxisMax = dataSet.getYMax();\n                }\n            }\n        }\n    }",
        "TranslatedCode": "/**\n   * Calc minimum and maximum values (both x and y) over all DataSets.\n   */\n  public calcMinMax() {\n\n    if (this.mDataSets == null)\n      return;\n\n    this.mYMax = -Number.MAX_VALUE;\n    this.mYMin = Number.MAX_VALUE;\n    this.mXMax = -Number.MAX_VALUE;\n    this.mXMin = Number.MAX_VALUE;\n\n    for (let dataSet of this.mDataSets.dataSource) {\n      this.calcMinMax1(dataSet);\n    }\n\n    this.mLeftAxisMax = -Number.MAX_VALUE;\n    this.mLeftAxisMin = Number.MAX_VALUE;\n    this.mRightAxisMax = -Number.MAX_VALUE;\n    this.mRightAxisMin = Number.MAX_VALUE;\n\n    // left axis\n    let firstLeft: T | null = this.getFirstLeft(this.mDataSets);\n\n    if (firstLeft) {\n\n      this.mLeftAxisMax = firstLeft.getYMax();\n      this.mLeftAxisMin = firstLeft.getYMin();\n\n      for (let dataSet of this.mDataSets.dataSource) {\n        if (dataSet.getAxisDependency() == AxisDependency.LEFT) {\n          if (dataSet.getYMin() < this.mLeftAxisMin)\n            this.mLeftAxisMin = dataSet.getYMin();\n\n          if (dataSet.getYMax() > this.mLeftAxisMax)\n            this.mLeftAxisMax = dataSet.getYMax();\n        }\n      }\n    }\n\n    // right axis\n    let firstRight: T | null = this.getFirstRight(this.mDataSets);\n\n    if (firstRight) {\n\n      this.mRightAxisMax = firstRight.getYMax();\n      this.mRightAxisMin = firstRight.getYMin();\n\n      for (let dataSet of this.mDataSets.dataSource) {\n        if (dataSet.getAxisDependency() == AxisDependency.RIGHT) {\n          if (dataSet.getYMin() < this.mRightAxisMin)\n            this.mRightAxisMin = dataSet.getYMin();\n\n          if (dataSet.getYMax() > this.mRightAxisMax)\n            this.mRightAxisMax = dataSet.getYMax();\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * returns the number of LineDataSets this object contains\n     *\n     * @return\n     */\n    public int getDataSetCount() {\n        if (mDataSets == null)\n            return 0;\n        return mDataSets.size();\n    }",
        "TranslatedCode": "/**\n   * returns the number of LineDataSets this object contains\n   *\n   * @return\n   */\n  public getDataSetCount(): number {\n    if (this.mDataSets == null) {\n      return 0;\n    }\n\n    return this.mDataSets.listSize;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the smallest y-value the data object contains.\n     *\n     * @return\n     */\n    public float getYMin() {\n        return mYMin;\n    }\n\n    /**\n     * Returns the minimum y-value for the specified axis.\n     *\n     * @param axis\n     * @return\n     */\n    public float getYMin(AxisDependency axis) {\n        if (axis == AxisDependency.LEFT) {\n\n            if (mLeftAxisMin == Float.MAX_VALUE) {\n                return mRightAxisMin;\n            } else\n                return mLeftAxisMin;\n        } else {\n            if (mRightAxisMin == Float.MAX_VALUE) {\n                return mLeftAxisMin;\n            } else\n                return mRightAxisMin;\n        }\n    }",
        "TranslatedCode": "public getYMin(axis ?: AxisDependency): number {\n    if (axis == null) {\n      return this.mYMin;\n    }\n    if (axis == AxisDependency.LEFT) {\n\n      if (this.mLeftAxisMin == Number.MAX_VALUE) {\n        return this.mRightAxisMin;\n      } else\n        return this.mLeftAxisMin;\n    } else {\n      if (this.mRightAxisMin == Number.MAX_VALUE) {\n        return this.mLeftAxisMin;\n      } else\n        return this.mRightAxisMin;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the greatest y-value the data object contains.\n     *\n     * @return\n     */\n    public float getYMax() {\n        return mYMax;\n    }\n\n    /**\n     * Returns the maximum y-value for the specified axis.\n     *\n     * @param axis\n     * @return\n     */\n    public float getYMax(AxisDependency axis) {\n        if (axis == AxisDependency.LEFT) {\n\n            if (mLeftAxisMax == -Float.MAX_VALUE) {\n                return mRightAxisMax;\n            } else\n                return mLeftAxisMax;\n        } else {\n            if (mRightAxisMax == -Float.MAX_VALUE) {\n                return mLeftAxisMax;\n            } else\n                return mRightAxisMax;\n        }\n    }",
        "TranslatedCode": "public getYMax(axis ?: AxisDependency): number {\n    if (axis == null) {\n      return this.mYMax;\n    }\n    if (axis == AxisDependency.LEFT) {\n\n      if (this.mLeftAxisMax == -Number.MAX_VALUE) {\n        return this.mRightAxisMax;\n      } else\n        return this.mLeftAxisMax;\n    } else {\n      if (this.mRightAxisMax == -Number.MAX_VALUE) {\n        return this.mLeftAxisMax;\n      } else\n        return this.mRightAxisMax;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Retrieve the index of a DataSet with a specific label from the ChartData.\n     * Search can be case sensitive or not. IMPORTANT: This method does\n     * calculations at runtime, do not over-use in performance critical\n     * situations.\n     *\n     * @param dataSets   the DataSet array to search\n     * @param label\n     * @param ignorecase if true, the search is not case-sensitive\n     * @return\n     */\n    protected int getDataSetIndexByLabel(List<T> dataSets, String label,\n                                         boolean ignorecase) {\n\n        if (ignorecase) {\n            for (int i = 0; i < dataSets.size(); i++)\n                if (label.equalsIgnoreCase(dataSets.get(i).getLabel()))\n                    return i;\n        } else {\n            for (int i = 0; i < dataSets.size(); i++)\n                if (label.equals(dataSets.get(i).getLabel()))\n                    return i;\n        }\n\n        return -1;\n    }\n",
        "TranslatedCode": "/**\n   * Retrieve the index of a DataSet with a specific label from the ChartData.\n   * Search can be case sensitive or not. IMPORTANT: This method does\n   * calculations at runtime, do not over-use in performance critical\n   * situations.\n   *\n   * @param dataSets   the DataSet array to search\n   * @param label\n   * @param ignorecase if true, the search is not case-sensitive\n   * @return\n   */\n  protected getDataSetIndexByLabel(dataSets: JArrayList<T>, label: string,\n                                   ignorecase: boolean): number {\n\n    if (ignorecase) {\n      for (let i: number = 0; i < dataSets.size(); i++)\n        if (label.toLowerCase() == dataSets.get(i).getLabel().toLowerCase())\n          return i;\n    } else {\n      for (let i: number = 0; i < dataSets.size(); i++)\n        if (label == dataSets.get(i).getLabel())\n          return i;\n    }\n\n    return -1;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the labels of all DataSets as a string array.\n     *\n     * @return\n     */\n    public String[] getDataSetLabels() {\n\n        String[] types = new String[mDataSets.size()];\n\n        for (int i = 0; i < mDataSets.size(); i++) {\n            types[i] = mDataSets.get(i).getLabel();\n        }\n\n        return types;\n    }",
        "TranslatedCode": "/**\n   * Returns the labels of all DataSets as a string array.\n   *\n   * @return\n   */\n  public getDataSetLabels(): string[] {\n    let size: number = 0;\n    if (this.mDataSets) {\n      size = this.mDataSets.listSize;\n    }\n    let types: string[] = new Array(size);\n    if (this.mDataSets) {\n      for (let i: number = 0; i < this.mDataSets.listSize; i++) {\n        types[i] = this.mDataSets.get(i).getLabel();\n      }\n    }\n\n    return types;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Get the Entry for a corresponding highlight object\n     *\n     * @param highlight\n     * @return the entry that is highlighted\n     */\n    public Entry getEntryForHighlight(Highlight highlight) {\n        if (highlight.getDataSetIndex() >= mDataSets.size())\n            return null;\n        else {\n            return mDataSets.get(highlight.getDataSetIndex()).getEntryForXValue(highlight.getX(), highlight.getY());\n        }\n    }",
        "TranslatedCode": "/**\n   * Get the Entry for a corresponding highlight object\n   *\n   * @param highlight\n   * @return the entry that is highlighted\n   */\n  public getEntryForHighlight(highlight: Highlight): EntryOhos | null {\n    if (!this.mDataSets) {\n      return null;\n    }\n    if (highlight.getDataSetIndex() >= this.mDataSets.size())\n      return null;\n    else {\n      return this.mDataSets.get(highlight.getDataSetIndex()).getEntryForXValue(highlight.getX(), highlight.getY());\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the DataSet object with the given label. Search can be case\n     * sensitive or not. IMPORTANT: This method does calculations at runtime.\n     * Use with care in performance critical situations.\n     *\n     * @param label\n     * @param ignorecase\n     * @return\n     */\n    public T getDataSetByLabel(String label, boolean ignorecase) {\n\n        int index = getDataSetIndexByLabel(mDataSets, label, ignorecase);\n\n        if (index < 0 || index >= mDataSets.size())\n            return null;\n        else\n            return mDataSets.get(index);\n    }",
        "TranslatedCode": "/**\n   * Returns the DataSet object with the given label. Search can be case\n   * sensitive or not. IMPORTANT: This method does calculations at runtime.\n   * Use with care in performance critical situations.\n   *\n   * @param label\n   * @param ignorecase\n   * @return\n   */\n  public getDataSetByLabel(label: string, ignorecase: boolean): T | null {\n    if (!this.mDataSets) {\n      return null;\n    }\n    let index: number = this.getDataSetIndexByLabel(this.mDataSets, label, ignorecase);\n\n    if (index < 0 || index >= this.mDataSets.size())\n      return null;\n    else\n      return this.mDataSets.get(index);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public T getDataSetByIndex(int index) {\n\n        if (mDataSets == null || index < 0 || index >= mDataSets.size())\n            return null;\n\n        return mDataSets.get(index);\n    }",
        "TranslatedCode": "public getDataSetByIndex(index: number): T | null {\n\n    if (this.mDataSets == null || index < 0 || index >= this.mDataSets.size())\n      return null;\n\n    return this.mDataSets.get(index);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Adds a DataSet dynamically.\n     *\n     * @param d\n     */\n    public void addDataSet(T d) {\n\n        if (d == null)\n            return;\n\n        calcMinMax(d);\n\n        mDataSets.add(d);\n    }\n",
        "TranslatedCode": "/**\n   * Adds a DataSet dynamically.\n   *\n   * @param d\n   */\n  public addDataSet(d: T): void {\n\n    if (d == null)\n      return;\n\n    this.calcMinMax1(d);\n    if (this.mDataSets) {\n      this.mDataSets.add(d);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Removes the given DataSet from this data object. Also recalculates all\n     * minimum and maximum values. Returns true if a DataSet was removed, false\n     * if no DataSet could be removed.\n     *\n     * @param d\n     */\n    public boolean removeDataSet(T d) {\n\n        if (d == null)\n            return false;\n\n        boolean removed = mDataSets.remove(d);\n\n        // if a DataSet was removed\n        if (removed) {\n            notifyDataChanged();\n        }\n\n        return removed;\n    }",
        "TranslatedCode": "/**\n   * Removes the given DataSet from this data object. Also recalculates all\n   * minimum and maximum values. Returns true if a DataSet was removed, false\n   * if no DataSet could be removed.\n   *\n   * @param d\n   */\n  public removeDataSet(d: T): boolean {\n\n    if (d == null)\n      return false;\n    if (!this.mDataSets) {\n      return true;\n    }\n    let removed: boolean = this.mDataSets.remove(d);\n\n    // if a DataSet was removed\n    if (removed) {\n      this.notifyDataChanged();\n    }\n\n    return removed;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Removes the DataSet at the given index in the DataSet array from the data\n     * object. Also recalculates all minimum and maximum values. Returns true if\n     * a DataSet was removed, false if no DataSet could be removed.\n     *\n     * @param index\n     */\n    public boolean removeDataSet(int index) {\n\n        if (index >= mDataSets.size() || index < 0)\n            return false;\n\n        T set = mDataSets.get(index);\n        return removeDataSet(set);\n    }",
        "TranslatedCode": "/**\n   * Removes the DataSet at the given index in the DataSet array from the data\n   * object. Also recalculates all minimum and maximum values. Returns true if\n   * a DataSet was removed, false if no DataSet could be removed.\n   *\n   * @param index\n   */\n  public removeDataSetByIndex(index: number): boolean {\n    if (!this.mDataSets) {\n      return false;\n    }\n    if (index >= this.mDataSets.size() || index < 0)\n      return false;\n\n    let data: T = this.mDataSets.get(index);\n    return this.removeDataSet(data);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Adds an Entry to the DataSet at the specified index.\n     * Entries are added to the end of the list.\n     *\n     * @param e\n     * @param dataSetIndex\n     */\n    public void addEntry(Entry e, int dataSetIndex) {\n\n        if (mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {\n\n            IDataSet set = mDataSets.get(dataSetIndex);\n            // add the entry to the dataset\n            if (!set.addEntry(e))\n                return;\n\n            calcMinMax(e, set.getAxisDependency());\n\n        } else {\n            Log.e(\"addEntry\", \"Cannot add Entry because dataSetIndex too high or too low.\");\n        }\n    }",
        "TranslatedCode": "/**\n   * Adds an Entry to the DataSet at the specified index.\n   * Entries are added to the end of the list.\n   *\n   * @param e\n   * @param dataSetIndex\n   */\n  public addEntry(e: EntryOhos, dataSetIndex: number): void {\n\n    if (this.mDataSets && this.mDataSets.size() > dataSetIndex && dataSetIndex >= 0) {\n\n      let data: IDataSet<EntryOhos> = this.mDataSets.get(dataSetIndex);\n      // add the entry to the dataset\n      if (!data.addEntry(e))\n        return;\n\n      this.calcMinMax2(e, data.getAxisDependency());\n\n    } else {\n      LogUtil.log(\"addEntry\", \"Cannot add Entry because dataSetIndex too high or too low.\");\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Adjusts the current minimum and maximum values based on the provided Entry object.\n     *\n     * @param e\n     * @param axis\n     */\n    protected void calcMinMax(Entry e, AxisDependency axis) {\n\n        if (mYMax < e.getY())\n            mYMax = e.getY();\n        if (mYMin > e.getY())\n            mYMin = e.getY();\n\n        if (mXMax < e.getX())\n            mXMax = e.getX();\n        if (mXMin > e.getX())\n            mXMin = e.getX();\n\n        if (axis == AxisDependency.LEFT) {\n\n            if (mLeftAxisMax < e.getY())\n                mLeftAxisMax = e.getY();\n            if (mLeftAxisMin > e.getY())\n                mLeftAxisMin = e.getY();\n        } else {\n            if (mRightAxisMax < e.getY())\n                mRightAxisMax = e.getY();\n            if (mRightAxisMin > e.getY())\n                mRightAxisMin = e.getY();\n        }\n    }",
        "TranslatedCode": "/**\n   * Adjusts the current minimum and maximum values based on the provided Entry object.\n   *\n   * @param e\n   * @param axis\n   */\n  protected calcMinMax2(e: EntryOhos, axis: AxisDependency): void {\n\n    if (this.mYMax < e.getY())\n      this.mYMax = e.getY();\n    if (this.mYMin > e.getY())\n      this.mYMin = e.getY();\n\n    if (this.mXMax < e.getX())\n      this.mXMax = e.getX();\n    if (this.mXMin > e.getX())\n      this.mXMin = e.getX();\n\n    if (axis == AxisDependency.LEFT) {\n\n      if (this.mLeftAxisMax < e.getY())\n        this.mLeftAxisMax = e.getY();\n      if (this.mLeftAxisMin > e.getY())\n        this.mLeftAxisMin = e.getY();\n    } else {\n      if (this.mRightAxisMax < e.getY())\n        this.mRightAxisMax = e.getY();\n      if (this.mRightAxisMin > e.getY())\n        this.mRightAxisMin = e.getY();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Adjusts the minimum and maximum values based on the given DataSet.\n     *\n     * @param d\n     */\n    protected void calcMinMax(T d) {\n\n        if (mYMax < d.getYMax())\n            mYMax = d.getYMax();\n        if (mYMin > d.getYMin())\n            mYMin = d.getYMin();\n\n        if (mXMax < d.getXMax())\n            mXMax = d.getXMax();\n        if (mXMin > d.getXMin())\n            mXMin = d.getXMin();\n\n        if (d.getAxisDependency() == AxisDependency.LEFT) {\n\n            if (mLeftAxisMax < d.getYMax())\n                mLeftAxisMax = d.getYMax();\n            if (mLeftAxisMin > d.getYMin())\n                mLeftAxisMin = d.getYMin();\n        } else {\n            if (mRightAxisMax < d.getYMax())\n                mRightAxisMax = d.getYMax();\n            if (mRightAxisMin > d.getYMin())\n                mRightAxisMin = d.getYMin();\n        }\n    }",
        "TranslatedCode": "/**\n   * Adjusts the minimum and maximum values based on the given DataSet.\n   *\n   * @param d\n   */\n  protected calcMinMax1(d: T): void {\n\n    if (this.mYMax < d.getYMax())\n      this.mYMax = d.getYMax();\n    if (this.mYMin > d.getYMin())\n      this.mYMin = d.getYMin();\n\n    if (this.mXMax < d.getXMax())\n      this.mXMax = d.getXMax();\n    if (this.mXMin > d.getXMin())\n      this.mXMin = d.getXMin();\n\n    if (d.getAxisDependency() == AxisDependency.LEFT) {\n\n      if (this.mLeftAxisMax < d.getYMax())\n        this.mLeftAxisMax = d.getYMax();\n      if (this.mLeftAxisMin > d.getYMin())\n        this.mLeftAxisMin = d.getYMin();\n    } else {\n      if (this.mRightAxisMax < d.getYMax())\n        this.mRightAxisMax = d.getYMax();\n      if (this.mRightAxisMin > d.getYMin())\n        this.mRightAxisMin = d.getYMin();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Removes the given Entry object from the DataSet at the specified index.\n     *\n     * @param e\n     * @param dataSetIndex\n     */\n    public boolean removeEntry(Entry e, int dataSetIndex) {\n\n        // entry null, outofbounds\n        if (e == null || dataSetIndex >= mDataSets.size())\n            return false;\n\n        IDataSet set = mDataSets.get(dataSetIndex);\n\n        if (set != null) {\n            // remove the entry from the dataset\n            boolean removed = set.removeEntry(e);\n\n            if (removed) {\n                notifyDataChanged();\n            }\n\n            return removed;\n        } else\n            return false;\n    }",
        "TranslatedCode": "/**\n   * Removes the given Entry object from the DataSet at the specified index.\n   *\n   * @param e\n   * @param dataSetIndex\n   */\n  public removeEntry(e: EntryOhos, dataSetIndex: number): boolean {\n    if (!this.mDataSets) {\n      return true;\n    }\n\n    // entry null, outofbounds\n    if (e == null || dataSetIndex >= this.mDataSets.listSize)\n      return false;\n\n    let data: IDataSet<EntryOhos> = this.mDataSets.get(dataSetIndex);\n\n    if (data != null) {\n      // remove the entry from the dataset\n      let removed: boolean = data.removeEntry(e);\n      if (removed) {\n        this.notifyDataChanged();\n      }\n\n      return removed;\n    } else\n      return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Removes the Entry object closest to the given DataSet at the\n     * specified index. Returns true if an Entry was removed, false if no Entry\n     * was found that meets the specified requirements.\n     *\n     * @param xValue\n     * @param dataSetIndex\n     * @return\n     */\n    public boolean removeEntry(float xValue, int dataSetIndex) {\n\n        if (dataSetIndex >= mDataSets.size())\n            return false;\n\n        IDataSet dataSet = mDataSets.get(dataSetIndex);\n        Entry e = dataSet.getEntryForXValue(xValue, Float.NaN);\n\n        if (e == null)\n            return false;\n\n        return removeEntry(e, dataSetIndex);\n    }",
        "TranslatedCode": "/**\n   * Removes the Entry object closest to the given DataSet at the\n   * specified index. Returns true if an Entry was removed, false if no Entry\n   * was found that meets the specified requirements.\n   *\n   * @param xValue\n   * @param dataSetIndex\n   * @return\n   */\n  public removeEntryByXValue(xValue: number, dataSetIndex: number): boolean {\n    if (!this.mDataSets) {\n      return false;\n    }\n    if (dataSetIndex >= this.mDataSets.size())\n      return false;\n\n    let dataSet: IDataSet<EntryOhos> = this.mDataSets.get(dataSetIndex);\n    let e: EntryOhos | null = dataSet.getEntryForXValue(xValue, Number.NaN);\n\n    if (e == null)\n      return false;\n\n    return this.removeEntry(e, dataSetIndex);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the DataSet that contains the provided Entry, or null, if no\n     * DataSet contains this Entry.\n     *\n     * @param e\n     * @return\n     */\n    public T getDataSetForEntry(Entry e) {\n\n        if (e == null)\n            return null;\n\n        for (int i = 0; i < mDataSets.size(); i++) {\n\n            T set = mDataSets.get(i);\n\n            for (int j = 0; j < set.getEntryCount(); j++) {\n                if (e.equalTo(set.getEntryForXValue(e.getX(), e.getY())))\n                    return set;\n            }\n        }\n\n        return null;\n    }",
        "TranslatedCode": "/**\n   * Returns the DataSet that contains the provided Entry, or null, if no\n   * DataSet contains this Entry.\n   *\n   * @param e\n   * @return\n   */\n  public getDataSetForEntry(e: EntryOhos): T | null {\n\n    if (e == null)\n      return null;\n    if (this.mDataSets) {\n      for (let i = 0; i < this.mDataSets.size(); i++) {\n\n        let dataSet: T = this.mDataSets.get(i);\n\n        for (let j = 0; j < dataSet.getEntryCount(); j++) {\n          if (dataSet.getEntryForXValue(e.getX(), e.getY())) {\n            if (e.equalTo(dataSet.getEntryForXValue(e.getX(), e.getY()) !))\n              return dataSet;\n          }\n        }\n      }\n    }\n\n\n    return null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns all colors used across all DataSet objects this object\n     * represents.\n     *\n     * @return\n     */\n    public int[] getColors() {\n\n        if (mDataSets == null)\n            return null;\n\n        int clrcnt = 0;\n\n        for (int i = 0; i < mDataSets.size(); i++) {\n            clrcnt += mDataSets.get(i).getColors().size();\n        }\n\n        int[] colors = new int[clrcnt];\n        int cnt = 0;\n\n        for (int i = 0; i < mDataSets.size(); i++) {\n\n            List<Integer> clrs = mDataSets.get(i).getColors();\n\n            for (Integer clr : clrs) {\n                colors[cnt] = clr;\n                cnt++;\n            }\n        }\n\n        return colors;\n    }",
        "TranslatedCode": "/**\n   * Returns all colors used across all DataSet objects this object\n   * represents.\n   *\n   * @return\n   */\n  public getColors(): number[] | null {\n\n    if (this.mDataSets == null)\n      return null;\n\n    let clrcnt: number = 0;\n\n    for (let i = 0; i < this.mDataSets.listSize; i++) {\n      clrcnt += this.mDataSets.get(i).getColors().size();\n    }\n\n    let colors: number[] = new Array(clrcnt);\n    let cnt: number = 0\n\n    for (let i = 0; i < this.mDataSets.size(); i++) {\n\n      let clrs: JArrayList<Number> = this.mDataSets.get(i).getColors();\n\n      for (let j = 0; j < clrs.size(); j++) {\n        colors[cnt] = clrs.get(j).valueOf();\n        cnt++;\n      }\n    }\n\n    return colors;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the DataSet object with the maximum number of entries or null if there are no DataSets.\n     *\n     * @return\n     */\n    public T getMaxEntryCountSet() {\n\n        if (mDataSets == null || mDataSets.isEmpty())\n            return null;\n\n        T max = mDataSets.get(0);\n\n        for (T set : mDataSets) {\n\n            if (set.getEntryCount() > max.getEntryCount())\n                max = set;\n        }\n\n        return max;\n    }",
        "TranslatedCode": "/**\n   * Returns the DataSet object with the maximum number of entries or null if there are no DataSets.\n   *\n   * @return\n   */\n  public getMaxEntryCountSet(): T | null {\n\n    if (this.mDataSets == null || this.mDataSets.isEmpty())\n      return null;\n\n    let max: T = this.mDataSets.get(0);\n\n    for (let data of this.mDataSets.dataSource) {\n\n      if (data.getEntryCount() > max.getEntryCount())\n        max = data;\n    }\n\n    return max;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void calcMinMax() {\n\n        if(mDataSets == null){\n            mDataSets = new ArrayList<>();\n        }\n        mDataSets.clear();\n\n        mYMax = -Float.MAX_VALUE;\n        mYMin = Float.MAX_VALUE;\n        mXMax = -Float.MAX_VALUE;\n        mXMin = Float.MAX_VALUE;\n\n        mLeftAxisMax = -Float.MAX_VALUE;\n        mLeftAxisMin = Float.MAX_VALUE;\n        mRightAxisMax = -Float.MAX_VALUE;\n        mRightAxisMin = Float.MAX_VALUE;\n\n        List<BarLineScatterCandleBubbleData> allData = getAllData();\n\n        for (ChartData data : allData) {\n\n            data.calcMinMax();\n\n            List<IBarLineScatterCandleBubbleDataSet<? extends Entry>> sets = data.getDataSets();\n            mDataSets.addAll(sets);\n\n            if (data.getYMax() > mYMax)\n                mYMax = data.getYMax();\n\n            if (data.getYMin() < mYMin)\n                mYMin = data.getYMin();\n\n            if (data.getXMax() > mXMax)\n                mXMax = data.getXMax();\n\n            if (data.getXMin() < mXMin)\n                mXMin = data.getXMin();\n\n            for (IBarLineScatterCandleBubbleDataSet<? extends Entry> dataset : sets) {\n                if (dataset.getAxisDependency() == YAxis.AxisDependency.LEFT)  {\n                    if (dataset.getYMax() > mLeftAxisMax) {\n                        mLeftAxisMax = dataset.getYMax();\n                    }\n\n                    if (dataset.getYMin() < mLeftAxisMin) {\n                        mLeftAxisMin = dataset.getYMin();\n                    }\n                }\n                else {\n                    if (dataset.getYMax() > mRightAxisMax) {\n                        mRightAxisMax = dataset.getYMax();\n                    }\n\n                    if (dataset.getYMin() < mRightAxisMin) {\n                        mRightAxisMin = dataset.getYMin();\n                    }\n                }\n            }\n        }\n    }",
        "TranslatedCode": "public calcMinMax() {\n    if (this.mDataSets == null) {\n      this.mDataSets = new JArrayList();\n    }\n    this.mDataSets.clear();\n\n    this.mYMax = -Number.MAX_VALUE;\n    this.mYMin = Number.MAX_VALUE;\n    this.mXMax = -Number.MAX_VALUE;\n    this.mXMin = Number.MAX_VALUE;\n\n    this.mLeftAxisMax = -Number.MAX_VALUE;\n    this.mLeftAxisMin = Number.MAX_VALUE;\n    this.mRightAxisMax = -Number.MAX_VALUE;\n    this.mRightAxisMin = Number.MAX_VALUE;\n\n    let allData: JArrayList<BarLineScatterCandleBubbleData<IBarLineScatterCandleBubbleDataSet<EntryOhos>>> = this.getAllData();\n\n    for (let i = 0; i < allData.size(); i++) {\n      let data = allData.get(i);\n      data.calcMinMax();\n      let sets: JArrayList<IBarLineScatterCandleBubbleDataSet<EntryOhos>> = data.getDataSets();\n      this.mDataSets.addAll(sets);\n\n      if (data.getYMax() > this.mYMax)\n        this.mYMax = data.getYMax();\n\n      if (data.getYMin() < this.mYMin)\n        this.mYMin = data.getYMin();\n\n      if (data.getXMax() > this.mXMax)\n        this.mXMax = data.getXMax();\n\n      if (data.getXMin() < this.mXMin)\n        this.mXMin = data.getXMin();\n\n      for (let i = 0; i < sets.size(); i++) {\n        let dataset = sets.get(i);\n        if (dataset.getAxisDependency() == AxisDependency.LEFT) {\n          if (dataset.getYMax() > this.mLeftAxisMax) {\n            this.mLeftAxisMax = dataset.getYMax();\n          }\n\n          if (dataset.getYMin() < this.mLeftAxisMin) {\n            this.mLeftAxisMin = dataset.getYMin();\n          }\n        }\n        else {\n          if (dataset.getYMax() > this.mRightAxisMax) {\n            this.mRightAxisMax = dataset.getYMax();\n          }\n\n          if (dataset.getYMin() < this.mRightAxisMin) {\n            this.mRightAxisMin = dataset.getYMin();\n          }\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Get the Entry for a corresponding highlight object\n     *\n     * @param highlight\n     * @return the entry that is highlighted\n     */\n    @Override\n    public Entry getEntryForHighlight(Highlight highlight) {\n\n        if (highlight.getDataIndex() >= getAllData().size())\n            return null;\n\n        ChartData data = getDataByIndex(highlight.getDataIndex());\n\n        if (highlight.getDataSetIndex() >= data.getDataSetCount())\n            return null;\n\n        // The value of the highlighted entry could be NaN -\n        //   if we are not interested in highlighting a specific value.\n\n        List<Entry> entries = data.getDataSetByIndex(highlight.getDataSetIndex())\n                .getEntriesForXValue(highlight.getX());\n        for (Entry entry : entries)\n            if (entry.getY() == highlight.getY() ||\n                    Float.isNaN(highlight.getY()))\n                return entry;\n\n        return null;\n    }",
        "TranslatedCode": "/**\n   * Get the Entry for a corresponding highlight object\n   *\n   * @param highlight\n   * @return the entry that is highlighted\n   */\n  public getEntryForHighlight(highlight: Highlight): EntryOhos | null {\n    if (highlight.getDataIndex() >= this.getAllData().size())\n      return null;\n\n    let data: ChartData<IDataSet<EntryOhos>> = this.getDataByIndex(highlight.getDataIndex());\n\n    if (!data || highlight.getDataSetIndex() >= data.getDataSetCount()) {\n      return null;\n    }\n\n    // The value of the highlighted entry could be NaN -\n    //   if we are not interested in highlighting a specific value.\n\n    let dataSet = data.getDataSetByIndex(highlight.getDataSetIndex());\n    if (!dataSet) {\n      return null;\n    }\n    let entries: JArrayList<EntryOhos> | null = dataSet.getEntriesForXValue(highlight.getX());\n    if (!entries) {\n      return null;\n    }\n    for (let i = 0; i < entries.size(); i++) {\n      let entry = entries.get(i);\n      if (entry.getY() == highlight.getY() ||\n      Number.isNaN(highlight.getY()))\n        return entry;\n    }\n    return null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Get dataset for highlight\n     *\n     * @param highlight current highlight\n     * @return dataset related to highlight\n     */\n    public IBarLineScatterCandleBubbleDataSet<? extends Entry> getDataSetByHighlight(Highlight highlight) {\n        if (highlight.getDataIndex() >= getAllData().size())\n            return null;\n\n        BarLineScatterCandleBubbleData data = getDataByIndex(highlight.getDataIndex());\n\n        if (highlight.getDataSetIndex() >= data.getDataSetCount())\n            return null;\n\n        return (IBarLineScatterCandleBubbleDataSet<? extends Entry>)\n                data.getDataSets().get(highlight.getDataSetIndex());\n    }",
        "TranslatedCode": "/**\n   * Get dataset for highlight\n   *\n   * @param highlight current highlight\n   * @return dataset related to highlight\n   */\n  public getDataSetByHighlight(highlight: Highlight): IBarLineScatterCandleBubbleDataSet<EntryOhos> | null {\n    if (highlight.getDataIndex() >= this.getAllData().size())\n      return null;\n\n    let data: BarLineScatterCandleBubbleData<IBarLineScatterCandleBubbleDataSet<EntryOhos>> = this.getDataByIndex(highlight.getDataIndex());\n\n    if (!data || highlight.getDataSetIndex() >= data.getDataSetCount())\n      return null;\n\n    return data.getDataSets().get(highlight.getDataSetIndex()) as IBarLineScatterCandleBubbleDataSet<EntryOhos>;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean removeDataSet(IBarLineScatterCandleBubbleDataSet<? extends Entry> d) {\n\n        List<BarLineScatterCandleBubbleData> datas = getAllData();\n\n        boolean success = false;\n\n        for (ChartData data : datas) {\n\n            success = data.removeDataSet(d);\n\n            if (success) {\n                break;\n            }\n        }\n\n        return success;\n    }",
        "TranslatedCode": "public removeDataSet(d: IBarLineScatterCandleBubbleDataSet<EntryOhos>): boolean {\n\n    let allData: JArrayList<BarLineScatterCandleBubbleData<IBarLineScatterCandleBubbleDataSet<EntryOhos>>> = this.getAllData();\n\n    let success: boolean = false;\n\n    for (let i = 0; i < allData.size(); i++) {\n      let data = allData.get(i);\n      success = data.removeDataSet(d);\n\n      if (success) {\n        break;\n      }\n    }\n\n    return success;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void calcMinMaxY(float fromX, float toX) {\n        mYMax = -Float.MAX_VALUE;\n        mYMin = Float.MAX_VALUE;\n\n        if (mEntries == null || mEntries.isEmpty())\n            return;\n\n        int indexFrom = getEntryIndex(fromX, Float.NaN, Rounding.DOWN);\n        int indexTo = getEntryIndex(toX, Float.NaN, Rounding.UP);\n\n        if (indexTo < indexFrom) return;\n\n        for (int i = indexFrom; i <= indexTo; i++) {\n\n            // only recalculate y\n            calcMinMaxY(mEntries.get(i));\n        }\n    }",
        "TranslatedCode": "public calcMinMaxY(fromX: number, toX: number): void {\n    this.mYMax = -Number.MAX_VALUE;\n    this.mYMin = Number.MAX_VALUE;\n\n    if (!this.mEntries || this.mEntries == null || this.mEntries.isEmpty()) {\n      return;\n    }\n    let indexFrom: number = this.getEntryIndex(fromX, Number.NaN, Rounding.DOWN);\n    let indexTo: number = this.getEntryIndex(toX, Number.NaN, Rounding.UP);\n\n    if (indexTo < indexFrom) return;\n\n    for (let i: number = indexFrom; i <= indexTo; i++) {\n      // only recalculate y\n      this.myCalcMinMaxY(this.mEntries.get(i));\n    }\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void calcMinMaxX(T e) {\n\n        if (e.getX() < mXMin)\n            mXMin = e.getX();\n\n        if (e.getX() > mXMax)\n            mXMax = e.getX();\n    }",
        "TranslatedCode": "protected calcMinMaxX(e: T): void {\n\n    if (e.getX() < this.mXMin)\n      this.mXMin = e.getX();\n\n    if (e.getX() > this.mXMax)\n      this.mXMax = e.getX();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void calcMinMaxY(T e) {\n\n        if (e.getY() < mYMin)\n            mYMin = e.getY();\n\n        if (e.getY() > mYMax)\n            mYMax = e.getY();\n    }",
        "TranslatedCode": "protected myCalcMinMaxY(e: T): void {\n    if (e.getY() < this.mYMin)\n      this.mYMin = e.getY();\n\n    if (e.getY() > this.mYMax)\n      this.mYMax = e.getY();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int getEntryCount() {\n        return mEntries.size();\n    }",
        "TranslatedCode": "public getEntryCount(): number {\n    if (this.mEntries == null) {\n      return 0;\n    }\n    return this.mEntries.size();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public String toString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(toSimpleString());\n        for (int i = 0; i < mEntries.size(); i++) {\n            buffer.append(mEntries.get(i).toString() + \" \");\n        }\n        return buffer.toString();\n    }",
        "TranslatedCode": "public toString(): string {\n    let str: string = this.toSimpleString();\n    if (this.mEntries != null) {\n      for (let i: number = 0; i < this.mEntries.size(); i++) {\n        str += this.mEntries.get(i).toString() + \" \"\n      }\n    }\n    return str;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns a simple string representation of the DataSet with the type and\n     * the number of Entries.\n     *\n     * @return\n     */\n    public String toSimpleString() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"DataSet, label: \" + (getLabel() == null ? \"\" : getLabel()) + \", entries: \" + mEntries.size() +\n                \"\\n\");\n        return buffer.toString();\n    }",
        "TranslatedCode": "/**\n   * Returns a simple string representation of the DataSet with the type and\n   * the number of Entries.\n   *\n   * @return\n   */\n  public toSimpleString(): string {\n    let size = 0;\n    if (this.mEntries != null) {\n      size = this.mEntries.size();\n    }\n    let str: string = \"DataSet, label: \" + (!this.getLabel() ? \"\" : this.getLabel()) + \", entries: \" + size + \"\\n\";\n    return str\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void addEntryOrdered(T e) {\n\n        if (e == null)\n            return;\n\n        if (mEntries == null) {\n            mEntries = new ArrayList<T>();\n        }\n\n        calcMinMax(e);\n\n        if (mEntries.size() > 0 && mEntries.get(mEntries.size() - 1).getX() > e.getX()) {\n            int closestIndex = getEntryIndex(e.getX(), e.getY(), Rounding.UP);\n            mEntries.add(closestIndex, e);\n        } else {\n            mEntries.add(e);\n        }\n    }",
        "TranslatedCode": "public addEntryOrdered(e: T): void {\n\n    if (!e)\n      return;\n\n    if (!this.mEntries) {\n      this.mEntries = new JArrayList<T>();\n    }\n\n    this.myCalcMinMax(e);\n\n    if (this.mEntries.size() > 0 && this.mEntries.get(this.mEntries.size() - 1).getX() > e.getX()) {\n      let closestIndex: number = this.getEntryIndex(e.getX(), e.getY(), Rounding.UP);\n      //              this.mEntries.add(closestIndex, e);\n    } else {\n      this.mEntries.add(e);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean addEntry(T e) {\n\n        if (e == null)\n            return false;\n\n        List<T> values = getEntries();\n        if (values == null) {\n            values = new ArrayList<>();\n        }\n\n        calcMinMax(e);\n\n        // add the entry\n        return values.add(e);\n    }",
        "TranslatedCode": "public addEntry(e: T): boolean {\n\n    if (!e)\n      return false;\n\n    let values: JArrayList<T> | null = this.getEntries();\n    if (!values) {\n      values = new JArrayList<T>();\n    }\n\n    this.myCalcMinMax(e);\n\n    // add the entry\n    values.add(e);\n    return true;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean removeEntry(T e) {\n\n        if (e == null)\n            return false;\n\n        if (mEntries == null)\n            return false;\n\n        // remove the entry\n        boolean removed = mEntries.remove(e);\n\n        if (removed) {\n            calcMinMax();\n        }\n\n        return removed;\n    }",
        "TranslatedCode": "public removeEntry(e: T): boolean {\n    if (!e)\n      return false;\n\n    if (!this.mEntries)\n      return false;\n\n    // remove the entry\n    let removed: boolean = this.mEntries.remove(e);\n\n    if (removed) {\n      this.calcMinMax();\n    }\n\n    return removed;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int getEntryIndex(Entry e) {\n        return mEntries.indexOf(e);\n    }",
        "TranslatedCode": "public getEntryIndexByEntry(e: T): number {\n    if (this.mEntries == null) {\n      return -1;\n    }\n    return this.mEntries.indexOf(e);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public T getEntryForXValue(float xValue, float closestToY, Rounding rounding) {\n\n        int index = getEntryIndex(xValue, closestToY, rounding);\n        if (index > -1)\n            return mEntries.get(index);\n        return null;\n    }\npublic T getEntryForXValue(float xValue, float closestToY) {\n        return getEntryForXValue(xValue, closestToY, Rounding.CLOSEST);\n    }",
        "TranslatedCode": "public getEntryForXValue(xValue: number, closestToY: number, rounding?: Rounding): T | null {\n    let myRounding: Rounding\n    if (rounding == null) {\n      myRounding = Rounding.CLOSEST;\n    } else {\n      myRounding = rounding;\n    }\n    // if(closestToY){\n    let index: number = this.getEntryIndex(xValue, closestToY, myRounding);\n    if (index > -1)\n      if (this.mEntries) {\n        return this.mEntries.get(index);\n      }\n    // }\n    return null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int getEntryIndex(float xValue, float closestToY, Rounding rounding) {\n\n        if (mEntries == null || mEntries.isEmpty())\n            return -1;\n\n        int low = 0;\n        int high = mEntries.size() - 1;\n        int closest = high;\n\n        while (low < high) {\n            int m = (low + high) / 2;\n\n            final float d1 = mEntries.get(m).getX() - xValue,\n                    d2 = mEntries.get(m + 1).getX() - xValue,\n                    ad1 = Math.abs(d1), ad2 = Math.abs(d2);\n\n            if (ad2 < ad1) {\n                // [m + 1] is closer to xValue\n                // Search in an higher place\n                low = m + 1;\n            } else if (ad1 < ad2) {\n                // [m] is closer to xValue\n                // Search in a lower place\n                high = m;\n            } else {\n                // We have multiple sequential x-value with same distance\n\n                if (d1 >= 0.0) {\n                    // Search in a lower place\n                    high = m;\n                } else if (d1 < 0.0) {\n                    // Search in an higher place\n                    low = m + 1;\n                }\n            }\n\n            closest = high;\n        }\n\n        if (closest != -1) {\n            float closestXValue = mEntries.get(closest).getX();\n            if (rounding == Rounding.UP) {\n                // If rounding up, and found x-value is lower than specified x, and we can go upper...\n                if (closestXValue < xValue && closest < mEntries.size() - 1) {\n                    ++closest;\n                }\n            } else if (rounding == Rounding.DOWN) {\n                // If rounding down, and found x-value is upper than specified x, and we can go lower...\n                if (closestXValue > xValue && closest > 0) {\n                    --closest;\n                }\n            }\n\n            // Search by closest to y-value\n            if (!Float.isNaN(closestToY)) {\n                while (closest > 0 && mEntries.get(closest - 1).getX() == closestXValue)\n                    closest -= 1;\n\n                float closestYValue = mEntries.get(closest).getY();\n                int closestYIndex = closest;\n\n                while (true) {\n                    closest += 1;\n                    if (closest >= mEntries.size())\n                        break;\n\n                    final Entry value = mEntries.get(closest);\n\n                    if (value.getX() != closestXValue)\n                        break;\n\n                    if (Math.abs(value.getY() - closestToY) <= Math.abs(closestYValue - closestToY)) {\n                        closestYValue = closestToY;\n                        closestYIndex = closest;\n                    }\n                }\n\n                closest = closestYIndex;\n            }\n        }\n\n        return closest;\n    }",
        "TranslatedCode": "public getEntryIndex(xValue: number, closestToY: number, rounding: Rounding): number {\n\n    if (!this.mEntries || this.mEntries.isEmpty())\n      return -1;\n\n    let low: number = 0;\n    let high: number = this.mEntries.size() - 1;\n    let closest: number = high;\n\n    while (low < high) {\n      let m: number = Math.floor((low + high) / 2);\n      let xVal1: number = this.mEntries.get(m).getX();\n      let xVal2: number = this.mEntries.get(m + 1).getX();\n\n      let d1: number = xVal1 - xValue;\n      let d2: number = xVal2 - xValue;\n\n      if (typeof d1 !== 'number' || typeof d2 !== 'number' || isNaN(d1) || isNaN(d2)) {\n        LogUtil.error(`Invalid values detected: d1 = ${d1}, d2 = ${d2}, xVal1 = ${xVal1}, xVal2 = ${xVal2}, xValue = ${xValue}, Indices: m = ${m}, low = ${low}, high = ${high}`);\n        break;\n      }\n      let ad1: number = Math.abs(d1), ad2 = Math.abs(d2);\n\n      if (ad2 < ad1) {\n        // [m + 1] is closer to xValue\n        // Search in an higher place\n        low = m + 1;\n      } else if (ad1 < ad2) {\n        // [m] is closer to xValue\n        // Search in a lower place\n        high = m;\n      } else {\n        // We have multiple sequential x-value with same distance\n        if (d1 >= 0.0) {\n          // Search in a lower place\n          high = m;\n        } else if (d1 < 0.0) {\n          // Search in an higher place\n          low = m + 1;\n        }\n      }\n      closest = high;\n    }\n\n    if (closest != -1) {\n      let closestXValue: number = this.mEntries.get(closest).getX();\n      if (rounding == Rounding.UP) {\n        // If rounding up, and found x-value is lower than specified x, and we can go upper...\n        if (closestXValue < xValue && closest < this.mEntries.size() - 1) {\n          ++closest;\n        }\n      } else if (rounding == Rounding.DOWN) {\n        // If rounding down, and found x-value is upper than specified x, and we can go lower...\n        if (closestXValue > xValue && closest > 0) {\n          --closest;\n        }\n      }\n      // Search by closest to y-value\n      if (!Number.isNaN(closestToY)) {\n        while (closest > 0 && this.mEntries.get(closest - 1).getX() == closestXValue)\n          closest -= 1;\n\n        let closestYValue: number = this.mEntries.get(closest).getY();\n        let closestYIndex: number = closest;\n\n        while (true) {\n          closest += 1;\n          if (closest >= this.mEntries.size())\n            break;\n\n          let value: EntryOhos = this.mEntries.get(closest);\n\n          if (value.getX() != closestXValue)\n            break;\n\n          if (Math.abs(value.getY() - closestToY) <= Math.abs(closestYValue - closestToY)) {\n            closestYValue = closestToY;\n            closestYIndex = closest;\n          }\n        }\n        closest = closestYIndex;\n      }\n    }\n    return closest;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public List<T> getEntriesForXValue(float xValue) {\n\n        List<T> entries = new ArrayList<T>();\n\n        int low = 0;\n        int high = mEntries.size() - 1;\n\n        while (low <= high) {\n            int m = (high + low) / 2;\n            T entry = mEntries.get(m);\n\n            // if we have a match\n            if (xValue == entry.getX()) {\n                while (m > 0 && mEntries.get(m - 1).getX() == xValue)\n                    m--;\n\n                high = mEntries.size();\n\n                // loop over all \"equal\" entries\n                for (; m < high; m++) {\n                    entry = mEntries.get(m);\n                    if (entry.getX() == xValue) {\n                        entries.add(entry);\n                    } else {\n                        break;\n                    }\n                }\n\n                break;\n            } else {\n                if (xValue > entry.getX())\n                    low = m + 1;\n                else\n                    high = m - 1;\n            }\n        }\n\n        return entries;\n    }",
        "TranslatedCode": "public getEntriesForXValue(xValue: number): JArrayList<T> {\n\n    let entries: JArrayList<T> = new JArrayList<T>();\n    if (this.mEntries == null) {\n      return entries;\n    }\n    let low: number = 0;\n    let high: number = this.mEntries.size() - 1;\n\n    while (low <= high) {\n      let m: number = (high + low) / 2;\n      m = Utils.parseInt(m);\n      let entry: T = this.mEntries.get(m);\n      // if we have a match\n      if (entry && xValue == entry.getX()) {\n        while (m > 0 && this.mEntries.get(m - 1).getX() == xValue)\n          m--;\n\n        high = this.mEntries.size();\n\n        // loop over all \"equal\" entries\n        for (; m < high; m++) {\n          if (this.mEntries != null) {\n            entry = this.mEntries.get(m);\n            if (entry.getX() == xValue) {\n              entries.add(entry);\n            } else {\n              break;\n            }\n          }\n        }\n\n        break;\n      } else {\n        if (entry && xValue > entry.getX())\n          low = m + 1;\n        else\n          high = m - 1;\n      }\n    }\n\n    return entries;\n  }\n}",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DataSet<Entry> copy() {\n        List<Entry> entries = new ArrayList<Entry>();\n        for (int i = 0; i < mEntries.size(); i++) {\n            entries.add(mEntries.get(i).copy());\n        }\n        LineDataSet copied = new LineDataSet(entries, getLabel());\n        copy(copied);\n        return copied;\n    }",
        "TranslatedCode": "public copy(): DataSet<EntryOhos> {\n    let entries = new JArrayList<EntryOhos>();\n    if (this.mEntries != null) {\n      for (let i = 0; i < this.mEntries.size(); i++) {\n        entries.add(this.mEntries.get(i).copy());\n      }\n    }\n    let copied = new LineDataSet(entries, this.getLabel());\n    this.copyTo(copied);\n    return copied;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Sets the intensity for cubic lines (if enabled). Max = 1f = very cubic,\n     * Min = 0.05f = low cubic effect, Default: 0.2f\n     *\n     * @param intensity\n     */\n    public void setCubicIntensity(float intensity) {\n\n        if (intensity > 1f)\n            intensity = 1f;\n        if (intensity < 0.05f)\n            intensity = 0.05f;\n\n        mCubicIntensity = intensity;\n    }",
        "TranslatedCode": "/**\n   * Sets the intensity for cubic lines (if enabled). Max = 1f = very cubic,\n   * Min = 0.05f = low cubic effect, Default: 0.2f\n   *\n   * @param intensity\n   */\n  public setCubicIntensity(intensity: number): void {\n    if (intensity > 1)\n      intensity = 1;\n    if (intensity < 0.05)\n      intensity = 0.05;\n    ;\n    this.mCubicIntensity = intensity;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Sets the radius of the drawn circles.\n     * Default radius = 4f, Min = 1f\n     *\n     * @param radius\n     */\n    public void setCircleRadius(float radius) {\n\n        if (radius >= 1f) {\n            mCircleRadius = Utils.convertDpToPixel(radius);\n        } else {\n            Log.e(\"LineDataSet\", \"Circle radius cannot be < 1\");\n        }\n    }",
        "TranslatedCode": "/**\n   * Sets the radius of the drawn circles.\n   * Default radius = 4f, Min = 1f\n   *\n   * @param radius\n   */\n  public setCircleRadius(radius: number): void {\n\n    if (radius >= 1) {\n      //      this.mCircleRadius = Utils.convertDpToPixel(radius);\n      this.mCircleRadius = radius;\n    } else {\n      LogUtil.log(\"LineDataSet\", \"Circle radius cannot be < 1\")\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Sets the hole radius of the drawn circles.\n     * Default radius = 2f, Min = 0.5f\n     *\n     * @param holeRadius\n     */\n    public void setCircleHoleRadius(float holeRadius) {\n\n        if (holeRadius >= 0.5f) {\n            mCircleHoleRadius = Utils.convertDpToPixel(holeRadius);\n        } else {\n            Log.e(\"LineDataSet\", \"Circle radius cannot be < 0.5\");\n        }\n    }",
        "TranslatedCode": "/**\n   * Sets the hole radius of the drawn circles.\n   * Default radius = 2f, Min = 0.5f\n   *\n   * @param holeRadius\n   */\n  public setCircleHoleRadius(holeRadius: number): void {\n\n    if (holeRadius >= 0.5) {\n      //      this.mCircleHoleRadius = Utils.convertDpToPixel(holeRadius);\n      this.mCircleHoleRadius = holeRadius;\n    } else {\n      LogUtil.log(\"LineDataSet\", \"Circle radius cannot be < 0.5\")\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * set the line width of the chart (min = 0.2f, max = 10f); default 1f NOTE:\n     * thinner line == better performance, thicker line == worse performance\n     *\n     * @param width\n     */\n    public void setLineWidth(float width) {\n\n        if (width < 0.0f)\n            width = 0.0f;\n        if (width > 10.0f)\n            width = 10.0f;\n        mLineWidth = Utils.convertDpToPixel(width);\n    }",
        "TranslatedCode": "/**\n   * set the line width of the chart (min = 0.2f, max = 10f); default 1f NOTE:\n   * thinner line == better performance, thicker line == worse performance\n   *\n   * @param width\n   */\n  public setLineWidth(width: number): void {\n\n    if (width < 0.0)\n      width = 0.0;\n    if (width > 10.0)\n      width = 10.0;\n    this.mLineWidth = width;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getLineWidth() {\n        return mLineWidth;\n    }",
        "TranslatedCode": "public getLineWidth(): number {\n    return this.mLineWidth;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isDrawFilledEnabled() {\n        return mDrawFilled;\n    }",
        "TranslatedCode": "public isDrawFilledEnabled(): boolean {\n    return this.mDrawFilled;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public List<IPieDataSet> getDataSets() {\n        List<IPieDataSet> dataSets = super.getDataSets();\n\n        if (dataSets.size() < 1) {\n            Log.e(\"MPAndroidChart\",\n                    \"Found multiple data sets while pie chart only allows one\");\n        }\n\n        return dataSets;\n    }",
        "TranslatedCode": "public getDataSets(): JArrayList<IPieDataSet> {\n    let dataSets: JArrayList<IPieDataSet> = super.getDataSets();\n\n    if (dataSets.size() < 1) {\n      LogUtil.log(\"mpchart\",\n        \"Found multiple data sets while pie chart only allows one\");\n    }\n\n    return dataSets;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * The PieData object can only have one DataSet. Use getDataSet() method instead.\n     *\n     * @param index\n     * @return\n     */\n    @Override\n    public IPieDataSet getDataSetByIndex(int index) {\n        return index == 0 ? getDataSet() : null;\n    }",
        "TranslatedCode": "/**\n   * The PieData object can only have one DataSet. Use getDataSet() method instead.\n   *\n   * @param index\n   * @return\n   */\n  public getDataSetByIndex(index: number): IPieDataSet | null {\n    return index == 0 ? this.getDataSet() : null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public IPieDataSet getDataSetByLabel(String label, boolean ignorecase) {\n        return ignorecase ? label.equalsIgnoreCase(mDataSets.get(0).getLabel()) ? mDataSets.get(0)\n                : null : label.equals(mDataSets.get(0).getLabel()) ? mDataSets.get(0) : null;\n    }",
        "TranslatedCode": "public getDataSetByLabel(label: string, ignorecase: boolean): IPieDataSet | null {\n    return ignorecase ? Utils.equalsIgnoreCase(label, this.mDataSets.get(0).getLabel()) ? this.mDataSets.get(0)\n                                                                                        : null : label == this.mDataSets.get(0)\n      .getLabel() ? this.mDataSets.get(0) : null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the sum of all values in this PieData object.\n     *\n     * @return\n     */\n    public float getYValueSum() {\n\n        float sum = 0;\n\n        for (int i = 0; i < getDataSet().getEntryCount(); i++)\n            sum += getDataSet().getEntryForIndex(i).getY();\n\n\n        return sum;\n    }",
        "TranslatedCode": "/**\n   * Returns the sum of all values in this PieData object.\n   *\n   * @return\n   */\n  public getYValueSum(): number {\n\n    let sum: number = 0;\n\n    for (let i: number = 0; i < this.getDataSet().getEntryCount(); i++)\n      sum += this.getDataSet().getEntryForIndex(i).getY();\n\n\n    return sum;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DataSet<PieEntry> copy() {\n        List<PieEntry> entries = new ArrayList<>();\n        for (int i = 0; i < mEntries.size(); i++) {\n            entries.add(mEntries.get(i).copy());\n        }\n        PieDataSet copied = new PieDataSet(entries, getLabel());\n        copy(copied);\n        return copied;\n    }",
        "TranslatedCode": "public copy(): DataSet<PieEntry> {\n    let entries = new JArrayList<PieEntry>();\n    if (this.mEntries != null) {\n      for (let i = 0; i < this.mEntries.size(); i++) {\n        entries.add(this.mEntries.get(i).copy());\n      }\n    }\n    let copied = new PieDataSet(entries, this.getLabel());\n    this.copyTo(copied);\n    return copied;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void calcMinMax(PieEntry e) {\n\n        if (e == null)\n            return;\n\n        calcMinMaxY(e);\n    }",
        "TranslatedCode": "public myCalcMinMax(e: PieEntry): void {\n\n    if (e == null)\n      return;\n\n    super.myCalcMinMax(e);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Sets the space that is left out between the piechart-slices in dp.\n     * Default: 0 --> no space, maximum 20f\n     *\n     * @param spaceDp\n     */\n    public void setSliceSpace(float spaceDp) {\n\n        if (spaceDp > 20)\n            spaceDp = 20f;\n        if (spaceDp < 0)\n            spaceDp = 0f;\n\n        mSliceSpace = Utils.convertDpToPixel(spaceDp);\n    }",
        "TranslatedCode": "/**\n   * Sets the space that is left out between the piechart-slices in vp.\n   * Default: 0 --> no space, maximum 20f\n   *\n   * @param spaceDp\n   */\n  public setSliceSpace(spaceDp: number): void {\n    if (spaceDp > 20)\n      spaceDp = 20;\n    if (spaceDp < 0)\n      spaceDp = 0;\n\n    this.mSliceSpace = Utils.handleDataValues(spaceDp);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getSliceSpace() {\n        return mSliceSpace;\n    }",
        "TranslatedCode": "public getSliceSpace(): number {\n    return this.mSliceSpace;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * When enabled, slice spacing will be 0.0 when the smallest value is going to be\n     * smaller than the slice spacing itself.\n     *\n     * @param autoDisable\n     */\n    public void setAutomaticallyDisableSliceSpacing(boolean autoDisable) {\n        mAutomaticallyDisableSliceSpacing = autoDisable;\n    }",
        "TranslatedCode": "/**\n   * When enabled, slice spacing will be 0.0 when the smallest value is going to be\n   * smaller than the slice spacing itself.\n   *\n   * @param autoDisable\n   */\n  public setAutomaticallyDisableSliceSpacing(autoDisable: boolean): void {\n    this.mAutomaticallyDisableSliceSpacing = autoDisable;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public Entry getEntryForHighlight(Highlight highlight) {\n        return getDataSetByIndex(highlight.getDataSetIndex()).getEntryForIndex((int) highlight.getX());\n    }",
        "TranslatedCode": "getEntryForHighlight(highlight: Highlight): EntryOhos | null {\n    const dataSet = this.getDataSetByIndex(highlight.getDataSetIndex());\n    return dataSet ? dataSet.getEntryForIndex(Math.floor(highlight.getX())) : null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DataSet<RadarEntry> copy() {\n        List<RadarEntry> entries = new ArrayList<RadarEntry>();\n        for (int i = 0; i < mEntries.size(); i++) {\n            entries.add(mEntries.get(i).copy());\n        }\n        RadarDataSet copied = new RadarDataSet(entries, getLabel());\n        copy(copied);\n        return copied;\n    }",
        "TranslatedCode": "public copy(): DataSet<RadarEntry> {\n    let entries: JArrayList<RadarEntry> = new JArrayList<RadarEntry>();\n    if (this.mEntries != null) {\n      for (let i = 0; i < this.mEntries.size(); i++) {\n        entries.add(this.mEntries.get(i).copy());\n      }\n    }\n    let copied: RadarDataSet = new RadarDataSet(entries, this.getLabel());\n    this.copyTo(copied);\n    return copied;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public RadarEntry copy() {\n        RadarEntry e = new RadarEntry(getY(), getData());\n        return e;\n    }",
        "TranslatedCode": "public copy(): RadarEntry {\n    if (!this.getData()) {\n      return new RadarEntry(this.getY(), undefined);\n    }\n    let e: RadarEntry = new RadarEntry(this.getY(),this.getIcon()!, this.getData()!);\n    return e;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Returns the maximum shape-size across all DataSets.\n     *\n     * @return\n     */\n    public float getGreatestShapeSize() {\n\n        float max = 0f;\n\n        for (IScatterDataSet set : mDataSets) {\n            float size = set.getScatterShapeSize();\n\n            if (size > max)\n                max = size;\n        }\n\n        return max;\n    }",
        "TranslatedCode": "/**\n   * Returns the maximum shape-size across all DataSets.\n   *\n   * @return\n   */\n  public getGreatestShapeSize() {\n\n    let max = 0;\n    for (let i = 0;i < this.mDataSets.size(); i++) {\n      const set = this.mDataSets.get(i);\n      const size = set.getScatterShapeSize();\n\n      if (size > max)\n        max = size;\n    }\n\n    return max;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Computes the axis values.\n     *\n     * @param min - the minimum value in the data object for this axis\n     * @param max - the maximum value in the data object for this axis\n     */\n    public void computeAxis(float min, float max, boolean inverted) {\n\n\n        if (mViewPortHandler != null && mViewPortHandler.contentWidth() > 10 && !mViewPortHandler.isFullyZoomedOutY()) {\n\n            MPPointD p1 = mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(), mViewPortHandler.contentTop());\n            MPPointD p2 = mTrans.getValuesByTouchPoint(mViewPortHandler.contentLeft(), mViewPortHandler.contentBottom());\n\n            if (!inverted) {\n\n                min = (float) p2.y;\n                max = (float) p1.y;\n            } else {\n\n                min = (float) p1.y;\n                max = (float) p2.y;\n            }\n\n            MPPointD.recycleInstance(p1);\n            MPPointD.recycleInstance(p2);\n        }\n\n        computeAxisValues(min, max);\n    }",
        "TranslatedCode": "/**\n   * Computes the axis values.\n   *\n   * @param min - the minimum value in the data object for this axis\n   * @param max - the maximum value in the data object for this axis\n   */\n  public computeAxis(min: number, max: number, inverted: boolean) {\n    if (this.mTrans && this.mViewPortHandler != null && this.mViewPortHandler.contentWidth() > 10 && !this.mViewPortHandler.isFullyZoomedOutY()) {\n\n      let p1: MPPointD | undefined = this.mTrans.getValuesByTouchPoint(this.mViewPortHandler.contentLeft(), this.mViewPortHandler.contentTop());\n      let p2: MPPointD | undefined = this.mTrans.getValuesByTouchPoint(this.mViewPortHandler.contentLeft(), this.mViewPortHandler.contentBottom());\n\n      if (!!p1 && !!p2) {\n        if (!inverted) {\n\n          min = p2.y;\n          max = p1.y;\n        } else {\n\n          min = p1.y;\n          max = p2.y;\n        }\n\n        MPPointD.recycleInstance(p1);\n        MPPointD.recycleInstance(p2);\n      }\n    }\n\n    this.computeAxisValues(min, max);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Sets up the axis values. Computes the desired number of labels between the two given extremes.\n     *\n     * @return\n     */\n    protected void computeAxisValues(float min, float max) {\n\n        float yMin = min;\n        float yMax = max;\n\n        int labelCount = mAxis.getLabelCount();\n        double range = Math.abs(yMax - yMin);\n\n        if (labelCount == 0 || range <= 0 || Double.isInfinite(range)) {\n            mAxis.mEntries = new float[]{};\n            mAxis.mCenteredEntries = new float[]{};\n            mAxis.mEntryCount = 0;\n            return;\n        }\n\n        // Find out how much spacing (in y value space) between axis values\n        double rawInterval = range / labelCount;\n        double interval = Utils.roundToNextSignificant(rawInterval);\n\n        // If granularity is enabled, then do not allow the interval to go below specified granularity.\n        // This is used to avoid repeated values when rounding values for display.\n        if (mAxis.isGranularityEnabled())\n            interval = interval < mAxis.getGranularity() ? mAxis.getGranularity() : interval;\n\n        // Normalize interval\n        double intervalMagnitude = Utils.roundToNextSignificant(Math.pow(10, (int) Math.log10(interval)));\n        int intervalSigDigit = (int) (interval / intervalMagnitude);\n        if (intervalSigDigit > 5) {\n            // Use one order of magnitude higher, to avoid intervals like 0.9 or 90\n            // if it's 0.0 after floor(), we use the old value\n            interval = Math.floor(10.0 * intervalMagnitude) == 0.0\n                    ? interval\n                    : Math.floor(10.0 * intervalMagnitude);\n\n        }\n\n        int n = mAxis.isCenterAxisLabelsEnabled() ? 1 : 0;\n\n        // force label count\n        if (mAxis.isForceLabelsEnabled()) {\n\n            interval = (float) range / (float) (labelCount - 1);\n            mAxis.mEntryCount = labelCount;\n\n            if (mAxis.mEntries.length < labelCount) {\n                // Ensure stops contains at least numStops elements.\n                mAxis.mEntries = new float[labelCount];\n            }\n\n            float v = min;\n\n            for (int i = 0; i < labelCount; i++) {\n                mAxis.mEntries[i] = v;\n                v += interval;\n            }\n\n            n = labelCount;\n\n            // no forced count\n        } else {\n\n            double first = interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;\n            if(mAxis.isCenterAxisLabelsEnabled()) {\n                first -= interval;\n            }\n\n            double last = interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);\n\n            double f;\n            int i;\n\n            if (interval != 0.0 && last != first) {\n                for (f = first; f <= last; f += interval) {\n                    ++n;\n                }\n            }\n            else if (last == first && n == 0) {\n                n = 1;\n            }\n\n            mAxis.mEntryCount = n;\n\n            if (mAxis.mEntries.length < n) {\n                // Ensure stops contains at least numStops elements.\n                mAxis.mEntries = new float[n];\n            }\n\n            for (f = first, i = 0; i < n; f += interval, ++i) {\n\n                if (f == 0.0) // Fix for negative zero case (Where value == -0.0, and 0.0 == -0.0)\n                    f = 0.0;\n\n                mAxis.mEntries[i] = (float) f;\n            }\n        }\n\n        // set decimals\n        if (interval < 1) {\n            mAxis.mDecimals = (int) Math.ceil(-Math.log10(interval));\n        } else {\n            mAxis.mDecimals = 0;\n        }\n\n        if (mAxis.isCenterAxisLabelsEnabled()) {\n\n            if (mAxis.mCenteredEntries.length < n) {\n                mAxis.mCenteredEntries = new float[n];\n            }\n\n            float offset = (float)interval / 2f;\n\n            for (int i = 0; i < n; i++) {\n                mAxis.mCenteredEntries[i] = mAxis.mEntries[i] + offset;\n            }\n        }\n    }",
        "TranslatedCode": "/**\n   * Sets up the axis values. Computes the desired number of labels between the two given extremes.\n   *\n   * @return\n   */\n  protected computeAxisValues(min: number, max: number) {\n    let yMin = min;\n    let yMax = max;\n\n    if (this.mAxis) {\n      let labelCount = this.mAxis.getLabelCount();\n      let range = Math.abs(yMax - yMin);\n\n      if (labelCount == 0 || range <= 0 || range == Number.POSITIVE_INFINITY) {\n        this.mAxis.mEntries = new Array<number>();\n        this.mAxis.mCenteredEntries = new Array<number>();\n        this.mAxis.mEntryCount = 0;\n        return;\n      }\n\n      // Find out how much spacing (in y value space) between axis values\n      let rawInterval: number = range / labelCount;\n      let interval: number = Utils.roundToNextSignificant(rawInterval);\n\n      // If granularity is enabled, then do not allow the interval to go below specified granularity.\n      // This is used to avoid repeated values when rounding values for display.\n      if (this.mAxis.isGranularityEnabled())\n        interval = interval < this.mAxis.getGranularity() ? this.mAxis.getGranularity() : interval;\n\n      // Normalize interval\n      let intervalMagnitude = Utils.roundToNextSignificant(Math.pow(10, Math.floor(Math.log10(interval))));\n      let intervalSigDigit = Math.floor((interval / intervalMagnitude));\n      if (intervalSigDigit > 5) {\n        // Use one order of magnitude higher, to avoid intervals like 0.9 or 90\n        // if it's 0.0 after floor(), we use the old value\n        interval = Math.floor(10.0 * intervalMagnitude) == 0.0\n          ? interval\n          : Math.floor(10.0 * intervalMagnitude);\n\n      }\n\n      let n = this.mAxis.isCenterAxisLabelsEnabled() ? 1 : 0;\n\n      // force label count\n      if (this.mAxis.isForceLabelsEnabled()) {\n\n        interval = range / (labelCount - 1);\n        this.mAxis.mEntryCount = labelCount;\n\n        if (this.mAxis.mEntries.length < labelCount) {\n          // Ensure stops contains at least numStops elements.\n          this.mAxis.mEntries = new Array<number>(labelCount);\n        }\n\n        let v = min;\n\n        for (let i = 0; i < labelCount; i++) {\n          this.mAxis.mEntries[i] = v;\n          v += interval;\n        }\n\n        n = labelCount;\n\n        // no forced count\n      } else {\n\n        let first = interval == 0.0 ? 0.0 : Math.ceil(yMin / interval) * interval;\n        if (this.mAxis.isCenterAxisLabelsEnabled()) {\n          first -= interval;\n        }\n\n        let last = interval == 0.0 ? 0.0 : Utils.nextUp(Math.floor(yMax / interval) * interval);\n\n        let f: number = 0;\n        let i: number = 0;\n\n        if (interval != 0.0 && last != first) {\n          for (f = first; f <= last; f += interval) {\n            ++n;\n          }\n        }\n        else if (last == first && n == 0) {\n          n = 1;\n        }\n\n        this.mAxis.mEntryCount = n;\n\n        if (this.mAxis.mEntries.length < n) {\n          // Ensure stops contains at least numStops elements.\n          this.mAxis.mEntries = new Array<number>(n);\n        }\n\n        for (f = first, i = 0; i < n; f += interval, ++i) {\n\n          if (f == 0.0) // Fix for negative zero case (Where value == -0.0, and 0.0 == -0.0)\n            f = 0.0;\n\n          this.mAxis.mEntries[i] = f;\n        }\n      }\n\n      // set decimals\n      if (interval < 1) {\n        this.mAxis.mDecimals = Math.floor(Math.ceil(-Math.log10(interval)));\n      } else {\n        this.mAxis.mDecimals = 0;\n      }\n\n      if (this.mAxis.isCenterAxisLabelsEnabled()) {\n\n        if (this.mAxis.mCenteredEntries.length < n) {\n          this.mAxis.mCenteredEntries = new Array<number>(n);\n        }\n\n        let offset: number = interval / 2;\n\n        for (let i = 0; i < n; i++) {\n          this.mAxis.mCenteredEntries[i] = this.mAxis.mEntries[i] + offset;\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void initBuffers() {\n\n        BarData barData = mChart.getBarData();\n        mBarBuffers = new BarBuffer[barData.getDataSetCount()];\n\n        for (int i = 0; i < mBarBuffers.length; i++) {\n            IBarDataSet set = barData.getDataSetByIndex(i);\n            mBarBuffers[i] = new BarBuffer(set.getEntryCount() * 4 * (set.isStacked() ? set.getStackSize() : 1),\n                    barData.getDataSetCount(), set.isStacked());\n        }\n    }",
        "TranslatedCode": "public initBuffers(): void {\n    if (!this.mChart) {\n      return;\n    }\n    let barData: BarData | null = this.mChart.getBarData();\n    if (barData) {\n      this.mBarBuffers = new Array(barData.getDataSetCount());\n      for (let i = 0; i < this.mBarBuffers.length; i++) {\n        let dataSet: IBarDataSet | null = barData.getDataSetByIndex(i);\n        if (dataSet) {\n          this.mBarBuffers[i] = new BarBuffer(dataSet.getEntryCount() * 4 * (dataSet.isStacked() ? dataSet.getStackSize() : 1),\n            barData.getDataSetCount(), dataSet.isStacked());\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void drawData(Canvas c) {\n\n        BarData barData = mChart.getBarData();\n\n        for (int i = 0; i < barData.getDataSetCount(); i++) {\n\n            IBarDataSet set = barData.getDataSetByIndex(i);\n\n            if (set.isVisible()) {\n                drawDataSet(c, set, i);\n            }\n        }\n    }",
        "TranslatedCode": "public drawData(c: CanvasRenderingContext2D): void {\n\n    if (!this.mChart) {\n      return\n    }\n    let barData: BarData | null = this.mChart.getBarData();\n    if (barData) {\n      for (let i = 0; i < barData.getDataSetCount(); i++) {\n        let set: IBarDataSet | null = barData.getDataSetByIndex(i);\n\n        if (set && set.isVisible()) {\n          this.drawDataSet(c, set, i);\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void drawDataSet(Canvas c, IBarDataSet dataSet, int index) {\n\n        Transformer trans = mChart.getTransformer(dataSet.getAxisDependency());\n\n        mBarBorderPaint.setColor(dataSet.getBarBorderColor());\n        mBarBorderPaint.setStrokeWidth(Utils.convertDpToPixel(dataSet.getBarBorderWidth()));\n\n        final boolean drawBorder = dataSet.getBarBorderWidth() > 0.f;\n\n        float phaseX = mAnimator.getPhaseX();\n        float phaseY = mAnimator.getPhaseY();\n\n        // draw the bar shadow before the values\n        if (mChart.isDrawBarShadowEnabled()) {\n            mShadowPaint.setColor(dataSet.getBarShadowColor());\n\n            BarData barData = mChart.getBarData();\n\n            final float barWidth = barData.getBarWidth();\n            final float barWidthHalf = barWidth / 2.0f;\n            float x;\n\n            for (int i = 0, count = Math.min((int)(Math.ceil((float)(dataSet.getEntryCount()) * phaseX)), dataSet.getEntryCount());\n                i < count;\n                i++) {\n\n                BarEntry e = dataSet.getEntryForIndex(i);\n\n                x = e.getX();\n\n                mBarShadowRectBuffer.left = x - barWidthHalf;\n                mBarShadowRectBuffer.right = x + barWidthHalf;\n\n                trans.rectValueToPixel(mBarShadowRectBuffer);\n\n                if (!mViewPortHandler.isInBoundsLeft(mBarShadowRectBuffer.right))\n                    continue;\n\n                if (!mViewPortHandler.isInBoundsRight(mBarShadowRectBuffer.left))\n                    break;\n\n                mBarShadowRectBuffer.top = mViewPortHandler.contentTop();\n                mBarShadowRectBuffer.bottom = mViewPortHandler.contentBottom();\n\n                c.drawRect(mBarShadowRectBuffer, mShadowPaint);\n            }\n        }\n\n        // initialize the buffer\n        BarBuffer buffer = mBarBuffers[index];\n        buffer.setPhases(phaseX, phaseY);\n        buffer.setDataSet(index);\n        buffer.setInverted(mChart.isInverted(dataSet.getAxisDependency()));\n        buffer.setBarWidth(mChart.getBarData().getBarWidth());\n\n        buffer.feed(dataSet);\n\n        trans.pointValuesToPixel(buffer.buffer);\n\n        final boolean isCustomFill = dataSet.getFills() != null && !dataSet.getFills().isEmpty();\n        final boolean isSingleColor = dataSet.getColors().size() == 1;\n        final boolean isInverted = mChart.isInverted(dataSet.getAxisDependency());\n\n        if (isSingleColor) {\n            mRenderPaint.setColor(dataSet.getColor());\n        }\n\n        for (int j = 0, pos = 0; j < buffer.size(); j += 4, pos++) {\n\n            if (!mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))\n                continue;\n\n            if (!mViewPortHandler.isInBoundsRight(buffer.buffer[j]))\n                break;\n\n            if (!isSingleColor) {\n                // Set the color for the currently drawn value. If the index\n                // is out of bounds, reuse colors.\n                mRenderPaint.setColor(dataSet.getColor(pos));\n            }\n\n            if (isCustomFill) {\n                dataSet.getFill(pos)\n                        .fillRect(\n                                c, mRenderPaint,\n                                buffer.buffer[j],\n                                buffer.buffer[j + 1],\n                                buffer.buffer[j + 2],\n                                buffer.buffer[j + 3],\n                                isInverted ? Fill.Direction.DOWN : Fill.Direction.UP);\n            }\n            else {\n                c.drawRect(buffer.buffer[j], buffer.buffer[j + 1], buffer.buffer[j + 2],\n                        buffer.buffer[j + 3], mRenderPaint);\n            }\n\n            if (drawBorder) {\n                c.drawRect(buffer.buffer[j], buffer.buffer[j + 1], buffer.buffer[j + 2],\n                        buffer.buffer[j + 3], mBarBorderPaint);\n            }\n        }\n    }",
        "TranslatedCode": "protected drawDataSet(c: CanvasRenderingContext2D, dataSet: IBarDataSet, index: number): void {\n\n    if (!this.mChart) {\n      return;\n    }\n    let trans: Transformer | null = this.mChart.getTransformer(dataSet.getAxisDependency());\n\n    if (this.mBarBorderPaint) {\n      this.mBarBorderPaint.setColor(dataSet.getBarBorderColor());\n      this.mBarBorderPaint.setStrokeWidth(Utils.handleDataValues(dataSet.getBarBorderWidth()));\n\n    }\n\n    const drawBorder: boolean = dataSet.getBarBorderWidth() > 0.0;\n\n    let phaseX: number = 1;\n    let phaseY: number = 1;\n    if (this.mAnimator) {\n      phaseX = this.mAnimator.getPhaseX();\n      phaseY = this.mAnimator.getPhaseY();\n    }\n\n    // draw the bar shadow before the values\n    if (this.mShadowPaint && this.mChart.isDrawBarShadowEnabled()) {\n      this.mShadowPaint.setColor(dataSet.getBarShadowColor());\n\n      let barData: BarData | null = this.mChart.getBarData();\n      if (!barData) {\n        return;\n      }\n      const radius = barData? barData.getTopRadius(): 0;\n      const barWidth: number = barData.getBarWidth();\n      const barWidthHalf: number = barWidth / 2.0;\n      let x: number = 0;\n\n      for (let i = 0,\n        count = Math.min(Number(Math.ceil(Number(dataSet.getEntryCount()) * phaseX)), dataSet.getEntryCount()); i < count; i++) {\n\n        let e: BarEntry = dataSet.getEntryForIndex(i);\n\n        x = e.getX();\n\n        this.mBarShadowRectBuffer.left = x - barWidthHalf;\n        this.mBarShadowRectBuffer.right = x + barWidthHalf;\n\n        if (trans) {\n          trans.rectValueToPixel(this.mBarShadowRectBuffer);\n        }\n\n        if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsLeft(this.mBarShadowRectBuffer.right)) {\n          continue;\n        }\n\n        if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsRight(this.mBarShadowRectBuffer.left)) {\n          break;\n        }\n\n        this.mBarShadowRectBuffer.top = this.mViewPortHandler ? this.mViewPortHandler.contentTop() : 0;\n        this.mBarShadowRectBuffer.bottom = this.mViewPortHandler ? this.mViewPortHandler.contentBottom() : 0;\n        if (this.mShadowPaint) {\n          switch (this.mShadowPaint.getStyle()) {\n            case Style.STROKE:\n              Utils.drawStrokeRect(radius > 0, c, this.mShadowPaint, this.mBarShadowRectBuffer.left, this.mBarShadowRectBuffer.top, this.mBarShadowRectBuffer.right, this.mBarShadowRectBuffer.bottom, radius, 'both'); // 阴影上下圆角都绘制比较好\n              break;\n            case Style.FILL:\n            case Style.FILL_AND_STROKE:\n            default:\n              Utils.drawFillRect(radius > 0, c, this.mShadowPaint, this.mBarShadowRectBuffer.left, this.mBarShadowRectBuffer.top, this.mBarShadowRectBuffer.right, this.mBarShadowRectBuffer.bottom, radius, 'both'); // 阴影上下圆角都绘制比较好\n              break;\n          }\n        }\n      }\n    }\n\n    // initialize the buffer\n    let buffer: BarBuffer = this.mBarBuffers[index];\n    buffer.setPhases(phaseX, phaseY);\n    buffer.setDataSet(index);\n    buffer.setInverted(this.mChart.isInverted(dataSet.getAxisDependency()));\n    let barData: BarData | null = this.mChart.getBarData();\n    if (barData) {\n      buffer.setBarWidth(barData.getBarWidth());\n    }\n\n    buffer.feed(dataSet);\n    if (trans) {\n      trans.pointValuesToPixel(buffer.buffer);\n    }\n\n    let fills: JArrayList<Fill> | null = dataSet.getFills();\n    const isCustomFill: boolean = !!fills && !fills.isEmpty();\n    const isSingleColor: boolean = dataSet.getColors().size() == 1;\n    const isInverted: boolean = this.mChart.isInverted(dataSet.getAxisDependency());\n\n    if (isSingleColor) {\n      this.mRenderPaint.setColor(dataSet.getColor());\n    }\n\n    for (let j = 0, pos = 0; j < buffer.size(); j += 4, pos++) {\n\n      if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsLeft(buffer.buffer[j + 2]))\n        continue;\n      if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsRight(buffer.buffer[j]))\n        break;\n      if (!isSingleColor) {\n        // Set the color for the currently drawn value. If the index\n        // is out of bounds, reuse colors.\n        this.mRenderPaint.setColor(dataSet.getColor(pos));\n      }\n\n      const radius = barData ? barData.getTopRadius() : 0;\n\n      //顶部的矩形才需要绘制圆角\n      let isDrawRounded = radius != 0 && (j + 4 >= buffer.size() || (j + 4 < buffer.size() && buffer.buffer[j] != buffer.buffer[j + 4]));\n\n      // 圆角位置：同时受 值 和 图表是否 inverted 影响\n      let cornerType: RoundCornerType = 'up'\n      if(dataSet.getEntryForIndex(pos) != null){\n        if (isInverted) {\n          cornerType = dataSet.getEntryForIndex(pos).getY() > 0 ? 'down' : 'up'\n        } else {\n          cornerType = dataSet.getEntryForIndex(pos).getY() > 0 ? 'up' : 'down'\n        }\n      }\n\n      if (isCustomFill) {\n\n        let fill: Fill | null = dataSet.getFill(pos);\n        if (fill) {\n          fill.fillRect(\n            c, this.mRenderPaint,\n            buffer.buffer[j],\n            buffer.buffer[j + 1],\n            buffer.buffer[j + 2],\n            buffer.buffer[j + 3],\n            isInverted ? FillDirection.DOWN : FillDirection.UP, radius, cornerType);\n        }\n\n      } else {\n        Utils.drawFillRect(isDrawRounded, c, this.mRenderPaint, buffer.buffer[j], buffer.buffer[j + 1], buffer.buffer[j + 2], buffer.buffer[j + 3], radius, cornerType);\n      }\n\n      if (drawBorder) {\n        if(this.mBarBorderPaint != null){\n          Utils.drawStrokeRect(isDrawRounded, c, this.mBarBorderPaint, buffer.buffer[j], buffer.buffer[j + 1], buffer.buffer[j + 2], buffer.buffer[j + 3], radius, cornerType);\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void drawValues(Canvas c) {\n\n        // if values are drawn\n        if (isDrawingValuesAllowed(mChart)) {\n\n            List<IBarDataSet> dataSets = mChart.getBarData().getDataSets();\n\n            final float valueOffsetPlus = Utils.convertDpToPixel(4.5f);\n            float posOffset = 0f;\n            float negOffset = 0f;\n            boolean drawValueAboveBar = mChart.isDrawValueAboveBarEnabled();\n\n            for (int i = 0; i < mChart.getBarData().getDataSetCount(); i++) {\n\n                IBarDataSet dataSet = dataSets.get(i);\n\n                if (!shouldDrawValues(dataSet))\n                    continue;\n\n                // apply the text-styling defined by the DataSet\n                applyValueTextStyle(dataSet);\n\n                boolean isInverted = mChart.isInverted(dataSet.getAxisDependency());\n\n                // calculate the correct offset depending on the draw position of\n                // the value\n                float valueTextHeight = Utils.calcTextHeight(mValuePaint, \"8\");\n                posOffset = (drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);\n                negOffset = (drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);\n\n                if (isInverted) {\n                    posOffset = -posOffset - valueTextHeight;\n                    negOffset = -negOffset - valueTextHeight;\n                }\n\n                // get the buffer\n                BarBuffer buffer = mBarBuffers[i];\n\n                final float phaseY = mAnimator.getPhaseY();\n\n                MPPointF iconsOffset = MPPointF.getInstance(dataSet.getIconsOffset());\n                iconsOffset.x = Utils.convertDpToPixel(iconsOffset.x);\n                iconsOffset.y = Utils.convertDpToPixel(iconsOffset.y);\n\n                // if only single values are drawn (sum)\n                if (!dataSet.isStacked()) {\n\n                    for (int j = 0; j < buffer.buffer.length * mAnimator.getPhaseX(); j += 4) {\n\n                        float x = (buffer.buffer[j] + buffer.buffer[j + 2]) / 2f;\n\n                        if (!mViewPortHandler.isInBoundsRight(x))\n                            break;\n\n                        if (!mViewPortHandler.isInBoundsY(buffer.buffer[j + 1])\n                                || !mViewPortHandler.isInBoundsLeft(x))\n                            continue;\n\n                        BarEntry entry = dataSet.getEntryForIndex(j / 4);\n                        float val = entry.getY();\n\n                        if (dataSet.isDrawValuesEnabled()) {\n                            drawValue(c, dataSet.getValueFormatter(), val, entry, i, x,\n                                    val >= 0 ?\n                                            (buffer.buffer[j + 1] + posOffset) :\n                                            (buffer.buffer[j + 3] + negOffset),\n                                    dataSet.getValueTextColor(j / 4));\n                        }\n\n                        if (entry.getIcon() != null && dataSet.isDrawIconsEnabled()) {\n\n                            Drawable icon = entry.getIcon();\n\n                            float px = x;\n                            float py = val >= 0 ?\n                                    (buffer.buffer[j + 1] + posOffset) :\n                                    (buffer.buffer[j + 3] + negOffset);\n\n                            px += iconsOffset.x;\n                            py += iconsOffset.y;\n\n                            Utils.drawImage(\n                                    c,\n                                    icon,\n                                    (int)px,\n                                    (int)py,\n                                    icon.getIntrinsicWidth(),\n                                    icon.getIntrinsicHeight());\n                        }\n                    }\n\n                    // if we have stacks\n                } else {\n\n                    Transformer trans = mChart.getTransformer(dataSet.getAxisDependency());\n\n                    int bufferIndex = 0;\n                    int index = 0;\n\n                    while (index < dataSet.getEntryCount() * mAnimator.getPhaseX()) {\n\n                        BarEntry entry = dataSet.getEntryForIndex(index);\n\n                        float[] vals = entry.getYVals();\n                        float x = (buffer.buffer[bufferIndex] + buffer.buffer[bufferIndex + 2]) / 2f;\n\n                        int color = dataSet.getValueTextColor(index);\n\n                        // we still draw stacked bars, but there is one\n                        // non-stacked\n                        // in between\n                        if (vals == null) {\n\n                            if (!mViewPortHandler.isInBoundsRight(x))\n                                break;\n\n                            if (!mViewPortHandler.isInBoundsY(buffer.buffer[bufferIndex + 1])\n                                    || !mViewPortHandler.isInBoundsLeft(x))\n                                continue;\n\n                            if (dataSet.isDrawValuesEnabled()) {\n                                drawValue(c, dataSet.getValueFormatter(), entry.getY(), entry, i, x,\n                                        buffer.buffer[bufferIndex + 1] +\n                                                (entry.getY() >= 0 ? posOffset : negOffset),\n                                        color);\n                            }\n\n                            if (entry.getIcon() != null && dataSet.isDrawIconsEnabled()) {\n\n                                Drawable icon = entry.getIcon();\n\n                                float px = x;\n                                float py = buffer.buffer[bufferIndex + 1] +\n                                        (entry.getY() >= 0 ? posOffset : negOffset);\n\n                                px += iconsOffset.x;\n                                py += iconsOffset.y;\n\n                                Utils.drawImage(\n                                        c,\n                                        icon,\n                                        (int)px,\n                                        (int)py,\n                                        icon.getIntrinsicWidth(),\n                                        icon.getIntrinsicHeight());\n                            }\n\n                            // draw stack values\n                        } else {\n\n                            float[] transformed = new float[vals.length * 2];\n\n                            float posY = 0f;\n                            float negY = -entry.getNegativeSum();\n\n                            for (int k = 0, idx = 0; k < transformed.length; k += 2, idx++) {\n\n                                float value = vals[idx];\n                                float y;\n\n                                if (value == 0.0f && (posY == 0.0f || negY == 0.0f)) {\n                                    // Take care of the situation of a 0.0 value, which overlaps a non-zero bar\n                                    y = value;\n                                } else if (value >= 0.0f) {\n                                    posY += value;\n                                    y = posY;\n                                } else {\n                                    y = negY;\n                                    negY -= value;\n                                }\n\n                                transformed[k + 1] = y * phaseY;\n                            }\n\n                            trans.pointValuesToPixel(transformed);\n\n                            for (int k = 0; k < transformed.length; k += 2) {\n\n                                final float val = vals[k / 2];\n                                final boolean drawBelow =\n                                        (val == 0.0f && negY == 0.0f && posY > 0.0f) ||\n                                                val < 0.0f;\n                                float y = transformed[k + 1]\n                                        + (drawBelow ? negOffset : posOffset);\n\n                                if (!mViewPortHandler.isInBoundsRight(x))\n                                    break;\n\n                                if (!mViewPortHandler.isInBoundsY(y)\n                                        || !mViewPortHandler.isInBoundsLeft(x))\n                                    continue;\n\n                                if (dataSet.isDrawValuesEnabled()) {\n                                    drawValue(c,\n                                            dataSet.getValueFormatter(),\n                                            vals[k / 2],\n                                            entry,\n                                            i,\n                                            x,\n                                            y,\n                                            color);\n                                }\n\n                                if (entry.getIcon() != null && dataSet.isDrawIconsEnabled()) {\n\n                                    Drawable icon = entry.getIcon();\n\n                                    Utils.drawImage(\n                                            c,\n                                            icon,\n                                            (int)(x + iconsOffset.x),\n                                            (int)(y + iconsOffset.y),\n                                            icon.getIntrinsicWidth(),\n                                            icon.getIntrinsicHeight());\n                                }\n                            }\n                        }\n\n                        bufferIndex = vals == null ? bufferIndex + 4 : bufferIndex + 4 * vals.length;\n                        index++;\n                    }\n                }\n\n                MPPointF.recycleInstance(iconsOffset);\n            }\n        }\n    }\n",
        "TranslatedCode": "public drawValues(c: CanvasRenderingContext2D): void {\n    if (!this.mChart || !this.mChart.getBarData()) {\n      return;\n    }\n    // if values are drawn\n    if (this.isDrawingValuesAllowed(this.mChart)) {\n      let barData: BarData | null = this.mChart.getBarData();\n      if (!barData) {\n        return;\n      }\n      let dataSets: JArrayList<IBarDataSet> = barData.getDataSets();\n\n      const valueOffsetPlus: number = 0;\n      let posOffset: number = 0;\n      let negOffset: number = 0;\n      let drawValueAboveBar: boolean = this.mChart.isDrawValueAboveBarEnabled();\n      for (let i = 0; i < barData.getDataSetCount(); i++) {\n\n        let dataSet: IBarDataSet = dataSets.get(i);\n\n        if (!this.shouldDrawValues(dataSet))\n          continue;\n\n        // apply the text-styling defined by the DataSet\n        this.applyValueTextStyle(dataSet);\n\n        let isInverted: boolean = this.mChart.isInverted(dataSet.getAxisDependency());\n\n        // calculate the correct offset depending on the draw position of\n        // the value\n        let valueTextHeight: number = Utils.getLabelTextSize(this.mValuePaint, \"8\", this.textSizeCache).height;\n        posOffset = (drawValueAboveBar ? -valueOffsetPlus : valueTextHeight + valueOffsetPlus);\n        negOffset = (drawValueAboveBar ? valueTextHeight + valueOffsetPlus : -valueOffsetPlus);\n\n        if (isInverted) {\n          posOffset = -posOffset - valueTextHeight;\n          negOffset = -negOffset - valueTextHeight;\n        }\n\n        // get the buffer\n        let buffer: BarBuffer = this.mBarBuffers[i];\n\n        const phaseY: number = this.mAnimator ? this.mAnimator.getPhaseY() : 1;\n\n        let iconsOffset: MPPointF = MPPointF.getInstance(0, 0, dataSet.getIconsOffset());\n        iconsOffset.x = Utils.handleDataValues(iconsOffset.x);\n        iconsOffset.y = Utils.handleDataValues(iconsOffset.y);\n\n        // if only single values are drawn (sum)\n        if (!dataSet.isStacked()) {\n\n          for (let j = 0; j < buffer.buffer.length * (this.mAnimator ? this.mAnimator.getPhaseX() : 1); j += 4) {\n\n            let x: number = (buffer.buffer[j] + buffer.buffer[j + 2]) / 2;\n\n            if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsRight(x))\n              break;\n\n            if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsY(buffer.buffer[j + 1])\n            || !this.mViewPortHandler.isInBoundsLeft(x))\n              continue;\n\n            let entry: BarEntry = dataSet.getEntryForIndex(j / 4);\n            let val: number = entry.getY();\n\n            if (dataSet.isDrawValuesEnabled()) {\n              let valueFormatter: IValueFormatter | null = dataSet.getValueFormatter();\n              if (valueFormatter) {\n                this.drawValue(c, valueFormatter, val, entry, i, x,\n                    val >= 0 ?\n                    (buffer.buffer[j + 1] + posOffset) :\n                    (buffer.buffer[j + 3] + negOffset),\n                  dataSet.getValueTextColor(j / 4));\n              }\n            }\n            let icon: ChartPixelMap | null = entry.getIcon();\n            if (icon && dataSet.isDrawIconsEnabled()) {\n\n              let px: number = x;\n              let py: number = val >= 0 ?\n                (buffer.buffer[j + 1] + posOffset) :\n                (buffer.buffer[j + 3] + negOffset);\n\n              px += iconsOffset.x;\n              py += iconsOffset.y;\n\n              Utils.drawImage(\n                c,\n                icon,\n                Utils.parseInt(px),\n                Utils.parseInt(py),\n                icon.getWidth(),\n                icon.getHeight());\n            }\n          }\n\n          // if we have stacks\n        } else {\n\n          let trans: Transformer | null = this.mChart.getTransformer(dataSet.getAxisDependency());\n\n          let bufferIndex: number = 0;\n          let index: number = 0;\n\n          while (index < dataSet.getEntryCount() * (this.mAnimator ? this.mAnimator.getPhaseX() : 1)) {\n\n            let entry: BarEntry = dataSet.getEntryForIndex(index);\n\n            let vals: number[] | null = entry.getYVals();\n            let x: number = (buffer.buffer[bufferIndex] + buffer.buffer[bufferIndex + 2]) / 2;\n\n            let color: number = dataSet.getValueTextColor(index);\n\n            // we still draw stacked bars, but there is one\n            // non-stacked\n            // in between\n            if (vals == null) {\n\n              if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsRight(x))\n                break;\n\n              if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsY(buffer.buffer[bufferIndex + 1])\n              || !this.mViewPortHandler.isInBoundsLeft(x))\n                continue;\n\n              if (dataSet.isDrawValuesEnabled()) {\n                let valueFormatter: IValueFormatter | null = dataSet.getValueFormatter();\n                if (valueFormatter) {\n                  this.drawValue(c, valueFormatter, entry.getY(), entry, i, x,\n                    buffer.buffer[bufferIndex + 1] +\n                    (entry.getY() >= 0 ? posOffset : negOffset),\n                    color);\n                }\n              }\n\n              let icon: ChartPixelMap | null = entry.getIcon();\n              if (icon && dataSet.isDrawIconsEnabled()) {\n                let px: number = x;\n                let py: number = buffer.buffer[bufferIndex + 1] +\n                (entry.getY() >= 0 ? posOffset : negOffset);\n\n                px += iconsOffset.x;\n                py += iconsOffset.y;\n\n                Utils.drawImage(\n                  c,\n                  icon,\n                  Utils.parseInt(px),\n                  Utils.parseInt(py),\n                  icon.getWidth(),\n                  icon.getHeight());\n              }\n\n              // draw stack values\n            }\n\n            else {\n\n              let transformed: number[] = new Array<number>(vals.length * 2);\n              let posY: number = 0;\n              let negY: number = -entry.getNegativeSum();\n              for (let k = 0, idx = 0; k < transformed.length; k += 2, idx++) {\n\n                let value: number = vals[idx];\n                let y: number = 0;\n                if (value == 0.0 && (posY == 0.0 || negY == 0.0)) {\n                  // Take care of the situation of a 0.0 value, which overlaps a non-zero bar\n                  y = value;\n                } else if (value >= 0.0) {\n                  posY += value;\n                  y = posY;\n                } else {\n                  y = negY;\n                  negY -= value;\n                }\n\n                transformed[k + 1] = y * phaseY;\n              }\n              if (trans) {\n                trans.pointValuesToPixel(transformed);\n              }\n\n\n              for (let k = 0; k < transformed.length; k += 2) {\n\n                const val: number = vals[k / 2];\n                const drawBelow: boolean = (val == 0.0 && negY == 0.0 && posY > 0.0) || val < 0.0;\n                let y: number = transformed[k + 1] + (drawBelow ? negOffset : posOffset);\n\n                if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsRight(x))\n                  break;\n\n                if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsY(y)\n                || !this.mViewPortHandler.isInBoundsLeft(x))\n                  continue;\n\n                if (dataSet.isDrawValuesEnabled()) {\n                  let valueFormatter: IValueFormatter | null = dataSet.getValueFormatter();\n                  if (valueFormatter) {\n                    this.drawValue(c,\n                      valueFormatter,\n                      vals[k / 2],\n                      entry,\n                      i,\n                      x,\n                      y,\n                      color);\n                  }\n                }\n                let icon: ChartPixelMap | null = entry.getIcon();\n                if (icon && dataSet.isDrawIconsEnabled()) {\n                  Utils.drawImage(\n                    c,\n                    icon,\n                    Number(x + iconsOffset.x),\n                    Number(y + iconsOffset.y),\n                    icon.getWidth(),\n                    icon.getHeight());\n                }\n              }\n            }\n\n            bufferIndex = vals == null ? bufferIndex + 4 : bufferIndex + 4 * vals.length;\n            index++;\n          }\n        }\n\n        MPPointF.recycleInstance(iconsOffset);\n      }\n    }\n }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void drawHighlighted(Canvas c, Highlight[] indices) {\n\n        BarData barData = mChart.getBarData();\n\n        for (Highlight high : indices) {\n\n            IBarDataSet set = barData.getDataSetByIndex(high.getDataSetIndex());\n\n            if (set == null || !set.isHighlightEnabled())\n                continue;\n\n            BarEntry e = set.getEntryForXValue(high.getX(), high.getY());\n\n            if (!isInBoundsX(e, set))\n                continue;\n\n            Transformer trans = mChart.getTransformer(set.getAxisDependency());\n\n            mHighlightPaint.setColor(set.getHighLightColor());\n            mHighlightPaint.setAlpha(set.getHighLightAlpha());\n\n            boolean isStack = (high.getStackIndex() >= 0  && e.isStacked()) ? true : false;\n\n            final float y1;\n            final float y2;\n\n            if (isStack) {\n\n                if(mChart.isHighlightFullBarEnabled()) {\n\n                    y1 = e.getPositiveSum();\n                    y2 = -e.getNegativeSum();\n\n                } else {\n\n                    Range range = e.getRanges()[high.getStackIndex()];\n\n                    y1 = range.from;\n                    y2 = range.to;\n                }\n\n            } else {\n                y1 = e.getY();\n                y2 = 0.f;\n            }\n\n            prepareBarHighlight(e.getX(), y1, y2, barData.getBarWidth() / 2f, trans);\n\n            setHighlightDrawPos(high, mBarRect);\n\n            c.drawRect(mBarRect, mHighlightPaint);\n        }\n    }",
        "TranslatedCode": "public drawHighlighted(c: CanvasRenderingContext2D, indices: Highlight[]): void {\n    if (!this.mChart) {\n      return;\n    }\n    let barData: BarData | null = this.mChart.getBarData();\n    if (!barData) {\n      return;\n    }\n\n    for (let i = 0; i < indices.length; i++) {\n      let high: Highlight = indices[i];\n      let set: IBarDataSet | null = barData.getDataSetByIndex(high.getDataSetIndex());\n\n      if (set == null || !set.isHighlightEnabled())\n        continue;\n\n      let e: BarEntry | null = set.getEntryForXValue(high.getX(), high.getY());\n      if (!e) {\n        continue;\n      }\n      if (!this.isInBoundsX(e, set))\n        continue;\n\n      let trans: Transformer | null = this.mChart.getTransformer(set.getAxisDependency());\n      let highLightColor: number = set.getHighLightColor();\n      if (highLightColor == 0) {\n        highLightColor = Color.Black\n      }\n      this.mHighlightPaint.setColor(highLightColor);\n      this.mHighlightPaint.setGlobalAlpha(set.getHighLightAlpha() / 255);\n\n      let isStack: boolean = (high.getStackIndex() >= 0 && e.isStacked()) ? true : false;\n\n      let y1: number = 0;\n      let y2: number = 0;\n\n      let drawRadius: boolean = false;\n      let radius = barData.getTopRadius();\n\n      if (isStack) {\n\n        if (this.mChart.isHighlightFullBarEnabled()) {\n\n          y1 = e.getPositiveSum();\n          y2 = -e.getNegativeSum();\n\n        } else {\n          let dataRanges: Range[] | null = e.getRanges();\n          if (dataRanges) {\n            let range: Range = dataRanges[high.getStackIndex()];\n            //堆叠柱状图顶部的柱形绘制圆角\n            if(radius != 0 && high.getStackIndex() == dataRanges.length - 1){\n              drawRadius = true;\n            }\n            y1 = range.myfrom;\n            y2 = range.to;\n          }\n        }\n      } else {\n        if (radius != 0) {\n          drawRadius = true;\n        }\n        y1 = e.getY();\n        y2 = 0.0;\n      }\n      if (trans) {\n        this.prepareBarHighlight(e.getX(), y1, y2, barData.getBarWidth() / 2, trans);\n      }\n\n      // 圆角位置\n      let cornerType: RoundCornerType = 'up'\n      // 当前图表是否反向\n      let isInverted: boolean = this.mChart.isInverted(set.getAxisDependency())\n\n      if (isInverted) {\n        cornerType = e.getY() > 0 ? 'down' : 'up'\n      } else {\n        cornerType = e.getY() > 0 ? 'up' : 'down'\n      }\n\n      this.setHighlightDrawPos(high, this.mBarRect);\n      Utils.drawFillRect(drawRadius, c, this.mHighlightPaint, this.mBarRect.left, this.mBarRect.top, this.mBarRect.right, this.mBarRect.bottom, radius, cornerType);\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void drawDataSet(Canvas c, IBubbleDataSet dataSet) {\n\n        if (dataSet.getEntryCount() < 1)\n            return;\n\n        Transformer trans = mChart.getTransformer(dataSet.getAxisDependency());\n\n        float phaseY = mAnimator.getPhaseY();\n\n        mXBounds.set(mChart, dataSet);\n\n        sizeBuffer[0] = 0f;\n        sizeBuffer[2] = 1f;\n\n        trans.pointValuesToPixel(sizeBuffer);\n\n        boolean normalizeSize = dataSet.isNormalizeSizeEnabled();\n\n        // calcualte the full width of 1 step on the x-axis\n        final float maxBubbleWidth = Math.abs(sizeBuffer[2] - sizeBuffer[0]);\n        final float maxBubbleHeight = Math.abs(mViewPortHandler.contentBottom() - mViewPortHandler.contentTop());\n        final float referenceSize = Math.min(maxBubbleHeight, maxBubbleWidth);\n\n        for (int j = mXBounds.min; j <= mXBounds.range + mXBounds.min; j++) {\n\n            final BubbleEntry entry = dataSet.getEntryForIndex(j);\n\n            pointBuffer[0] = entry.getX();\n            pointBuffer[1] = (entry.getY()) * phaseY;\n            trans.pointValuesToPixel(pointBuffer);\n\n            float shapeHalf = getShapeSize(entry.getSize(), dataSet.getMaxSize(), referenceSize, normalizeSize) / 2f;\n\n            if (!mViewPortHandler.isInBoundsTop(pointBuffer[1] + shapeHalf)\n                    || !mViewPortHandler.isInBoundsBottom(pointBuffer[1] - shapeHalf))\n                continue;\n\n            if (!mViewPortHandler.isInBoundsLeft(pointBuffer[0] + shapeHalf))\n                continue;\n\n            if (!mViewPortHandler.isInBoundsRight(pointBuffer[0] - shapeHalf))\n                break;\n\n            final int color = dataSet.getColor(j);\n\n            mRenderPaint.setColor(color);\n            c.drawCircle(pointBuffer[0], pointBuffer[1], shapeHalf, mRenderPaint);\n        }\n    }\nprotected void drawDataSet(Canvas c, IBubbleDataSet dataSet) {\n\n        if (dataSet.getEntryCount() < 1)\n            return;\n\n        Transformer trans = mChart.getTransformer(dataSet.getAxisDependency());\n\n        float phaseY = mAnimator.getPhaseY();\n\n        mXBounds.set(mChart, dataSet);\n\n        sizeBuffer[0] = 0f;\n        sizeBuffer[2] = 1f;\n\n        trans.pointValuesToPixel(sizeBuffer);\n\n        boolean normalizeSize = dataSet.isNormalizeSizeEnabled();\n\n        // calcualte the full width of 1 step on the x-axis\n        final float maxBubbleWidth = Math.abs(sizeBuffer[2] - sizeBuffer[0]);\n        final float maxBubbleHeight = Math.abs(mViewPortHandler.contentBottom() - mViewPortHandler.contentTop());\n        final float referenceSize = Math.min(maxBubbleHeight, maxBubbleWidth);\n\n        for (int j = mXBounds.min; j <= mXBounds.range + mXBounds.min; j++) {\n\n            final BubbleEntry entry = dataSet.getEntryForIndex(j);\n\n            pointBuffer[0] = entry.getX();\n            pointBuffer[1] = (entry.getY()) * phaseY;\n            trans.pointValuesToPixel(pointBuffer);\n\n            float shapeHalf = getShapeSize(entry.getSize(), dataSet.getMaxSize(), referenceSize, normalizeSize) / 2f;\n\n            if (!mViewPortHandler.isInBoundsTop(pointBuffer[1] + shapeHalf)\n                    || !mViewPortHandler.isInBoundsBottom(pointBuffer[1] - shapeHalf))\n                continue;\n\n            if (!mViewPortHandler.isInBoundsLeft(pointBuffer[0] + shapeHalf))\n                continue;\n\n            if (!mViewPortHandler.isInBoundsRight(pointBuffer[0] - shapeHalf))\n                break;\n\n            final int color = dataSet.getColor(j);\n\n            mRenderPaint.setColor(color);\n            c.drawCircle(pointBuffer[0], pointBuffer[1], shapeHalf, mRenderPaint);\n        }\n    }",
        "TranslatedCode": "protected drawDataSet(c: CanvasRenderingContext2D, dataSet: IBubbleDataSet): void {\n\n    if (!dataSet || dataSet.getEntryCount() < 1) return;\n\n\n    let trans: Transformer | null = this.mChart.getTransformer(dataSet.getAxisDependency());\n    if (this.mAnimator && this.mViewPortHandler) {\n\n      let phaseY: number = this.mAnimator.getPhaseY();\n\n      this.mXBounds?.set(this.mChart, dataSet);\n\n      this.sizeBuffer[0] = 0;\n      this.sizeBuffer[2] = 1;\n\n      trans?.pointValuesToPixel(this.sizeBuffer);\n\n      let normalizeSize: boolean = dataSet.isNormalizeSizeEnabled();\n\n      // calculate the full width of 1 step on the x-axis\n      let maxBubbleWidth: number = Math.abs(this.sizeBuffer[2] - this.sizeBuffer[0]);\n      let maxBubbleHeight: number = Math.abs(this.mViewPortHandler.contentBottom() - this.mViewPortHandler.contentTop());\n      let referenceSize: number = Math.min(maxBubbleHeight, maxBubbleWidth);\n      if (!this.mXBounds) return\n      for (let j: number = this.mXBounds.min; j <= this.mXBounds.range + this.mXBounds.min; j++) {\n\n        let entry: BubbleEntry = dataSet.getEntryForIndex(j);\n\n        this.pointBuffer[0] = entry.getX();\n        this.pointBuffer[1] = (entry.getY()) * phaseY;\n        trans?.pointValuesToPixel(this.pointBuffer);\n\n        let shapeHalf: number = this.getShapeSize(entry.getSize(), dataSet.getMaxSize(), referenceSize, normalizeSize) / 2;\n\n        if (!this.mViewPortHandler.isInBoundsTop(this.pointBuffer[1] + shapeHalf) || !this.mViewPortHandler.isInBoundsBottom(this.pointBuffer[1] - shapeHalf)) continue;\n\n        if (!this.mViewPortHandler.isInBoundsLeft(this.pointBuffer[0] + shapeHalf)) continue;\n\n\n        if (!this.mViewPortHandler.isInBoundsRight(this.pointBuffer[0] - shapeHalf)) break;\n        let color: number = dataSet.getColor(j);\n        this.mRenderPaint.setColor(color)\n\n        Utils.resetContext2DWithoutFont(c, this.mRenderPaint);\n\n        c.beginPath();\n        c.arc(this.pointBuffer[0], this.pointBuffer[1], shapeHalf, 0, 2 * Math.PI, true);\n        c.stroke();\n        c.fill();\n        c.closePath();\n\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void drawValues(Canvas c) {\n\n        BubbleData bubbleData = mChart.getBubbleData();\n\n        if (bubbleData == null)\n            return;\n\n        // if values are drawn\n        if (isDrawingValuesAllowed(mChart)) {\n\n            final List<IBubbleDataSet> dataSets = bubbleData.getDataSets();\n\n            float lineHeight = Utils.calcTextHeight(mValuePaint, \"1\");\n\n            for (int i = 0; i < dataSets.size(); i++) {\n\n                IBubbleDataSet dataSet = dataSets.get(i);\n\n                if (!shouldDrawValues(dataSet) || dataSet.getEntryCount() < 1)\n                    continue;\n\n                // apply the text-styling defined by the DataSet\n                applyValueTextStyle(dataSet);\n\n                final float phaseX = Math.max(0.f, Math.min(1.f, mAnimator.getPhaseX()));\n                final float phaseY = mAnimator.getPhaseY();\n\n                mXBounds.set(mChart, dataSet);\n\n                final float[] positions = mChart.getTransformer(dataSet.getAxisDependency())\n                        .generateTransformedValuesBubble(dataSet, phaseY, mXBounds.min, mXBounds.max);\n\n                final float alpha = phaseX == 1 ? phaseY : phaseX;\n\n                MPPointF iconsOffset = MPPointF.getInstance(dataSet.getIconsOffset());\n                iconsOffset.x = Utils.convertDpToPixel(iconsOffset.x);\n                iconsOffset.y = Utils.convertDpToPixel(iconsOffset.y);\n\n                for (int j = 0; j < positions.length; j += 2) {\n\n                    int valueTextColor = dataSet.getValueTextColor(j / 2 + mXBounds.min);\n                    valueTextColor = Color.argb(Math.round(255.f * alpha), Color.red(valueTextColor),\n                            Color.green(valueTextColor), Color.blue(valueTextColor));\n\n                    float x = positions[j];\n                    float y = positions[j + 1];\n\n                    if (!mViewPortHandler.isInBoundsRight(x))\n                        break;\n\n                    if ((!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y)))\n                        continue;\n\n                    BubbleEntry entry = dataSet.getEntryForIndex(j / 2 + mXBounds.min);\n\n                    if (dataSet.isDrawValuesEnabled()) {\n                        drawValue(c, dataSet.getValueFormatter(), entry.getSize(), entry, i, x,\n                                y + (0.5f * lineHeight), valueTextColor);\n                    }\n\n                    if (entry.getIcon() != null && dataSet.isDrawIconsEnabled()) {\n\n                        Drawable icon = entry.getIcon();\n\n                        Utils.drawImage(\n                                c,\n                                icon,\n                                (int)(x + iconsOffset.x),\n                                (int)(y + iconsOffset.y),\n                                icon.getIntrinsicWidth(),\n                                icon.getIntrinsicHeight());\n                    }\n                }\n\n                MPPointF.recycleInstance(iconsOffset);\n            }\n        }\n    }\n",
        "TranslatedCode": "public drawValues(c: CanvasRenderingContext2D): void {\n\n    let bubbleData: BubbleData | null = this.mChart.getBubbleData();\n\n    if (bubbleData == null)\n      return;\n\n    // if values are drawn\n    if (this.isDrawingValuesAllowed(this.mChart) && this.mXBounds) {\n\n      let dataSets: JArrayList<IBubbleDataSet> = bubbleData.getDataSets();\n\n      let lineHeight: number = Utils.getLabelTextSize(this.mValuePaint, \"1\", this.textSizeCache).height;\n\n      for (let i: number = 0; i < dataSets.size(); i++) {\n\n        let dataSet: IBubbleDataSet = dataSets.get(i);\n\n        if (!this.shouldDrawValues(dataSet) || dataSet.getEntryCount() < 1) continue;\n\n        // apply the text-styling defined by the DataSet\n        this.applyValueTextStyle(dataSet);\n        if (!this.mAnimator || !this.mViewPortHandler) continue\n        let phaseX: number = Math.max(0.0, Math.min(1.0, this.mAnimator.getPhaseX()));\n        let phaseY: number = this.mAnimator.getPhaseY();\n\n        this.mXBounds.set(this.mChart, dataSet);\n        let positions: number[] = this.mChart.getTransformer(dataSet.getAxisDependency())!\n          .generateTransformedValuesBubble(dataSet, phaseY, this.mXBounds.min, this.mXBounds.max);\n\n        let alpha: number = phaseX == 1 ? phaseY : phaseX;\n\n        let iconsOffset: MPPointF = MPPointF.getInstance(undefined, undefined, dataSet.getIconsOffset());\n        iconsOffset.x = Utils.handleDataValues(iconsOffset.x);\n        iconsOffset.y = Utils.handleDataValues(iconsOffset.y);\n\n        for (let j: number = 0; j < positions.length; j += 2) {\n\n          let valueTextColor: number = dataSet.getValueTextColor(j / 2 + this.mXBounds.min);\n          valueTextColor = ChartColor.argb(Math.round(255.0 * alpha), ChartColor.red(valueTextColor),\n            ChartColor.green(valueTextColor), ChartColor.blue(valueTextColor));\n\n          let x: number = positions[j];\n          let y: number = positions[j + 1];\n\n          if ((!this.mViewPortHandler.isInBoundsLeft(x) || !this.mViewPortHandler.isInBoundsY(y))) continue;\n\n          let entry: BubbleEntry = dataSet.getEntryForIndex(j / 2 + this.mXBounds.min);\n\n          if (dataSet && dataSet.isDrawValuesEnabled()) {\n\n            this.drawValue(c, dataSet.getValueFormatter()!, entry.getSize(), entry, i, x, y + (0.5 * lineHeight), valueTextColor);\n          }\n\n          if (entry.getIcon() != null && dataSet.isDrawIconsEnabled()) {\n\n            let icon: ChartPixelMap | null = entry.getIcon();\n            if (icon) {\n              Utils.drawImage(\n                c,\n                icon,\n                x + iconsOffset.x,\n                y + iconsOffset.y,\n                icon.getWidth(),\n                icon.getHeight())\n            }\n          }\n        }\n\n        MPPointF.recycleInstance(iconsOffset);\n      }\n    }\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void drawHighlighted(Canvas c, Highlight[] indices) {\n\n        BubbleData bubbleData = mChart.getBubbleData();\n\n        float phaseY = mAnimator.getPhaseY();\n\n        for (Highlight high : indices) {\n\n            IBubbleDataSet set = bubbleData.getDataSetByIndex(high.getDataSetIndex());\n\n            if (set == null || !set.isHighlightEnabled())\n                continue;\n\n            final BubbleEntry entry = set.getEntryForXValue(high.getX(), high.getY());\n\n            if (entry.getY() != high.getY())\n                continue;\n\n            if (!isInBoundsX(entry, set))\n                continue;\n\n            Transformer trans = mChart.getTransformer(set.getAxisDependency());\n\n            sizeBuffer[0] = 0f;\n            sizeBuffer[2] = 1f;\n\n            trans.pointValuesToPixel(sizeBuffer);\n\n            boolean normalizeSize = set.isNormalizeSizeEnabled();\n\n            // calcualte the full width of 1 step on the x-axis\n            final float maxBubbleWidth = Math.abs(sizeBuffer[2] - sizeBuffer[0]);\n            final float maxBubbleHeight = Math.abs(\n                    mViewPortHandler.contentBottom() - mViewPortHandler.contentTop());\n            final float referenceSize = Math.min(maxBubbleHeight, maxBubbleWidth);\n\n            pointBuffer[0] = entry.getX();\n            pointBuffer[1] = (entry.getY()) * phaseY;\n            trans.pointValuesToPixel(pointBuffer);\n\n            high.setDraw(pointBuffer[0], pointBuffer[1]);\n\n            float shapeHalf = getShapeSize(entry.getSize(),\n                    set.getMaxSize(),\n                    referenceSize,\n                    normalizeSize) / 2f;\n\n            if (!mViewPortHandler.isInBoundsTop(pointBuffer[1] + shapeHalf)\n                    || !mViewPortHandler.isInBoundsBottom(pointBuffer[1] - shapeHalf))\n                continue;\n\n            if (!mViewPortHandler.isInBoundsLeft(pointBuffer[0] + shapeHalf))\n                continue;\n\n            if (!mViewPortHandler.isInBoundsRight(pointBuffer[0] - shapeHalf))\n                break;\n\n            final int originalColor = set.getColor((int) entry.getX());\n\n            Color.RGBToHSV(Color.red(originalColor), Color.green(originalColor),\n                    Color.blue(originalColor), _hsvBuffer);\n            _hsvBuffer[2] *= 0.5f;\n            final int color = Color.HSVToColor(Color.alpha(originalColor), _hsvBuffer);\n\n            mHighlightPaint.setColor(color);\n            mHighlightPaint.setStrokeWidth(set.getHighlightCircleWidth());\n            c.drawCircle(pointBuffer[0], pointBuffer[1], shapeHalf, mHighlightPaint);\n        }\n    }",
        "TranslatedCode": "public drawHighlighted(c: CanvasRenderingContext2D, indices: Highlight[]): void {\n\n    let bubbleData: BubbleData | null = this.mChart.getBubbleData();\n    if (!bubbleData) {\n      return;\n    }\n    if (this.mAnimator && this.mViewPortHandler) {\n      let phaseY: number = this.mAnimator.getPhaseY();\n\n      for (let i = 0; i < indices.length; i++) {\n\n        let set: IBubbleDataSet | null = bubbleData.getDataSetByIndex(indices[i].getDataSetIndex());\n\n        if (set == null || !set.isHighlightEnabled()) continue;\n\n        let entry: BubbleEntry | null = set.getEntryForXValue(indices[i].getX(), indices[i].getY());\n\n        if (!entry || entry.getY() != indices[i].getY()) continue;\n\n        if (!this.isInBoundsX(entry, set)) continue;\n\n        let trans: Transformer | null = this.mChart.getTransformer(set.getAxisDependency());\n\n        this.sizeBuffer[0] = 0;\n        this.sizeBuffer[2] = 1;\n\n        trans?.pointValuesToPixel(this.sizeBuffer);\n\n        let normalizeSize: boolean = set.isNormalizeSizeEnabled();\n\n        // calculate the full width of 1 step on the x-axis\n        let maxBubbleWidth: number = Math.abs(this.sizeBuffer[2] - this.sizeBuffer[0]);\n        let maxBubbleHeight: number = Math.abs(\n          this.mViewPortHandler.contentBottom() - this.mViewPortHandler.contentTop());\n        let referenceSize: number = Math.min(maxBubbleHeight, maxBubbleWidth);\n\n        this.pointBuffer[0] = entry.getX();\n        this.pointBuffer[1] = (entry.getY()) * phaseY;\n        trans?.pointValuesToPixel(this.pointBuffer);\n\n        indices[i].setDraw(this.pointBuffer[0], this.pointBuffer[1]);\n\n        let shapeHalf: number = this.getShapeSize(entry.getSize(),\n          set.getMaxSize(),\n          referenceSize,\n          normalizeSize) / 2;\n\n        if (!this.mViewPortHandler.isInBoundsTop(this.pointBuffer[1] + shapeHalf) || !this.mViewPortHandler.isInBoundsBottom(this.pointBuffer[1] - shapeHalf)) continue;\n\n        if (!this.mViewPortHandler.isInBoundsLeft(this.pointBuffer[0] + shapeHalf)) continue;\n\n        if (!this.mViewPortHandler.isInBoundsRight(this.pointBuffer[0] - shapeHalf)) break;\n\n        let originalColor: number = set.getColor(/*(int)*/ entry.getX());\n\n        ChartColor.RGBToHSV(ChartColor.red(originalColor), ChartColor.green(originalColor), ChartColor.blue(originalColor), this._hsvBuffer);\n        this._hsvBuffer[2] *= 0.5;\n        let color: number = ChartColor.HSVToColor(ChartColor.alpha(originalColor), this._hsvBuffer);\n\n        this.mHighlightPaint.setColor(color);\n        this.mHighlightPaint.setStrokeWidth(set.getHighlightCircleWidth());\n        Utils.resetContext2DWithoutFont(c, this.mHighlightPaint);\n        c.beginPath();\n        c.arc(this.pointBuffer[0], this.pointBuffer[1], shapeHalf, 0, 2 * Math.PI);\n        c.stroke();\n        c.closePath();\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void drawDataSet(Canvas c, ICandleDataSet dataSet) {\n\n        Transformer trans = mChart.getTransformer(dataSet.getAxisDependency());\n\n        float phaseY = mAnimator.getPhaseY();\n        float barSpace = dataSet.getBarSpace();\n        boolean showCandleBar = dataSet.getShowCandleBar();\n\n        mXBounds.set(mChart, dataSet);\n\n        mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());\n\n        // draw the body\n        for (int j = mXBounds.min; j <= mXBounds.range + mXBounds.min; j++) {\n\n            // get the entry\n            CandleEntry e = dataSet.getEntryForIndex(j);\n\n            if (e == null)\n                continue;\n\n            final float xPos = e.getX();\n\n            final float open = e.getOpen();\n            final float close = e.getClose();\n            final float high = e.getHigh();\n            final float low = e.getLow();\n\n            if (showCandleBar) {\n                // calculate the shadow\n\n                mShadowBuffers[0] = xPos;\n                mShadowBuffers[2] = xPos;\n                mShadowBuffers[4] = xPos;\n                mShadowBuffers[6] = xPos;\n\n                if (open > close) {\n                    mShadowBuffers[1] = high * phaseY;\n                    mShadowBuffers[3] = open * phaseY;\n                    mShadowBuffers[5] = low * phaseY;\n                    mShadowBuffers[7] = close * phaseY;\n                } else if (open < close) {\n                    mShadowBuffers[1] = high * phaseY;\n                    mShadowBuffers[3] = close * phaseY;\n                    mShadowBuffers[5] = low * phaseY;\n                    mShadowBuffers[7] = open * phaseY;\n                } else {\n                    mShadowBuffers[1] = high * phaseY;\n                    mShadowBuffers[3] = open * phaseY;\n                    mShadowBuffers[5] = low * phaseY;\n                    mShadowBuffers[7] = mShadowBuffers[3];\n                }\n\n                trans.pointValuesToPixel(mShadowBuffers);\n\n                // draw the shadows\n\n                if (dataSet.getShadowColorSameAsCandle()) {\n\n                    if (open > close)\n                        mRenderPaint.setColor(\n                                dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE ?\n                                        dataSet.getColor(j) :\n                                        dataSet.getDecreasingColor()\n                        );\n\n                    else if (open < close)\n                        mRenderPaint.setColor(\n                                dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE ?\n                                        dataSet.getColor(j) :\n                                        dataSet.getIncreasingColor()\n                        );\n\n                    else\n                        mRenderPaint.setColor(\n                                dataSet.getNeutralColor() == ColorTemplate.COLOR_NONE ?\n                                        dataSet.getColor(j) :\n                                        dataSet.getNeutralColor()\n                        );\n\n                } else {\n                    mRenderPaint.setColor(\n                            dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ?\n                                    dataSet.getColor(j) :\n                                    dataSet.getShadowColor()\n                    );\n                }\n\n                mRenderPaint.setStyle(Paint.Style.STROKE);\n\n                c.drawLines(mShadowBuffers, mRenderPaint);\n\n                // calculate the body\n\n                mBodyBuffers[0] = xPos - 0.5f + barSpace;\n                mBodyBuffers[1] = close * phaseY;\n                mBodyBuffers[2] = (xPos + 0.5f - barSpace);\n                mBodyBuffers[3] = open * phaseY;\n\n                trans.pointValuesToPixel(mBodyBuffers);\n\n                // draw body differently for increasing and decreasing entry\n                if (open > close) { // decreasing\n\n                    if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {\n                        mRenderPaint.setColor(dataSet.getColor(j));\n                    } else {\n                        mRenderPaint.setColor(dataSet.getDecreasingColor());\n                    }\n\n                    mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());\n\n                    c.drawRect(\n                            mBodyBuffers[0], mBodyBuffers[3],\n                            mBodyBuffers[2], mBodyBuffers[1],\n                            mRenderPaint);\n\n                } else if (open < close) {\n\n                    if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {\n                        mRenderPaint.setColor(dataSet.getColor(j));\n                    } else {\n                        mRenderPaint.setColor(dataSet.getIncreasingColor());\n                    }\n\n                    mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());\n\n                    c.drawRect(\n                            mBodyBuffers[0], mBodyBuffers[1],\n                            mBodyBuffers[2], mBodyBuffers[3],\n                            mRenderPaint);\n                } else { // equal values\n\n                    if (dataSet.getNeutralColor() == ColorTemplate.COLOR_NONE) {\n                        mRenderPaint.setColor(dataSet.getColor(j));\n                    } else {\n                        mRenderPaint.setColor(dataSet.getNeutralColor());\n                    }\n\n                    c.drawLine(\n                            mBodyBuffers[0], mBodyBuffers[1],\n                            mBodyBuffers[2], mBodyBuffers[3],\n                            mRenderPaint);\n                }\n            } else {\n\n                mRangeBuffers[0] = xPos;\n                mRangeBuffers[1] = high * phaseY;\n                mRangeBuffers[2] = xPos;\n                mRangeBuffers[3] = low * phaseY;\n\n                mOpenBuffers[0] = xPos - 0.5f + barSpace;\n                mOpenBuffers[1] = open * phaseY;\n                mOpenBuffers[2] = xPos;\n                mOpenBuffers[3] = open * phaseY;\n\n                mCloseBuffers[0] = xPos + 0.5f - barSpace;\n                mCloseBuffers[1] = close * phaseY;\n                mCloseBuffers[2] = xPos;\n                mCloseBuffers[3] = close * phaseY;\n\n                trans.pointValuesToPixel(mRangeBuffers);\n                trans.pointValuesToPixel(mOpenBuffers);\n                trans.pointValuesToPixel(mCloseBuffers);\n\n                // draw the ranges\n                int barColor;\n\n                if (open > close)\n                    barColor = dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE\n                            ? dataSet.getColor(j)\n                            : dataSet.getDecreasingColor();\n                else if (open < close)\n                    barColor = dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE\n                            ? dataSet.getColor(j)\n                            : dataSet.getIncreasingColor();\n                else\n                    barColor = dataSet.getNeutralColor() == ColorTemplate.COLOR_NONE\n                            ? dataSet.getColor(j)\n                            : dataSet.getNeutralColor();\n\n                mRenderPaint.setColor(barColor);\n                c.drawLine(\n                        mRangeBuffers[0], mRangeBuffers[1],\n                        mRangeBuffers[2], mRangeBuffers[3],\n                        mRenderPaint);\n                c.drawLine(\n                        mOpenBuffers[0], mOpenBuffers[1],\n                        mOpenBuffers[2], mOpenBuffers[3],\n                        mRenderPaint);\n                c.drawLine(\n                        mCloseBuffers[0], mCloseBuffers[1],\n                        mCloseBuffers[2], mCloseBuffers[3],\n                        mRenderPaint);\n            }\n        }\n    }",
        "TranslatedCode": "protected drawDataSet(c: CanvasRenderingContext2D, dataSet: ICandleDataSet): void {\n    if (!this.mChart) {\n      return;\n    }\n\n    let trans: Transformer | null = this.mChart.getTransformer(dataSet.getAxisDependency());\n\n    let phaseY: number = this.mAnimator ? this.mAnimator.getPhaseY() : 1;\n    let barSpace: number = dataSet.getBarSpace();\n    let showCandleBar: boolean = dataSet.getShowCandleBar();\n\n    if (this.mXBounds) {\n      this.mXBounds.set(this.mChart, dataSet);\n\n      this.mRenderPaint.setStrokeWidth(dataSet.getShadowWidth());\n      // LogUtil.log('-------------------------dataRenderbuffers drawDataSet: ' + this.mXBounds.min + \"  length: \" + (this.mXBounds.range + this.mXBounds.min))\n      for (let j = this.mXBounds.min; j <= this.mXBounds.range + this.mXBounds.min; j++) {\n        let e: CandleEntry = dataSet.getEntryForIndex(j);\n        if (!e) {\n          continue;\n        }\n        const xPos: number = e.getX();\n        const open: number = e.getOpen();\n        const close: number = e.getClose();\n        const high: number = e.getHigh();\n        const low: number = e.getLow();\n\n        if (showCandleBar) {\n          this.mShadowBuffers[0] = xPos;\n          this.mShadowBuffers[2] = xPos;\n          this.mShadowBuffers[4] = xPos;\n          this.mShadowBuffers[6] = xPos;\n\n          if (open > close) {\n            this.mShadowBuffers[1] = high * phaseY;\n            this.mShadowBuffers[3] = open * phaseY;\n            this.mShadowBuffers[5] = low * phaseY;\n            this.mShadowBuffers[7] = close * phaseY;\n          } else if (open < close) {\n            this.mShadowBuffers[1] = high * phaseY;\n            this.mShadowBuffers[3] = close * phaseY;\n            this.mShadowBuffers[5] = low * phaseY;\n            this.mShadowBuffers[7] = open * phaseY;\n          } else {\n            this.mShadowBuffers[1] = high * phaseY;\n            this.mShadowBuffers[3] = open * phaseY;\n            this.mShadowBuffers[5] = low * phaseY;\n            this.mShadowBuffers[7] = this.mShadowBuffers[3];\n          }\n          if (trans) {\n            trans.pointValuesToPixel(this.mShadowBuffers);\n          }\n\n          if (dataSet.getShadowColorSameAsCandle()) {\n            if (open > close) {\n              this.mRenderPaint.setColor(\n                  dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE ?\n                dataSet.getColor(j) :\n                dataSet.getDecreasingColor()\n              );\n            } else if (open < close) {\n              this.mRenderPaint.setColor(\n                  dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE ?\n                dataSet.getColor(j) :\n                dataSet.getIncreasingColor()\n              );\n            } else {\n              this.mRenderPaint.setColor(\n                  dataSet.getNeutralColor() == ColorTemplate.COLOR_NONE ?\n                dataSet.getColor(j) :\n                dataSet.getNeutralColor()\n              );\n            }\n          } else {\n            this.mRenderPaint.setColor(\n                dataSet.getShadowColor() == ColorTemplate.COLOR_NONE ?\n              dataSet.getColor(j) :\n              dataSet.getShadowColor()\n            );\n          }\n\n          this.mRenderPaint.setStyle(Style.STROKE);\n          Utils.resetContext2DWithoutFont(c, this.mRenderPaint);\n          c.beginPath();\n          c.moveTo(this.mShadowBuffers[0], this.mShadowBuffers[1]);\n          c.lineTo(this.mShadowBuffers[2], this.mShadowBuffers[3])\n          c.moveTo(this.mShadowBuffers[4], this.mShadowBuffers[5]);\n          c.lineTo(this.mShadowBuffers[6], this.mShadowBuffers[7])\n          c.stroke();\n          c.closePath();\n\n          this.mBodyBuffers[0] = xPos - 0.5 + barSpace;\n          this.mBodyBuffers[1] = close * phaseY;\n          this.mBodyBuffers[2] = (xPos + 0.5 - barSpace);\n          this.mBodyBuffers[3] = open * phaseY;\n\n          if (trans) {\n            trans.pointValuesToPixel(this.mBodyBuffers);\n          }\n\n          if (open > close) {\n\n            if (dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE) {\n              this.mRenderPaint.setColor(dataSet.getColor(j));\n            } else {\n              this.mRenderPaint.setColor(dataSet.getDecreasingColor());\n            }\n\n            this.mRenderPaint.setStyle(dataSet.getDecreasingPaintStyle());\n            Utils.resetContext2DWithoutFont(c, this.mRenderPaint);\n            let paintStyle = this.mRenderPaint.getStyle();\n            switch (paintStyle) {\n              case Style.STROKE:\n                c.strokeRect(this.mBodyBuffers[0], this.mBodyBuffers[3],\n                  this.mBodyBuffers[2] - this.mBodyBuffers[0], this.mBodyBuffers[1] - this.mBodyBuffers[3]);\n                break;\n              case Style.FILL:\n              case Style.FILL_AND_STROKE:\n              default:\n                c.fillRect(this.mBodyBuffers[0], this.mBodyBuffers[3],\n                  this.mBodyBuffers[2] - this.mBodyBuffers[0], this.mBodyBuffers[1] - this.mBodyBuffers[3]);\n                break;\n            }\n          } else if (open < close) {\n            if (dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE) {\n              this.mRenderPaint.setColor(dataSet.getColor(j));\n            } else {\n              this.mRenderPaint.setColor(dataSet.getIncreasingColor());\n            }\n\n            this.mRenderPaint.setStyle(dataSet.getIncreasingPaintStyle());\n            Utils.resetContext2DWithoutFont(c, this.mRenderPaint);\n            let paintStyle = this.mRenderPaint.getStyle();\n\n            switch (paintStyle) {\n              case Style.STROKE:\n                c.strokeRect(this.mBodyBuffers[0], this.mBodyBuffers[1],\n                  this.mBodyBuffers[2] - this.mBodyBuffers[0], this.mBodyBuffers[3] - this.mBodyBuffers[1]);\n                break;\n              case Style.FILL:\n              case Style.FILL_AND_STROKE:\n              default:\n                c.fillRect(this.mBodyBuffers[0], this.mBodyBuffers[1],\n                  this.mBodyBuffers[2] - this.mBodyBuffers[0], this.mBodyBuffers[3] - this.mBodyBuffers[1]);\n                break;\n            }\n          } else {\n            if (dataSet.getNeutralColor() == ColorTemplate.COLOR_NONE) {\n              this.mRenderPaint.setColor(dataSet.getColor(j));\n            } else {\n              this.mRenderPaint.setColor(dataSet.getNeutralColor());\n            }\n            Utils.resetContext2DWithoutFont(c, this.mRenderPaint);\n            c.moveTo(this.mBodyBuffers[0], this.mBodyBuffers[1]);\n            c.lineTo(this.mBodyBuffers[2], this.mBodyBuffers[3]);\n            c.stroke();\n          }\n        } else {\n          this.mRangeBuffers[0] = xPos;\n          this.mRangeBuffers[1] = high * phaseY;\n          this.mRangeBuffers[2] = xPos;\n          this.mRangeBuffers[3] = low * phaseY;\n\n          this.mOpenBuffers[0] = xPos - 0.5 + barSpace;\n          this.mOpenBuffers[1] = open * phaseY;\n          this.mOpenBuffers[2] = xPos;\n          this.mOpenBuffers[3] = open * phaseY;\n\n          this.mCloseBuffers[0] = xPos + 0.5 - barSpace;\n          this.mCloseBuffers[1] = close * phaseY;\n          this.mCloseBuffers[2] = xPos;\n          this.mCloseBuffers[3] = close * phaseY;\n\n          if (trans) {\n            trans.pointValuesToPixel(this.mRangeBuffers);\n            trans.pointValuesToPixel(this.mOpenBuffers);\n            trans.pointValuesToPixel(this.mCloseBuffers);\n          }\n\n          let barColor: number = 0;\n\n          if (open > close) {\n            barColor = dataSet.getDecreasingColor() == ColorTemplate.COLOR_NONE\n              ? dataSet.getColor(j)\n              : dataSet.getDecreasingColor();\n          } else if (open < close) {\n            barColor = dataSet.getIncreasingColor() == ColorTemplate.COLOR_NONE\n              ? dataSet.getColor(j)\n              : dataSet.getIncreasingColor();\n          } else {\n            barColor = dataSet.getNeutralColor() == ColorTemplate.COLOR_NONE\n              ? dataSet.getColor(j)\n              : dataSet.getNeutralColor();\n          }\n\n          this.mRenderPaint.setColor(barColor);\n          Utils.resetContext2DWithoutFont(c, this.mRenderPaint)\n          c.moveTo(this.mRangeBuffers[0], this.mRangeBuffers[1]);\n          c.lineTo(this.mRangeBuffers[2], this.mRangeBuffers[3]);\n\n          c.moveTo(this.mOpenBuffers[0], this.mOpenBuffers[1]);\n          c.lineTo(this.mOpenBuffers[2], this.mOpenBuffers[3]);\n\n          c.moveTo(this.mCloseBuffers[0], this.mCloseBuffers[1]);\n          c.lineTo(this.mCloseBuffers[2], this.mCloseBuffers[3]);\n        }\n      }\n    }\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void drawValues(Canvas c) {\n\n        // if values are drawn\n        if (isDrawingValuesAllowed(mChart)) {\n\n            List<ICandleDataSet> dataSets = mChart.getCandleData().getDataSets();\n\n            for (int i = 0; i < dataSets.size(); i++) {\n\n                ICandleDataSet dataSet = dataSets.get(i);\n\n                if (!shouldDrawValues(dataSet) || dataSet.getEntryCount() < 1)\n                    continue;\n\n                // apply the text-styling defined by the DataSet\n                applyValueTextStyle(dataSet);\n\n                Transformer trans = mChart.getTransformer(dataSet.getAxisDependency());\n\n                mXBounds.set(mChart, dataSet);\n\n                float[] positions = trans.generateTransformedValuesCandle(\n                        dataSet, mAnimator.getPhaseX(), mAnimator.getPhaseY(), mXBounds.min, mXBounds.max);\n\n                float yOffset = Utils.convertDpToPixel(5f);\n\n                MPPointF iconsOffset = MPPointF.getInstance(dataSet.getIconsOffset());\n                iconsOffset.x = Utils.convertDpToPixel(iconsOffset.x);\n                iconsOffset.y = Utils.convertDpToPixel(iconsOffset.y);\n\n                for (int j = 0; j < positions.length; j += 2) {\n\n                    float x = positions[j];\n                    float y = positions[j + 1];\n\n                    if (!mViewPortHandler.isInBoundsRight(x))\n                        break;\n\n                    if (!mViewPortHandler.isInBoundsLeft(x) || !mViewPortHandler.isInBoundsY(y))\n                        continue;\n\n                    CandleEntry entry = dataSet.getEntryForIndex(j / 2 + mXBounds.min);\n\n                    if (dataSet.isDrawValuesEnabled()) {\n                        drawValue(c,\n                                dataSet.getValueFormatter(),\n                                entry.getHigh(),\n                                entry,\n                                i,\n                                x,\n                                y - yOffset,\n                                dataSet\n                                        .getValueTextColor(j / 2));\n                    }\n\n                    if (entry.getIcon() != null && dataSet.isDrawIconsEnabled()) {\n\n                        Drawable icon = entry.getIcon();\n\n                        Utils.drawImage(\n                                c,\n                                icon,\n                                (int)(x + iconsOffset.x),\n                                (int)(y + iconsOffset.y),\n                                icon.getIntrinsicWidth(),\n                                icon.getIntrinsicHeight());\n                    }\n                }\n\n                MPPointF.recycleInstance(iconsOffset);\n            }\n        }\n    }",
        "TranslatedCode": "public drawValues(c: CanvasRenderingContext2D): void {\n    if (!this.mChart) {\n      return;\n    }\n    if (this.isDrawingValuesAllowed(this.mChart)) {\n      let chartData = this.mChart.getCandleData();\n      if (!chartData) {\n        return;\n      }\n\n      let dataSets: JArrayList<ICandleDataSet> = chartData.getDataSets();\n\n      for (let i = 0; i < dataSets.size(); i++) {\n        let dataSet: ICandleDataSet = dataSets.get(i);\n\n        if (!this.shouldDrawValues(dataSet) || dataSet.getEntryCount() < 1) {\n          continue;\n        }\n\n        this.applyValueTextStyle(dataSet);\n\n        let trans: Transformer | null = this.mChart.getTransformer(dataSet.getAxisDependency());\n        if (this.mXBounds) {\n          this.mXBounds.set(this.mChart, dataSet);\n          let positions: number[] = [];\n          if (trans) {\n            positions = trans.generateTransformedValuesCandle(\n              dataSet, (this.mAnimator ? this.mAnimator.getPhaseX() : 1), (this.mAnimator ? this.mAnimator.getPhaseY() : 1), this.mXBounds.min, this.mXBounds.max);\n          }\n\n          let yOffset: number = Utils.handleDataValues(5.0);\n\n          let iconsOffset: MPPointF = MPPointF.getInstance(undefined, undefined, dataSet.getIconsOffset());\n          iconsOffset.x = Utils.handleDataValues(iconsOffset.x);\n          iconsOffset.y = Utils.handleDataValues(iconsOffset.y);\n\n          for (let j = 0; j < positions.length; j += 2) {\n            let x: number = positions[j];\n            let y: number = positions[j + 1];\n\n            if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsRight(x)) {\n              break;\n            }\n\n            if (!this.mViewPortHandler || !this.mViewPortHandler.isInBoundsLeft(x) || !this.mViewPortHandler.isInBoundsY(y)) {\n              continue;\n            }\n\n            let entry: CandleEntry = dataSet.getEntryForIndex(j / 2 + this.mXBounds.min);\n\n            if (dataSet.isDrawValuesEnabled()) {\n              this.drawValue(\n                c,\n                dataSet.getValueFormatter() !,\n                entry.getHigh(),\n                entry,\n                i,\n                x,\n                y - yOffset,\n                dataSet.getValueTextColor(j / 2))\n            }\n            if (entry.getIcon != null && dataSet.isDrawIconsEnabled()) {\n              let icon: ChartPixelMap | null = entry.getIcon();\n              if (icon) {\n                Utils.drawImage(\n                  c,\n                  icon,\n                  Number(x + iconsOffset.x),\n                  Number(y + iconsOffset.y),\n                  icon.getWidth(),\n                  icon.getHeight());\n              }\n            }\n          }\n          MPPointF.recycleInstance(iconsOffset);\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void drawHighlighted(Canvas c, Highlight[] indices) {\n\n        CandleData candleData = mChart.getCandleData();\n\n        for (Highlight high : indices) {\n\n            ICandleDataSet set = candleData.getDataSetByIndex(high.getDataSetIndex());\n\n            if (set == null || !set.isHighlightEnabled())\n                continue;\n\n            CandleEntry e = set.getEntryForXValue(high.getX(), high.getY());\n\n            if (!isInBoundsX(e, set))\n                continue;\n\n            float lowValue = e.getLow() * mAnimator.getPhaseY();\n            float highValue = e.getHigh() * mAnimator.getPhaseY();\n            float y = (lowValue + highValue) / 2f;\n\n            MPPointD pix = mChart.getTransformer(set.getAxisDependency()).getPixelForValues(e.getX(), y);\n\n            high.setDraw((float) pix.x, (float) pix.y);\n\n            // draw the lines\n            drawHighlightLines(c, (float) pix.x, (float) pix.y, set);\n        }\n    }",
        "TranslatedCode": "public drawHighlighted(c: CanvasRenderingContext2D, indices: Highlight[]) {\n    if (!this.mChart) {\n      return;\n    }\n    let candleData: CandleData | null = this.mChart.getCandleData();\n    if (!candleData) {\n      return;\n    }\n\n    for (let i = 0; i < indices.length; i++) {\n      let high = indices[i];\n\n      let set: ICandleDataSet | null = candleData.getDataSetByIndex(high.getDataSetIndex());\n\n      if (set == null || !set.isHighlightEnabled()) {\n        continue;\n      }\n      let e: CandleEntry | null = set.getEntryForXValue(high.getX(), high.getY());\n      if (!e) {\n        continue;\n      }\n\n      if (!this.isInBoundsX(e, set)) {\n        continue;\n      }\n      let lowValue: number = e.getLow() * (this.mAnimator ? this.mAnimator.getPhaseY() : 1);\n      let highValue: number = e.getHigh() * (this.mAnimator ? this.mAnimator.getPhaseY() : 1);\n\n      let y: number = (lowValue + highValue) / 2.0;\n      let transformer: Transformer | null = this.mChart.getTransformer(set.getAxisDependency());\n      let pix: MPPointD = MPPointD.getInstance(0, 0);\n      if (transformer) {\n        pix = transformer.getPixelForValues(e.getX(), y);\n      }\n      high.setDraw(Number(pix.x), Number(pix.y));\n      this.drawHighlightLines(c, Number(pix.x), Number(pix.y), set);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void initBuffers() {\n\n        BarData barData = mChart.getBarData();\n        mBarBuffers = new HorizontalBarBuffer[barData.getDataSetCount()];\n\n        for (int i = 0; i < mBarBuffers.length; i++) {\n            IBarDataSet set = barData.getDataSetByIndex(i);\n            mBarBuffers[i] = new HorizontalBarBuffer(set.getEntryCount() * 4 * (set.isStacked() ? set.getStackSize() : 1),\n                    barData.getDataSetCount(), set.isStacked());\n        }\n    }",
        "TranslatedCode": "initBuffers() {\n    if (!this.mChart) {\n      return;\n    }\n    let barData: BarData | null = this.mChart.getBarData();\n    if (!barData) {\n      return;\n    }\n    this.mBarBuffers = new Array<HorizontalBarBuffer>(barData.getDataSetCount());\n    for (let i = 0; i < this.mBarBuffers.length; i++) {\n      let set: IBarDataSet | null = barData.getDataSetByIndex(i);\n      if (set) {\n        this.mBarBuffers[i] = new HorizontalBarBuffer(set.getEntryCount() * 4 * (set.isStacked() ? set.getStackSize() : 1),\n          barData.getDataSetCount(), set.isStacked());\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Prepares the legend and calculates all needed forms, labels and colors.\n     *\n     * @param data\n     */\n    public void computeLegend(ChartData<?> data) {\n\n        if (!mLegend.isLegendCustom()) {\n\n            computedEntries.clear();\n\n            // loop for building up the colors and labels used in the legend\n            for (int i = 0; i < data.getDataSetCount(); i++) {\n\n                IDataSet dataSet = data.getDataSetByIndex(i);\n                if (dataSet == null) continue;\n\n                List<Integer> clrs = dataSet.getColors();\n                int entryCount = dataSet.getEntryCount();\n\n                // if we have a barchart with stacked bars\n                if (dataSet instanceof IBarDataSet && ((IBarDataSet) dataSet).isStacked()) {\n\n                    IBarDataSet bds = (IBarDataSet) dataSet;\n                    String[] sLabels = bds.getStackLabels();\n\n                    int minEntries = Math.min(clrs.size(), bds.getStackSize());\n\n                    for (int j = 0; j < minEntries; j++) {\n                        String label;\n                        if (sLabels.length > 0) {\n                            int labelIndex = j % minEntries;\n                            label = labelIndex < sLabels.length ? sLabels[labelIndex] : null;\n                        } else {\n                            label = null;\n                        }\n\n                        computedEntries.add(new LegendEntry(\n                                label,\n                                dataSet.getForm(),\n                                dataSet.getFormSize(),\n                                dataSet.getFormLineWidth(),\n                                dataSet.getFormLineDashEffect(),\n                                clrs.get(j)\n                        ));\n                    }\n\n                    if (bds.getLabel() != null) {\n                        // add the legend description label\n                        computedEntries.add(new LegendEntry(\n                                dataSet.getLabel(),\n                                Legend.LegendForm.NONE,\n                                Float.NaN,\n                                Float.NaN,\n                                null,\n                                ColorTemplate.COLOR_NONE\n                        ));\n                    }\n\n                } else if (dataSet instanceof IPieDataSet) {\n\n                    IPieDataSet pds = (IPieDataSet) dataSet;\n\n                    for (int j = 0; j < clrs.size() && j < entryCount; j++) {\n\n                        computedEntries.add(new LegendEntry(\n                                pds.getEntryForIndex(j).getLabel(),\n                                dataSet.getForm(),\n                                dataSet.getFormSize(),\n                                dataSet.getFormLineWidth(),\n                                dataSet.getFormLineDashEffect(),\n                                clrs.get(j)\n                        ));\n                    }\n\n                    if (pds.getLabel() != null) {\n                        // add the legend description label\n                        computedEntries.add(new LegendEntry(\n                                dataSet.getLabel(),\n                                Legend.LegendForm.NONE,\n                                Float.NaN,\n                                Float.NaN,\n                                null,\n                                ColorTemplate.COLOR_NONE\n                        ));\n                    }\n\n                } else if (dataSet instanceof ICandleDataSet && ((ICandleDataSet) dataSet).getDecreasingColor() !=\n                        ColorTemplate.COLOR_NONE) {\n\n                    int decreasingColor = ((ICandleDataSet) dataSet).getDecreasingColor();\n                    int increasingColor = ((ICandleDataSet) dataSet).getIncreasingColor();\n\n                    computedEntries.add(new LegendEntry(\n                            null,\n                            dataSet.getForm(),\n                            dataSet.getFormSize(),\n                            dataSet.getFormLineWidth(),\n                            dataSet.getFormLineDashEffect(),\n                            decreasingColor\n                    ));\n\n                    computedEntries.add(new LegendEntry(\n                            dataSet.getLabel(),\n                            dataSet.getForm(),\n                            dataSet.getFormSize(),\n                            dataSet.getFormLineWidth(),\n                            dataSet.getFormLineDashEffect(),\n                            increasingColor\n                    ));\n\n                } else { // all others\n\n                    for (int j = 0; j < clrs.size() && j < entryCount; j++) {\n\n                        String label;\n\n                        // if multiple colors are set for a DataSet, group them\n                        if (j < clrs.size() - 1 && j < entryCount - 1) {\n                            label = null;\n                        } else { // add label to the last entry\n                            label = data.getDataSetByIndex(i).getLabel();\n                        }\n\n                        computedEntries.add(new LegendEntry(\n                                label,\n                                dataSet.getForm(),\n                                dataSet.getFormSize(),\n                                dataSet.getFormLineWidth(),\n                                dataSet.getFormLineDashEffect(),\n                                clrs.get(j)\n                        ));\n                    }\n                }\n            }\n\n            if (mLegend.getExtraEntries() != null) {\n                Collections.addAll(computedEntries, mLegend.getExtraEntries());\n            }\n\n            mLegend.setEntries(computedEntries);\n        }\n\n        Typeface tf = mLegend.getTypeface();\n\n        if (tf != null)\n            mLegendLabelPaint.setTypeface(tf);\n\n        mLegendLabelPaint.setTextSize(mLegend.getTextSize());\n        mLegendLabelPaint.setColor(mLegend.getTextColor());\n\n        // calculate all dimensions of the mLegend\n        mLegend.calculateDimensions(mLegendLabelPaint, mViewPortHandler);\n    }\n",
        "TranslatedCode": "/**\n   * Prepares the legend and calculates all needed forms, labels and colors.\n   *\n   * @param data\n   */\n  public computeLegend(data ?: ChartData<IDataSet<EntryOhos>>): void {\n\n    if (this.mLegend && !this.mLegend.isLegendCustom() && data) {\n\n      this.computedEntries.clear();\n\n      // loop for building up the colors and labels used in the legend\n      for (let i: number = 0; i < data.getDataSetCount(); i++) {\n\n        let dataSet: IDataSet<EntryOhos> | null = data.getDataSetByIndex(i);\n        if (dataSet == null) continue;\n\n        let clrs: JArrayList<Number> | null = dataSet.getColors();\n        let entryCount: number = dataSet.getEntryCount();\n\n        // if we have a barchart with stacked bars\n        if (dataSet.constructor.name == \"BarDataSet\" && (dataSet as IBarDataSet).isStacked()) {\n\n          let bds: IBarDataSet = dataSet as IBarDataSet;\n          let sLabels: string[] = bds.getStackLabels();\n\n          let minEntries: number = Math.min(clrs.size(), bds.getStackSize());\n\n          for (let j: number = 0; j < minEntries; j++) {\n            let label: string | null = null;\n            if (sLabels.length > 0) {\n              let labelIndex: number = j % minEntries;\n              label = labelIndex < sLabels.length ? sLabels[labelIndex] : null;\n            } else {\n              label = null;\n            }\n\n            const dashEffect = dataSet.getFormLineDashEffect(); // 使用空对象作为默认值\n            this.computedEntries.add(new LegendEntry(\n              label,\n              dataSet.getForm(),\n              dataSet.getFormSize(),\n              dataSet.getFormLineWidth(), dashEffect,\n              clrs.get(j).valueOf()\n            ));\n          }\n\n          let label = bds.getLabel();\n          if (label != null && label != \"\") {\n            // add the legend description label\n            const dashEffect = dataSet.getFormLineDashEffect();\n            this.computedEntries.add(new LegendEntry(\n              dataSet.getLabel(),\n              LegendForm.NONE,\n              Number.NaN,\n              Number.NaN,\n              dashEffect,\n              ColorTemplate.COLOR_NONE\n            ));\n          }\n\n        } else if (dataSet.constructor.name == 'PieDataSet') {\n          let pds = dataSet as IPieDataSet;\n          for (let j = 0; j < clrs.size() && j < entryCount; j++) {\n            this.computedEntries.add(new LegendEntry(\n              pds.getEntryForIndex(j).getLabel(),\n              dataSet.getForm(),\n              dataSet.getFormSize(),\n              dataSet.getFormLineWidth(),\n              dataSet.getFormLineDashEffect(),\n              clrs.get(j).valueOf()\n            ));\n          }\n          let label = pds.getLabel();\n          if (label != null && label != \"\") {\n            this.computedEntries.add(new LegendEntry(\n              dataSet.getLabel(),\n              LegendForm.NONE,\n              Number.NaN,\n              Number.NaN,\n              null,\n              ColorTemplate.COLOR_NONE\n            ));\n          }\n        } else if (dataSet.constructor.name == 'CandleDataSet' && (dataSet as ICandleDataSet).getDecreasingColor() != ColorTemplate.COLOR_NONE) {\n          let decreasingColor: number = (dataSet as ICandleDataSet).getDecreasingColor();\n          let increasingColor: number = (dataSet as ICandleDataSet).getIncreasingColor();\n\n          this.computedEntries.add(new LegendEntry(\n            undefined,\n            dataSet.getForm(),\n            dataSet.getFormSize(),\n            dataSet.getFormLineWidth(),\n            dataSet.getFormLineDashEffect(),\n            decreasingColor\n          ))\n\n          this.computedEntries.add(new LegendEntry(\n            dataSet.getLabel(),\n            dataSet.getForm(),\n            dataSet.getFormSize(),\n            dataSet.getFormLineWidth(),\n            dataSet.getFormLineDashEffect(),\n            increasingColor\n          ))\n        }\n        else { // all others\n\n          for (let j: number = 0; j < clrs.size() && j < entryCount; j++) {\n\n            let label: string | undefined = undefined;\n\n            // if multiple colors are set for a DataSet, group them\n            if (j < clrs.size() - 1 && j < entryCount - 1) {\n              label = undefined;\n            } else { // add label to the last entry\n              if (!data) {\n                label = undefined;\n              }\n              let dataObj = data.getDataSetByIndex(i);\n              if (!dataObj) {\n                label = undefined;\n              } else {\n                label = dataObj.getLabel();\n              }\n            }\n            let clrsData: number = 0;\n            if (!clrs) {\n              clrsData = 0;\n            }\n            clrsData = clrs.get(j) as number;\n            const dashEffect = dataSet.getFormLineDashEffect(); // 使用空对象作为默认值\n            this.computedEntries.add(new LegendEntry(\n                label ? label : '',\n              dataSet.getForm(),\n              dataSet.getFormSize(),\n              dataSet.getFormLineWidth(),\n              dashEffect,\n                clrsData ? clrsData : 0\n            ));\n          }\n        }\n      }\n\n      if (this.mLegend && this.mLegend.getExtraEntries() != null) {\n        let dataSource: LegendEntry[] | null = this.mLegend.getExtraEntries();\n        if (dataSource) {\n          for (let i: number = 0; i < dataSource.length; i++) {\n            this.computedEntries.add(dataSource[i]);\n          }\n        }\n      }\n\n      if (this.mLegend) {\n        this.mLegend.setEntries(this.computedEntries);\n        let tf: FontFamily /*Typeface*/\n          = this.mLegend.getTypeface();\n\n        if (this.mLegendLabelPaint) {\n          if (tf != null) {\n            this.mLegendLabelPaint.setFontFamily(tf);\n          }\n          this.mLegendLabelPaint.setTextSize(this.mLegend.getTextSize());\n          this.mLegendLabelPaint.setColor(this.mLegend.getTextColor());\n        }\n\n        // calculate all dimensions of the mLegend\n        this.mLegend.calculateDimensions(this.mLegendLabelPaint !, this.mViewPortHandler !);\n      }\n    }\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 检测两个弹幕是否会碰撞\n     * 允许不同类型弹幕的碰撞\n     * @param d1\n     * @param d2\n     * @return\n     */\n    public static boolean willHitInDuration(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2,\n            long duration, long currTime) {\n        final int type1 = d1.getType();\n        final int type2 = d2.getType();\n        // allow hit if different type\n        if(type1 != type2)\n            return false;\n\n        if(d1.isOutside()){\n            return false;\n        }\n        long dTime = d2.getActualTime() - d1.getActualTime();\n        if (dTime <= 0)\n            return true;\n        if (Math.abs(dTime) >= duration || d1.isTimeOut() || d2.isTimeOut()) {\n            return false;\n        }\n\n        if (type1 == BaseDanmaku.TYPE_FIX_TOP || type1 == BaseDanmaku.TYPE_FIX_BOTTOM) {\n            return true;\n        }\n\n        return checkHitAtTime(disp, d1, d2, currTime)\n                || checkHitAtTime(disp, d1, d2,  d1.getActualTime() + d1.getDuration());\n    }",
        "TranslatedCode": "/**\n     * 检测两个弹幕是否会碰撞\n     * 允许不同类型弹幕的碰撞\n     * @param d1\n     * @param d2\n     * @return\n     */\n  public static willHitInDuration(disp: IDisplayer, d1: BaseDanmaku, d2: BaseDanmaku,\n                                  duration: number, currTime: number): boolean {\n    let type1: number = d1.getType();\n    let type2: number = d2.getType();\n    // allow hit if different type\n    if (type1 != type2)\n    return false;\n\n    if (d1.isOutside()) {\n      return false;\n    }\n    let dTime: number = d2.getActualTime() - d1.getActualTime();\n    if (dTime <= 0)\n    return true;\n    if (Math.abs(dTime) >= duration || d1.isTimeOut() || d2.isTimeOut()) {\n      return false;\n    }\n\n    if (type1 == BaseDanmaku.TYPE_FIX_TOP || type1 == BaseDanmaku.TYPE_FIX_BOTTOM) {\n      return true;\n    }\n\n    return DanmakuUtils.checkHitAtTime(disp, d1, d2, currTime)\n    || DanmakuUtils.checkHitAtTime(disp, d1, d2, d1.getActualTime() + d1.getDuration());\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private static boolean checkHitAtTime(IDisplayer disp, BaseDanmaku d1, BaseDanmaku d2, long time){\n        final float[] rectArr1 = d1.getRectAtTime(disp, time);\n        final float[] rectArr2 = d2.getRectAtTime(disp, time);\n        if (rectArr1 == null || rectArr2 == null)\n            return false;\n        return checkHit(d1.getType(), d2.getType(), rectArr1, rectArr2);\n    }",
        "TranslatedCode": "private static checkHitAtTime(disp: IDisplayer, d1: BaseDanmaku, d2: BaseDanmaku, time: number): boolean{\n    let rectArr1: number[] = d1.getRectAtTime(disp, time);\n    let rectArr2: number[] = d2.getRectAtTime(disp, time);\n    if (rectArr1 == null || rectArr2 == null)\n    return false;\n    return DanmakuUtils.checkHit(d1.getType(), d2.getType(), rectArr1, rectArr2);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private static boolean checkHit(int type1, int type2, float[] rectArr1,\n            float[] rectArr2) {\n        if(type1 != type2)\n            return false;\n        if (type1 == BaseDanmaku.TYPE_SCROLL_RL) {\n            // hit if left2 < right1\n            return rectArr2[0] < rectArr1[2];\n        }\n\n        if (type1 == BaseDanmaku.TYPE_SCROLL_LR){\n            // hit if right2 > left1\n            return rectArr2[2] > rectArr1[0];\n        }\n\n        return false;\n    }",
        "TranslatedCode": "private static checkHit(type1: number, type2: number, rectArr1: number[],\n                          rectArr2: number[]): boolean {\n    if (type1 != type2)\n    return false;\n    if (type1 == BaseDanmaku.TYPE_SCROLL_RL) {\n      // hit if left2 < right1\n      return rectArr2[0] < rectArr1[2];\n    }\n\n    if (type1 == BaseDanmaku.TYPE_SCROLL_LR) {\n      // hit if right2 > left1\n      return rectArr2[2] > rectArr1[0];\n    }\n\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public final static boolean isDuplicate(BaseDanmaku obj1, BaseDanmaku obj2) {\n        if(obj1 == obj2) {\n            return false;\n        }\n\n        if (obj1.text == obj2.text) {\n            return true;\n        }\n\n        return false;\n    }",
        "TranslatedCode": "public static isDuplicate(obj1: BaseDanmaku, obj2: BaseDanmaku): boolean {\n    if (obj1 == obj2) {\n      return false;\n    }\n\n    if (obj1.text == obj2.text) {\n      return true;\n    }\n\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public final static int compare(BaseDanmaku obj1, BaseDanmaku obj2) {\n\n        if (obj1 == obj2) {\n            return 0;\n        }\n\n        if (obj1 == null) {\n            return -1;\n        }\n\n        if (obj2 == null) {\n            return 1;\n        }\n\n        long val = obj1.getTime() - obj2.getTime();\n        if (val > 0) {\n            return 1;\n        } else if (val < 0) {\n            return -1;\n        }\n        int r = obj1.index - obj2.index;\n        if (r != 0)\n            return r < 0 ? -1 : 1;\n\n        r = obj1.hashCode() - obj1.hashCode();\n        return r;\n    }",
        "TranslatedCode": "public static compare(obj1: BaseDanmaku, obj2: BaseDanmaku): number {\n\n    if (obj1 == obj2) {\n      return 0;\n    }\n\n    if (obj1 == null) {\n      return -1;\n    }\n\n    if (obj2 == null) {\n      return 1;\n    }\n\n    let val: number = obj1.getTime() - obj2.getTime();\n    if (val > 0) {\n      return 1;\n    } else if (val < 0) {\n      return -1;\n    }\n    let r: number = obj1.index - obj2.index;\n    if (r != 0) {\n      return r < 0 ? -1 : 1;\n    }\n    r = obj1.hashCode() - obj1.hashCode();\n    return r;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public static void fillText(BaseDanmaku danmaku, CharSequence text) {\n        danmaku.text = text;\n        if (TextUtils.isEmpty(text) || !text.toString().contains(BaseDanmaku.DANMAKU_BR_CHAR)) {\n            return;\n        }\n\n        String[] lines = String.valueOf(danmaku.text).split(BaseDanmaku.DANMAKU_BR_CHAR, -1);\n        if (lines.length > 1) {\n            danmaku.lines = lines;\n        }\n    }",
        "TranslatedCode": "public static fillText(danmaku: BaseDanmaku, text: string): void {\n    danmaku.text = text;\n    if (text == null || text.length == 0 || !text.toString().includes(BaseDanmaku.DANMAKU_BR_CHAR)) {\n      return;\n    }\n\n    let lines: string[] = danmaku.text.valueOf().split(BaseDanmaku.DANMAKU_BR_CHAR, -1);\n    if (lines.length > 1) {\n      danmaku.lines = lines;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public static final long uptimeMillis() {\n        return android.os.SystemClock.elapsedRealtime();\n    }",
        "TranslatedCode": "public static uptimeMillis(): number {\n    return new Date().getTime();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int accept(BaseDanmaku drawItem) {\n            lastItem = drawItem;\n            if (drawItem.isTimeOut()) {\n                disp.recycle(drawItem);\n                return renderingState.isRunningDanmakus ? ACTION_REMOVE : ACTION_CONTINUE;\n            }\n\n            if (!renderingState.isRunningDanmakus && drawItem.isOffset()) {\n                return ACTION_CONTINUE;\n            }\n\n            if (!drawItem.hasPassedFilter()) {\n                mContext.mDanmakuFilters.filter(drawItem, renderingState.indexInScreen, renderingState.totalSizeInScreen, renderingState.timer, false, mContext);\n            }\n            if (drawItem.getActualTime() < startRenderTime\n                    || (drawItem.priority == 0 && drawItem.isFiltered())) {\n                return ACTION_CONTINUE;\n            }\n\n            if (drawItem.isLate()) {\n                IDrawingCache<?> cache = drawItem.getDrawingCache();\n                if (mCacheManager != null && (cache == null || cache.get() == null)) {\n                    mCacheManager.addDanmaku(drawItem);\n                }\n                return ACTION_BREAK;\n            }\n\n            if (drawItem.getType() == BaseDanmaku.TYPE_SCROLL_RL) {\n                // 同屏弹幕密度只对滚动弹幕有效\n                renderingState.indexInScreen++;\n            }\n\n            // measure\n            if (!drawItem.isMeasured()) {\n                drawItem.measure(disp, false);\n            }\n\n            // notify prepare drawing\n            if (!drawItem.isPrepared()) {\n                drawItem.prepare(disp, false);\n            }\n\n            // layout\n            mDanmakusRetainer.fix(drawItem, disp, mVerifier);\n\n            // draw\n            if (drawItem.isShown()) {\n                if (drawItem.lines == null && drawItem.getBottom() > disp.getHeight()) {\n                    return ACTION_CONTINUE;    // skip bottom outside danmaku\n                }\n                int renderingType = drawItem.draw(disp);\n                if (renderingType == IRenderer.CACHE_RENDERING) {\n                    renderingState.cacheHitCount++;\n                } else if (renderingType == IRenderer.TEXT_RENDERING) {\n                    renderingState.cacheMissCount++;\n                    if (mCacheManager != null) {\n                        mCacheManager.addDanmaku(drawItem);\n                    }\n                }\n                renderingState.addCount(drawItem.getType(), 1);\n                renderingState.addTotalCount(1);\n                renderingState.appendToRunningDanmakus(drawItem);\n\n                if (mOnDanmakuShownListener != null\n                        && drawItem.firstShownFlag != mContext.mGlobalFlagValues.FIRST_SHOWN_RESET_FLAG) {\n                    drawItem.firstShownFlag = mContext.mGlobalFlagValues.FIRST_SHOWN_RESET_FLAG;\n                    mOnDanmakuShownListener.onDanmakuShown(drawItem);\n                }\n            }\n            return ACTION_CONTINUE;\n        }",
        "TranslatedCode": "public accept(drawItem: BaseDanmaku): number {\n    this.lastItem = drawItem;\n    if (drawItem.isTimeOut()) {\n      this.disp.recycle(drawItem);\n      if(this.renderingState!=null){\n        return this.renderingState.isRunningDanmakus ? Consumer.ACTION_REMOVE : Consumer.ACTION_CONTINUE;\n      }\n    }\n    if(this.renderingState!=null){\n      if (!this.renderingState.isRunningDanmakus && drawItem.isOffset()) {\n        return Consumer.ACTION_CONTINUE;\n      }\n    }\n    if(this.renderingState!=null){\n      if (!drawItem.hasPassedFilter()) { //还没执行过过滤逻辑\n        self.mContext.mDanmakuFilters.filter(drawItem, this.renderingState.indexInScreen, this.renderingState.totalSizeInScreen, this.renderingState.timer, false, self.mContext);\n      }\n    }\n    if (drawItem.getActualTime() < this.startRenderTime\n    || (drawItem.priority == 0 && drawItem.isFiltered())) { // isFiltered 就表示已经被过滤掉了 0表示低优先级 大于0不会被过滤\n      return Consumer.ACTION_CONTINUE;\n    }\n\n    if (drawItem.isLate()) {\n      return Consumer.ACTION_BREAK;\n    }\n\n    if (drawItem.getType() == BaseDanmaku.TYPE_SCROLL_RL) {\n      // 同屏弹幕密度只对滚动弹幕有效\n      if(this.renderingState!=null){\n        this.renderingState.indexInScreen++;\n      }\n    }\n\n    // measure\n    if (!drawItem.isMeasured()) {\n      drawItem.measure(this.disp, false);\n    }\n\n    // notify prepare drawing\n    if (!drawItem.isPrepared()) {\n      drawItem.prepare(this.disp, false);\n    }\n\n    // layout\n    self.mDanmakusRetainer.fix(drawItem, this.disp, self.mVerifier);\n\n    // draw\n    if (drawItem.isShown()) {\n      if (drawItem.lines == null && drawItem.getBottom() > this.disp.getHeight()) {\n        return Consumer.ACTION_CONTINUE; // skip bottom outside danmaku\n      }\n      let renderingType: number = drawItem.draw(this.disp);\n      if(this.renderingState!=null){\n        if (renderingType == CACHE_RENDERING) {\n          this.renderingState.cacheHitCount++;\n        } else if (renderingType == TEXT_RENDERING) {\n          this.renderingState.cacheMissCount++;\n        }\n        this.renderingState.addCount(drawItem.getType(), 1);\n        this.renderingState.addTotalCount(1);\n        this.renderingState.appendToRunningDanmakus(drawItem);\n      }\n\n      if (self.mOnDanmakuShownListener != null\n      && drawItem.firstShownFlag != self.mContext.mGlobalFlagValues.FIRST_SHOWN_RESET_FLAG) {\n        drawItem.firstShownFlag = self.mContext.mGlobalFlagValues.FIRST_SHOWN_RESET_FLAG;\n        self.mOnDanmakuShownListener.onDanmakuShown(drawItem);\n      }\n    }\n    return Consumer.ACTION_CONTINUE;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void after() {\n            renderingState.lastDanmaku = lastItem;\n            super.after();\n        }",
        "TranslatedCode": "public after(): void {\n    if(this.renderingState!=null){\n      this.renderingState.lastDanmaku = this.lastItem;\n      super.after();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void clear() {\n        clearRetainer();\n        mContext.mDanmakuFilters.clear();\n    }",
        "TranslatedCode": "public clear(): void {\n    this.clearRetainer();\n    this.mContext.mDanmakuFilters.clear();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void release() {\n        mDanmakusRetainer.release();\n        mContext.mDanmakuFilters.clear();\n    }",
        "TranslatedCode": "public release(): void {\n\n    this.mDanmakusRetainer.release();\n\n    this.mContext.mDanmakuFilters.clear();\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void draw(final IDisplayer disp, IDanmakus danmakus, long startRenderTime, final RenderingState renderingState) {\n        mStartTimer = renderingState.timer;\n        mConsumer.disp = disp;\n        mConsumer.renderingState = renderingState;\n        mConsumer.startRenderTime = startRenderTime;\n        danmakus.forEachSync(mConsumer);\n    }",
        "TranslatedCode": "public draw(disp: IDisplayer, danmakus: IDanmakus, startRenderTime: number, renderingState: RenderingState): void {\n    this.mStartTimer = renderingState.timer;\n    this.mConsumer.disp = disp;\n    this.mConsumer.renderingState = renderingState;\n    this.mConsumer.startRenderTime = startRenderTime;\n    danmakus.forEachSync(this.mConsumer);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void alignBottom(boolean enable) {\n        if (mDanmakusRetainer != null) {\n            mDanmakusRetainer.alignBottom(enable);\n        }\n    }",
        "TranslatedCode": "public alignBottom(enable: boolean): void {\n\n    if (this.mDanmakusRetainer != null) {\n\n      this.mDanmakusRetainer.alignBottom(enable);\n\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void alignBottom(boolean alignBottom) {\n        rldrInstance = alignBottom ? new AlignBottomRetainer() : new AlignTopRetainer();\n        lrdrInstance = alignBottom ? new AlignBottomRetainer() : new AlignTopRetainer();\n        if (ftdrInstance == null) {\n            ftdrInstance = new FTDanmakusRetainer();\n        }\n        if (fbdrInstance == null) {\n            fbdrInstance = new AlignBottomRetainer();\n        }\n    }",
        "TranslatedCode": "public alignBottom(alignBottom: boolean): void {\n    this.rldrInstance = alignBottom ? new AlignBottomRetainer() : new AlignTopRetainer(); //r2l, 使用AlignBottom或AlignTop\n    this.lrdrInstance = alignBottom ? new AlignBottomRetainer() : new AlignTopRetainer(); //l2r, 使用AlignBottom或AlignTop\n    if (this.ftdrInstance == null) {\n      this.ftdrInstance = new FTDanmakusRetainer(); //fix top\n    }\n    if (this.fbdrInstance == null) {\n      this.fbdrInstance = new AlignBottomRetainer(); //fix bottom 使用 AlignBottomRetainer逻辑\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void fix(BaseDanmaku danmaku, IDisplayer disp, Verifier verifier) {\n\n        int type = danmaku.getType();\n        switch (type) {\n            case BaseDanmaku.TYPE_SCROLL_RL:\n                rldrInstance.fix(danmaku, disp, verifier);\n                break;\n            case BaseDanmaku.TYPE_SCROLL_LR:\n                lrdrInstance.fix(danmaku, disp, verifier);\n                break;\n            case BaseDanmaku.TYPE_FIX_TOP:\n                ftdrInstance.fix(danmaku, disp, verifier);\n                break;\n            case BaseDanmaku.TYPE_FIX_BOTTOM:\n                fbdrInstance.fix(danmaku, disp, verifier);\n                break;\n            case BaseDanmaku.TYPE_SPECIAL:\n                danmaku.layout(disp, 0, 0);\n                break;\n        }\n\n    }",
        "TranslatedCode": "public fix(danmaku: BaseDanmaku, disp: IDisplayer, verifier: Verifier): void {\n\n    let danmakuType = danmaku.getType();\n    switch (danmakuType) {\n      case BaseDanmaku.TYPE_SCROLL_RL:\n        this.rldrInstance.fix(danmaku, disp, verifier);\n        break;\n      case BaseDanmaku.TYPE_SCROLL_LR:\n        this.lrdrInstance.fix(danmaku, disp, verifier);\n        break;\n      case BaseDanmaku.TYPE_FIX_TOP:\n        this.ftdrInstance.fix(danmaku, disp, verifier);\n        break;\n      case BaseDanmaku.TYPE_FIX_BOTTOM:\n        this.fbdrInstance.fix(danmaku, disp, verifier);\n        break;\n      case BaseDanmaku.TYPE_SPECIAL:\n        danmaku.layout(disp, 0, 0);\n        break;\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void clear() {\n        if (rldrInstance != null) {\n            rldrInstance.clear();\n        }\n        if (lrdrInstance != null) {\n            lrdrInstance.clear();\n        }\n        if (ftdrInstance != null) {\n            ftdrInstance.clear();\n        }\n        if (fbdrInstance != null) {\n            fbdrInstance.clear();\n        }\n    }",
        "TranslatedCode": "public clear(): void {\n    if (this.rldrInstance != null) {\n      this.rldrInstance.clear();\n    }\n    if (this.lrdrInstance != null) {\n      this.lrdrInstance.clear();\n    }\n    if (this.ftdrInstance != null) {\n      this.ftdrInstance.clear();\n    }\n    if (this.fbdrInstance != null) {\n      this.fbdrInstance.clear();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int accept(BaseDanmaku item) {\n                if (mCancelFixingFlag) {\n                    return ACTION_BREAK;\n                }\n                lines++;\n                if(item == drawItem){\n                    insertItem = item;\n                    lastItem = null;\n                    shown = true;\n                    willHit = false;\n                    return ACTION_BREAK;\n                }\n\n                if (firstItem == null)\n                    firstItem = item;\n\n                if (drawItem.paintHeight + item.getTop() > disp.getHeight()) {\n                    overwriteInsert = true;\n                    return ACTION_BREAK;\n                }\n\n                if (minRightRow == null) {\n                    minRightRow = item;\n                } else {\n                    if (minRightRow.getRight() >= item.getRight()) {\n                        minRightRow = item;\n                    }\n                }\n\n                // 检查碰撞\n                willHit = DanmakuUtils.willHitInDuration(disp, item, drawItem,\n                        drawItem.getDuration(), drawItem.getTimer().currMillisecond);\n                if (!willHit) {\n                    insertItem = item;\n                    return ACTION_BREAK;\n                }\n\n                lastItem = item;\n                return ACTION_CONTINUE;\n            }",
        "TranslatedCode": "public accept(item: BaseDanmaku): number {\n    if (this.outer.mCancelFixingFlag) {\n      return Consumer.ACTION_BREAK;\n    }\n    this.lines++;\n    if (item == this.drawItem) {\n      this.insertItem = item;\n      this.lastItem = null;\n      this.shown = true;\n      this.willHit = false;\n      return Consumer.ACTION_BREAK;\n    }\n\n    if (this.firstItem == null)\n    this.firstItem = item;\n\n    if (this.drawItem.paintHeight + item.getTop() > this.disp.getHeight()) {\n      this.overwriteInsert = true;\n      return Consumer.ACTION_BREAK;\n    }\n\n    if (this.minRightRow == null) {\n      this.minRightRow = item;\n    } else {\n      if (this.minRightRow.getRight() >= item.getRight()) {\n        this.minRightRow = item;\n      }\n    }\n\n    // 检查碰撞\n    this.willHit = DanmakuUtils.willHitInDuration(this.disp, item, this.drawItem,\n    this.drawItem.getDuration(), this.drawItem.getTimer().currMillisecond);\n    if (!this.willHit) {\n      this.insertItem = item;\n      return Consumer.ACTION_BREAK;\n    }\n\n    this.lastItem = item;\n    return Consumer.ACTION_CONTINUE;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void fix(BaseDanmaku drawItem, IDisplayer disp, Verifier verifier) {\n            if (drawItem.isOutside())\n                return;\n            float topPos = disp.getAllMarginTop();\n            int lines = 0;\n            boolean shown = drawItem.isShown();\n            boolean willHit = !shown && !mVisibleDanmakus.isEmpty();\n            boolean isOutOfVertialEdge = false;\n            BaseDanmaku removeItem = null;\n            int margin = disp.getMargin();\n            if (!shown) {\n                mCancelFixingFlag = false;\n                // 确定弹幕位置\n                BaseDanmaku insertItem = null, firstItem = null, lastItem = null, minRightRow = null;\n                boolean overwriteInsert = false;\n                mConsumer.disp = disp;\n                mConsumer.drawItem = drawItem;\n                mVisibleDanmakus.forEachSync(mConsumer);\n                RetainerState retainerState = mConsumer.result();\n                if (retainerState != null) {\n                    lines = retainerState.lines;\n                    insertItem = retainerState.insertItem;\n                    firstItem = retainerState.firstItem;\n                    lastItem = retainerState.lastItem;\n                    minRightRow = retainerState.minRightRow;\n                    overwriteInsert = retainerState.overwriteInsert;\n                    shown = retainerState.shown;\n                    willHit = retainerState.willHit;\n                }\n                boolean checkEdge = true;\n                if (insertItem != null) {\n                    if (lastItem != null)\n                        topPos = lastItem.getBottom() + margin;\n                    else\n                        topPos = insertItem.getTop();\n                    if (insertItem != drawItem){\n                        removeItem = insertItem;\n                        shown = false;\n                    }\n                } else if (overwriteInsert && minRightRow != null) {\n                    topPos = minRightRow.getTop();\n                    checkEdge = false;\n                    shown = false;\n                } else if (lastItem != null) {\n                    topPos = lastItem.getBottom() + margin;\n                    willHit = false;\n                } else if (firstItem != null) {\n                    topPos = firstItem.getTop();\n                    removeItem = firstItem;\n                    shown = false;\n                } else {\n                    topPos = disp.getAllMarginTop();\n                }\n                if (checkEdge) {\n                    isOutOfVertialEdge = isOutVerticalEdge(overwriteInsert, drawItem, disp, topPos, firstItem,\n                            lastItem);\n                }\n                if (isOutOfVertialEdge) {\n                    topPos = disp.getAllMarginTop();\n                    willHit = true;\n                    lines = 1;\n                } else if (removeItem != null) {\n                    lines--;\n                }\n                if (topPos == disp.getAllMarginTop()) {\n                    shown = false;\n                }\n            }\n\n            if (verifier != null && verifier.skipLayout(drawItem, topPos, lines, willHit)) {\n                return;\n            }\n\n            if (isOutOfVertialEdge) {\n                clear();\n            }\n\n            drawItem.layout(disp, drawItem.getLeft(), topPos);\n\n            if (!shown) {\n                mVisibleDanmakus.removeItem(removeItem);\n                mVisibleDanmakus.addItem(drawItem);\n            }\n\n        }",
        "TranslatedCode": "public fix(drawItem: BaseDanmaku, disp: IDisplayer, verifier: Verifier): void{\n    if (drawItem.isOutside())\n    return;\n    let topPos: number = disp.getAllMarginTop();\n    let lines: number = 0;\n    let shown: boolean = drawItem.isShown();\n    let willHit: boolean = !shown && !this.mVisibleDanmakus.isEmpty();\n    let isOutOfVertialEdge: boolean = false;\n    let removeItem: BaseDanmaku|ESObject = null;\n    let margin: number = disp.getMargin();\n    if (!shown) {\n      this.mCancelFixingFlag = false;\n      // 确定弹幕位置\n      let insertItem: BaseDanmaku|ESObject = null\n      let firstItem: BaseDanmaku|ESObject = null\n      let lastItem: BaseDanmaku|ESObject = null\n      let minRightRow: BaseDanmaku|ESObject = null;\n      let overwriteInsert: boolean = false;\n      this.mConsumerTop.disp = disp;\n      this.mConsumerTop.drawItem = drawItem;\n      this.mVisibleDanmakus.forEachSync(this.mConsumerTop);\n      let retainerState: RetainerState = this.mConsumerTop.result();\n      if (retainerState != null) {\n        lines = retainerState.lines;\n        insertItem = retainerState.insertItem;\n        firstItem = retainerState.firstItem;\n        lastItem = retainerState.lastItem;\n        minRightRow = retainerState.minRightRow;\n        overwriteInsert = retainerState.overwriteInsert;\n        shown = retainerState.shown;\n        willHit = retainerState.willHit;\n      }\n      let checkEdge: boolean = true;\n      if (insertItem != null) {\n        if (lastItem != null)\n        topPos = lastItem.getBottom() + margin;\n        else\n        topPos = insertItem.getTop();\n        if (insertItem != drawItem) {\n          removeItem = insertItem;\n          shown = false;\n        }\n      } else if (overwriteInsert && minRightRow != null) {\n        topPos = minRightRow.getTop();\n        checkEdge = false;\n        shown = false;\n      } else if (lastItem != null) {\n        topPos = lastItem.getBottom() + margin;\n        willHit = false;\n      } else if (firstItem != null) {\n        topPos = firstItem.getTop();\n        removeItem = firstItem;\n        shown = false;\n      } else {\n        topPos = disp.getAllMarginTop();\n      }\n      if (checkEdge) {\n        isOutOfVertialEdge = this.isOutVerticalEdge(overwriteInsert, drawItem, disp, topPos, firstItem,\n          lastItem);\n      }\n      if (isOutOfVertialEdge) {\n        topPos = disp.getAllMarginTop();\n        willHit = true;\n        lines = 1;\n      } else if (removeItem != null) {\n        lines--;\n      }\n      if (topPos == disp.getAllMarginTop()) {\n        shown = false;\n      }\n    }\n\n    if (verifier != null && verifier.skipLayout(drawItem, topPos, lines, willHit)) {\n      return;\n    }\n\n    if (isOutOfVertialEdge) {\n      this.clear();\n    }\n\n    drawItem.layout(disp, drawItem.getLeft(), topPos);\n\n    if (!shown) {\n      this.mVisibleDanmakus.removeItem(removeItem);\n      this.mVisibleDanmakus.addItem(drawItem);\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected boolean isOutVerticalEdge(boolean overwriteInsert, BaseDanmaku drawItem,\n                                            IDisplayer disp, float topPos, BaseDanmaku firstItem, BaseDanmaku lastItem) {\n            if (topPos < disp.getAllMarginTop() || (firstItem != null && firstItem.getTop() > 0) || topPos + drawItem.paintHeight > disp.getHeight()) {\n                return true;\n            }\n            return false;\n        }",
        "TranslatedCode": "protected isOutVerticalEdge(overwriteInsert: boolean, drawItem: BaseDanmaku,\n                              disp: IDisplayer, topPos: number, firstItem: BaseDanmaku, lastItem: BaseDanmaku): boolean {\n    if (topPos < disp.getAllMarginTop() || (firstItem != null && firstItem.getTop() > 0) || topPos + drawItem.paintHeight > disp.getHeight()) {\n      return true;\n    }\n    return false;\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void clear() {\n            mCancelFixingFlag = true;\n            mVisibleDanmakus.clear();\n        }",
        "TranslatedCode": "public clear(): void {\n    this.mCancelFixingFlag = true;\n    this.mVisibleDanmakus.clear();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected boolean isOutVerticalEdge(boolean overwriteInsert, BaseDanmaku drawItem,\n                                            IDisplayer disp, float topPos, BaseDanmaku firstItem, BaseDanmaku lastItem) {\n            if (topPos + drawItem.paintHeight > disp.getHeight()) {\n                return true;\n            }\n            return false;\n        }",
        "TranslatedCode": "protected isOutVerticalEdge(overwriteInsert: boolean, drawItem: BaseDanmaku,\n                              disp: IDisplayer, topPos: number, firstItem: BaseDanmaku, lastItem: BaseDanmaku): boolean {\n    if (topPos + drawItem.paintHeight > disp.getHeight()) {\n      return true;\n    }\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int accept(BaseDanmaku item) {\n                if (mCancelFixingFlag) {\n                    return ACTION_BREAK;\n                }\n                lines++;\n                if (item == drawItem) {\n                    removeItem = null;\n                    willHit = false;\n                    return ACTION_BREAK;\n                }\n\n                if (firstItem == null) {\n                    firstItem = item;\n                    if (firstItem.getBottom() != disp.getHeight()) {\n                        return ACTION_BREAK;\n                    }\n                }\n\n                if (topPos < disp.getAllMarginTop()) {\n                    removeItem = null;\n                    return ACTION_BREAK;\n                }\n\n                // 检查碰撞\n                willHit = DanmakuUtils.willHitInDuration(disp, item, drawItem,\n                        drawItem.getDuration(), drawItem.getTimer().currMillisecond);\n                if (!willHit) {\n                    removeItem = item;\n                    // topPos = item.getBottom() - drawItem.paintHeight;\n                    return ACTION_BREAK;\n                }\n\n                topPos = item.getTop() - disp.getMargin() - drawItem.paintHeight;\n                return ACTION_CONTINUE;\n            }",
        "TranslatedCode": "public accept(item: BaseDanmaku): number {\n    if (this.outer.mCancelFixingFlag) {\n      return Consumer.ACTION_BREAK;\n    }\n    this.lines++;\n    if (item == this.drawItem) {\n      this.removeItem = null;\n      this.willHit = false;\n      return Consumer.ACTION_BREAK;\n    }\n\n    if (this.firstItem == null) {\n      this.firstItem = item;\n      if (this.firstItem.getBottom() != this.disp.getHeight()) {\n        return Consumer.ACTION_BREAK;\n      }\n    }\n\n    if (this.topPos < this.disp.getAllMarginTop()) {\n      this.removeItem = null;\n      return Consumer.ACTION_BREAK;\n    }\n\n    // 检查碰撞\n    this.willHit = DanmakuUtils.willHitInDuration(this.disp, item, this.drawItem,\n    this.drawItem.getDuration(), this.drawItem.getTimer().currMillisecond);\n    if (!this.willHit) {\n      this.removeItem = item;\n      // topPos = item.getBottom() - drawItem.paintHeight;\n      return Consumer.ACTION_BREAK;\n    }\n\n    this.topPos = item.getTop() - this.disp.getMargin() - this.drawItem.paintHeight;\n    return Consumer.ACTION_CONTINUE;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void before() {\n                lines = 0;\n                removeItem = firstItem = null;\n                willHit = false;\n            }",
        "TranslatedCode": "public before(): void {\n    this.lines = 0;\n    this.removeItem = this.firstItem = null;\n    this.willHit = false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void fix(BaseDanmaku drawItem, IDisplayer disp, Verifier verifier) {\n            if (drawItem.isOutside())\n                return;\n            boolean shown = drawItem.isShown();\n            float topPos = shown ? drawItem.getTop() : -1;\n            int lines = 0;\n            boolean willHit = !shown && !mVisibleDanmakus.isEmpty();\n            boolean isOutOfVerticalEdge = false;\n            if (topPos < disp.getAllMarginTop()) {\n                topPos = disp.getHeight() - drawItem.paintHeight;\n            }\n            BaseDanmaku removeItem = null, firstItem = null;\n            if (!shown) {\n                mCancelFixingFlag = false;\n                mConsumer.topPos = topPos;\n                mConsumer.disp = disp;\n                mConsumer.drawItem = drawItem;\n                mVisibleDanmakus.forEachSync(mConsumer);\n                RetainerState retainerState = mConsumer.result();\n                topPos = mConsumer.topPos;\n                if (retainerState != null) {\n                    lines = retainerState.lines;\n                    firstItem = retainerState.firstItem;\n                    removeItem = retainerState.removeItem;\n                    shown = retainerState.shown;\n                    willHit = retainerState.willHit;\n                }\n\n                isOutOfVerticalEdge = isOutVerticalEdge(false, drawItem, disp, topPos, firstItem, null);\n                if (isOutOfVerticalEdge) {\n                    topPos = disp.getHeight() - drawItem.paintHeight;\n                    willHit = true;\n                    lines = 1;\n                } else {\n                    if (topPos >= disp.getAllMarginTop()) {\n                        willHit = false;\n                    }\n                    if (removeItem != null) {\n                        lines--;\n                    }\n                }\n\n            }\n\n            if (verifier != null && verifier.skipLayout(drawItem, topPos, lines, willHit)) {\n                return;\n            }\n\n            if (isOutOfVerticalEdge) {\n                clear();\n            }\n\n            drawItem.layout(disp, drawItem.getLeft(), topPos);\n\n            if (!shown) {\n                mVisibleDanmakus.removeItem(removeItem);\n                mVisibleDanmakus.addItem(drawItem);\n            }\n\n        }",
        "TranslatedCode": "public fix(drawItem: BaseDanmaku, disp: IDisplayer, verifier: Verifier): void {\n    if (drawItem.isOutside())\n    return;\n    let shown: boolean = drawItem.isShown();\n    let topPos: number = shown ? drawItem.getTop() : -1;\n    let lines: number = 0;\n    let willHit: boolean = !shown && !this.mVisibleDanmakus.isEmpty();\n    let isOutOfVerticalEdge: boolean = false;\n    if (topPos < disp.getAllMarginTop()) {\n      topPos = disp.getHeight() - drawItem.paintHeight;\n    }\n    let removeItem: BaseDanmaku |ESObject= null\n    let firstItem: BaseDanmaku |ESObject= null;\n    if (!shown) {\n      this.mCancelFixingFlag = false;\n      this.mConsumerBottom.topPos = topPos;\n      this.mConsumerBottom.disp = disp;\n      this.mConsumerBottom.drawItem = drawItem;\n      this.mVisibleDanmakus.forEachSync(this.mConsumerBottom);\n      let retainerState: RetainerState = this.mConsumerBottom.result();\n      topPos = this.mConsumerBottom.topPos;\n      if (retainerState != null) {\n        lines = retainerState.lines;\n        firstItem = retainerState.firstItem;\n        removeItem = retainerState.removeItem;\n        shown = retainerState.shown;\n        willHit = retainerState.willHit;\n      }\n\n      isOutOfVerticalEdge = this.isOutVerticalEdge(false, drawItem, disp, topPos, firstItem, null);\n      if (isOutOfVerticalEdge) {\n        topPos = disp.getHeight() - drawItem.paintHeight;\n        willHit = true;\n        lines = 1;\n      } else {\n        if (topPos >= disp.getAllMarginTop()) {\n          willHit = false;\n        }\n        if (removeItem != null) {\n          lines--;\n        }\n      }\n\n    }\n\n    if (verifier != null && verifier.skipLayout(drawItem, topPos, lines, willHit)) {\n      return;\n    }\n\n    if (isOutOfVerticalEdge) {\n      this.clear();\n    }\n\n    drawItem.layout(disp, drawItem.getLeft(), topPos);\n\n    if (!shown) {\n      this.mVisibleDanmakus.removeItem(removeItem);\n      this.mVisibleDanmakus.addItem(drawItem);\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected boolean isOutVerticalEdge(boolean overwriteInsert, BaseDanmaku drawItem,\n                                            IDisplayer disp, float topPos, BaseDanmaku firstItem, BaseDanmaku lastItem) {\n            if (topPos < disp.getAllMarginTop() || (firstItem != null && firstItem.getBottom() != disp.getHeight())) {\n                return true;\n            }\n            return false;\n        }",
        "TranslatedCode": "protected isOutVerticalEdge(overwriteInsert: boolean, drawItem: BaseDanmaku,\n                              disp: IDisplayer, topPos: number, firstItem: BaseDanmaku, lastItem: BaseDanmaku|null): boolean {\n    if (topPos < disp.getAllMarginTop() || (firstItem != null && firstItem.getBottom() != disp.getHeight())) {\n      return true;\n    }\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void clear() {\n            mCancelFixingFlag = true;\n            mVisibleDanmakus.clear();\n        }",
        "TranslatedCode": "public clear(): void {\n    this.mCancelFixingFlag = true;\n    this.mVisibleDanmakus.clear();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BaseDanmakuParser setDisplayer(IDisplayer disp){\n        mDisp = disp;\n    \tmDispWidth = disp.getWidth();\n        mDispHeight = disp.getHeight();\n        mDispDensity = disp.getDensity();\n        mScaledDensity = disp.getScaledDensity();\n        mContext.mDanmakuFactory.updateViewportState(mDispWidth, mDispHeight, getViewportSizeFactor());\n        mContext.mDanmakuFactory.updateMaxDanmakuDuration();\n        return this;\n    }",
        "TranslatedCode": "public setDisplayer(disp: IDisplayer): BaseDanmakuParser {\n    this.mDisp = disp;\n    this.mDispWidth = disp.getWidth();\n    this.mDispHeight = disp.getHeight();\n    this.mDispDensity = disp.getDensity();\n    this.mScaledDensity = disp.getScaledDensity();\n    this.mContext.mDanmakuFactory.updateViewportState(this.mDispWidth, this.mDispHeight, this.getViewportSizeFactor());\n    this.mContext.mDanmakuFactory.updateMaxDanmakuDuration();\n    return this;\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public IDisplayer getDisplayer(){\n        return mDisp;\n    }",
        "TranslatedCode": "public getDisplayer(): IDisplayer {\n    return this.mDisp;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BaseDanmakuParser setListener(Listener listener) {\n        mListener = listener;\n        return this;\n    }",
        "TranslatedCode": "public setListener(listener: Listener|ESObject): BaseDanmakuParser {\n    this.mListener = listener;\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * decide the speed of scroll-danmakus\n     * @return\n     */\n    protected float getViewportSizeFactor() {\n        return 1 / (mDispDensity - 0.6f);\n    }",
        "TranslatedCode": "/**\n   * decide the speed of scroll-danmakus\n   * @return\n   */\n  protected getViewportSizeFactor(): number {\n    return 1 / (this.mDispDensity * 0.8);\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BaseDanmakuParser load(IDataSource<?> source) {\n        mDataSource = source;\n        return this;\n    }",
        "TranslatedCode": "public load(source: IDataSource<ESObject>): BaseDanmakuParser {\n    this.mDataSource = source;\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BaseDanmakuParser setTimer(DanmakuTimer timer) {\n        mTimer = timer;\n        return this;\n    }",
        "TranslatedCode": "public setTimer(timer: DanmakuTimer): BaseDanmakuParser {\n    this.mTimer = timer;\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DanmakuTimer getTimer() {\n        return mTimer;\n    }",
        "TranslatedCode": "public getTimer(): DanmakuTimer {\n    return this.mTimer;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public IDanmakus getDanmakus() {\n        if (mDanmakus != null)\n            return mDanmakus;\n        mContext.mDanmakuFactory.resetDurationsData();\n        mDanmakus = parse();\n        releaseDataSource();\n        mContext.mDanmakuFactory.updateMaxDanmakuDuration();\n        return mDanmakus;\n    }",
        "TranslatedCode": "public getDanmakus(): IDanmakus {\n    if (this.mDanmakus != null) {\n      return this.mDanmakus;\n    }\n    this.mContext.mDanmakuFactory.resetDurationsData();\n    this.mDanmakus = this.parse();\n    this.releaseDataSource();\n    this.mContext.mDanmakuFactory.updateMaxDanmakuDuration();\n    return this.mDanmakus;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void releaseDataSource() {\n        if(mDataSource!=null)\n            mDataSource.release();\n        mDataSource = null;\n    }",
        "TranslatedCode": "protected releaseDataSource(): void {\n    if (this.mDataSource != null) {\n      this.mDataSource.release();\n    }\n    this.mDataSource = null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BaseDanmakuParser setConfig(DanmakuContext config) {\n        mContext = config;\n        return this;\n    }",
        "TranslatedCode": "public setConfig(config: DanmakuContext): BaseDanmakuParser {\n    this.mContext = config;\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void init(InputStream in) throws JSONException {\n\t\tif(in == null)\n\t\t\tthrow new NullPointerException(\"input stream cannot be null!\");\n\t\tmInput = in;\n\t\tString json = IOUtils.getString(mInput);\n\t\tinit(json);\n\t}\n\tprivate void init(String json) throws JSONException {\n\t\tif(!TextUtils.isEmpty(json)){\n\t\t\tmJSONArray = new JSONArray(json);\n\t\t}\n\t}",
        "TranslatedCode": "private init(json: string | fileio.Stream) {\n    if (typeof json === 'string') {\n      if (json != null || json != undefined || (json as ESObject).length != 0) {\n        this.mJSONArray = JSON.parse(json)\n      }\n    } else {\n      if (json != null) {\n        let that = this\n        this.mInput = json\n        this.mInput.read(new ArrayBuffer(this.MAX_BUFFER_SIZE),).then((readOut:ESObject)=> {\n          let dataString:ESObject = String.fromCharCode(...new Uint8Array(readOut.buffer))\n          that.mJSONArray = dataString != null ? JSON.parse(dataString) : []\n        })\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void release() {\n\t\tIOUtils.closeQuietly(mInput);\n\t\tmInput = null;\n\t\tmJSONArray = null;\n\t}",
        "TranslatedCode": "public release() {\n    if (this.mInput != null) {\n      this.mInput.close()\n    }\n    this.mInput = null;\n    this.mJSONArray = null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void fillStreamFromUri(Uri uri) {\n        String scheme = uri.getScheme();\n        if (SCHEME_HTTP_TAG.equalsIgnoreCase(scheme) || SCHEME_HTTPS_TAG.equalsIgnoreCase(scheme)) {\n            fillStreamFromHttpFile(uri);\n        } else if (SCHEME_FILE_TAG.equalsIgnoreCase(scheme)) {\n            fillStreamFromFile(new File(uri.getPath()));\n        }\n    }\n\n    public void fillStreamFromHttpFile(Uri uri) {\n        try {\n            URL url = new URL(uri.getPath());\n            url.openConnection();\n            inStream = new BufferedInputStream(url.openStream());\n\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }",
        "TranslatedCode": "public fillStreamFromUri(filePath: uri.URI) {\n    let ctx = getContext(this);\n    if (filePath.scheme.toLocaleLowerCase() == SCHEME_HTTP_TAG || filePath.scheme.toLocaleLowerCase() == SCHEME_HTTPS_TAG) {\n      let downloadTask:ESObject;\n      let that = this\n      request.downloadFile(ctx, { url: filePath.toString(),\n        filePath: this.DOWNLOAD_FILE_PATH }, (err, data) => {\n        if (err) {\n          console.error('Failed to request the download. Cause: ' + JSON.stringify(err));\n          return;\n        }\n        downloadTask = data;\n        downloadTask.on('complete', ()=> {\n          fileio.createStream(this.DOWNLOAD_FILE_PATH, \"r+\", (err, stream)=> {\n            if (err) {\n              console.error('Failed to createStream. Cause: ' + JSON.stringify(err));\n              return\n            }\n            that.inStream = stream\n          });\n        }\n        );\n      });\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void release() {\n        IOUtils.closeQuietly(inStream);\n        inStream = null;\n    }",
        "TranslatedCode": "public release() {\n    if (this.inStream != null) {\n      this.inStream.closeSync()\n    }\n\n    this.inStream = null\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public long getDuration() {\n        return duration.value;\n    }",
        "TranslatedCode": " public getDuration(): number {\n    return this.duration.value;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": " public boolean isMeasured() {\n        return paintWidth > -1 && paintHeight > -1\n                && measureResetFlag == flags.MEASURE_RESET_FLAG;\n    }",
        "TranslatedCode": "public isMeasured(): boolean {\n    return this.paintWidth > -1 && this.paintHeight > -1\n    && this.measureResetFlag == this.flags.MEASURE_RESET_FLAG;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void measure(IDisplayer displayer, boolean fromWorkerThread) {\n        displayer.measure(this, fromWorkerThread);\n        this.measureResetFlag = flags.MEASURE_RESET_FLAG;\n    }",
        "TranslatedCode": "public measure(displayer: IDisplayer, fromWorkerThread: boolean) {\n    displayer.measure(this, fromWorkerThread);\n    this.measureResetFlag = this.flags.MEASURE_RESET_FLAG;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isTimeOut() {\n        return mTimer == null || isTimeOut(mTimer.currMillisecond);\n    }\npublic boolean isTimeOut(long ctime) {\n        return ctime - getActualTime() >= duration.value;\n    }\n",
        "TranslatedCode": "public isTimeOut(ctime?: number): boolean {\n    if (ctime === undefined) {\n      return this.mTimer == null || this.isTimeOut(this.mTimer.currMillisecond);\n    } else {\n      return ctime - this.getActualTime() >= this.duration.value;\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isOutside() {\n        return mTimer == null || isOutside(mTimer.currMillisecond);\n    }\n\n    public boolean isOutside(long ctime) {\n        long dtime = ctime - getActualTime();\n        return dtime <= 0 || dtime >= duration.value;\n    }",
        "TranslatedCode": "public isOutside(ctime?: number): boolean {\n    if (ctime === undefined) {\n      return this.mTimer == null || this.isOutside(this.mTimer.currMillisecond);\n    } else {\n      let dtime: number = ctime - this.getActualTime();\n      return dtime <= 0 || dtime >= this.duration.value;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean hasPassedFilter() {\n        if (filterResetFlag != flags.FILTER_RESET_FLAG) {\n            mFilterParam = 0;\n            return false;\n        }\n        return true;\n    }",
        "TranslatedCode": "public hasPassedFilter(): boolean {\n    if (this.filterResetFlag != this.flags.FILTER_RESET_FLAG) {\n      this.mFilterParam = 0;\n      return false;\n    }\n    return true;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setVisibility(boolean b) {\n        if (b) {\n            this.visibleResetFlag = flags.VISIBLE_RESET_FLAG;\n            this.visibility = VISIBLE;\n        } else\n            this.visibility = INVISIBLE;\n    }",
        "TranslatedCode": "public setVisibility(b: boolean) {\n    if (b) {\n      this.visibleResetFlag = this.flags.VISIBLE_RESET_FLAG;\n      this.visibility = BaseDanmaku.VISIBLE;\n    } else\n    this.visibility = BaseDanmaku.INVISIBLE;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public long getActualTime() {\n        if (flags == null || flags.SYNC_TIME_OFFSET_RESET_FLAG != this.syncTimeOffsetResetFlag) {\n            this.timeOffset = 0;\n            return time;\n        }\n        return time + timeOffset;\n    }",
        "TranslatedCode": "public getActualTime(): number {\n    if (this.flags == null || this.flags.SYNC_TIME_OFFSET_RESET_FLAG != this.syncTimeOffsetResetFlag) {\n      this.timeOffset = 0;\n      return this.time;\n    }\n    return this.time + this.timeOffset;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isOffset() {\n        if (flags == null || flags.SYNC_TIME_OFFSET_RESET_FLAG != this.syncTimeOffsetResetFlag) {\n            this.timeOffset = 0;\n            return false;\n        }\n        return timeOffset != 0;\n    }",
        "TranslatedCode": "public isOffset(): boolean {\n    if (this.flags == null || this.flags.SYNC_TIME_OFFSET_RESET_FLAG != this.syncTimeOffsetResetFlag) {\n      this.timeOffset = 0;\n      return false;\n    }\n    return this.timeOffset != 0;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public long update(long curr) {\n        lastInterval = curr - currMillisecond;\n        currMillisecond = curr;\n        return lastInterval;\n    }",
        "TranslatedCode": "public update(curr: number): number {\n    this.lastInterval = curr - this.currMillisecond;\n    this.currMillisecond = curr;\n    return this.lastInterval;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public long add(long mills) {\n        return update(currMillisecond + mills);\n    }",
        "TranslatedCode": "public add(mills: number): number {\n    return this.update(this.currMillisecond + mills);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public long lastInterval() {\n        return lastInterval;\n    }",
        "TranslatedCode": "public getLastInterval(): number {\n    return this.lastInterval;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setValue(long initialDuration) {\n        mInitialDuration = initialDuration;\n        value = (long) (mInitialDuration * factor);\n    }",
        "TranslatedCode": "public setValue(initialDuration: number) {\n    this.mInitialDuration = initialDuration;\n    this.value = (this.mInitialDuration * this.factor);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setFactor(float f) {\n        if (factor != f) {\n            factor = f;\n            value = (long) (mInitialDuration * f);\n        }\n    }",
        "TranslatedCode": "public setFactor(f: number) {\n    if (this.factor != f) {\n      this.factor = f;\n      this.value = (this.mInitialDuration * f);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void layout(IDisplayer displayer, float x, float y) {\n        if (mTimer != null) {\n            long deltaDuration = mTimer.currMillisecond - getActualTime();\n            if (deltaDuration > 0 && deltaDuration < duration.value) {\n                if (!this.isShown()) {\n                    this.x = getLeft(displayer);\n                    this.y = y;\n                    this.setVisibility(true);\n                }\n                return;\n            }\n\n            this.setVisibility(false);\n            this.y = -1;\n            this.x = displayer.getWidth();\n        }\n\n    }",
        "TranslatedCode": "public layout(displayer: IDisplayer, x: number, y: number) {\n    if (this.mTimer != null) {\n      let deltaDuration: number = this.mTimer.currMillisecond - this.getActualTime();\n      if (deltaDuration > 0 && deltaDuration < this.duration.value) {\n        if (!this.isShown()) {\n          this.x = this.getLeftWithDisplayer(displayer);\n          this.y = y;\n          this.setVisibility(true);\n        }\n        return;\n      }\n\n      this.setVisibility(false);\n      this.y = -1;\n      this.x = displayer.getWidth();\n    }\n\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected float getLeft(IDisplayer displayer) {\n        if (mLastDispWidth == displayer.getWidth() && mLastPaintWidth == paintWidth) {\n            return mLastLeft;\n        }\n        float left = (displayer.getWidth() - paintWidth) / 2;\n        mLastDispWidth = displayer.getWidth();\n        mLastPaintWidth = paintWidth;\n        mLastLeft = left;\n        return left;\n    }",
        "TranslatedCode": "public getLeftWithDisplayer(displayer: IDisplayer): number {\n    if (this.mLastDispWidth == displayer.getWidth() && this.mLastPaintWidth == this.paintWidth) {\n      return this.mLastLeft;\n    }\n    let left: number = (displayer.getWidth() - this.paintWidth) / 2;\n    this.mLastDispWidth = displayer.getWidth();\n    this.mLastPaintWidth = this.paintWidth;\n    this.mLastLeft = left;\n    return left;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float[] getRectAtTime(IDisplayer displayer, long time) {\n        if (!isMeasured())\n            return null;\n        float left = getLeft(displayer);\n        if (RECT == null) {\n            RECT = new float[4];\n        }\n        RECT[0] = left;\n        RECT[1] = y;\n        RECT[2] = left + paintWidth;\n        RECT[3] = y + paintHeight;\n        return RECT;\n    }",
        "TranslatedCode": "public getRectAtTime(displayer: IDisplayer, time: number): number[]|ESObject {\n    if (!this.isMeasured())\n    return null;\n    let left: number = this.getLeftWithDisplayer(displayer);\n    if (this.RECT == null) {\n      this.RECT = new Array<number>(4);\n    }\n    this.RECT[0] = left;\n    this.RECT[1] = this.y;\n    this.RECT[2] = left + this.paintWidth;\n    this.RECT[3] = this.y + this.paintHeight;\n    return this.RECT;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getLeft() {\n        return x;\n    }",
        "TranslatedCode": "public getLeft(): number {\n    return this.x;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getRight() {\n        return x + paintWidth;\n    }",
        "TranslatedCode": "public getRight(): number {\n\n    return this.x + this.paintWidth;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int compare(BaseDanmaku obj1, BaseDanmaku obj2) {\n            if (mDuplicateMergingEnable && DanmakuUtils.isDuplicate(obj1, obj2)) {\n                return 0;\n            }\n            return DanmakuUtils.compare(obj1, obj2);\n        }",
        "TranslatedCode": "public compare(obj1: BaseDanmaku, obj2: BaseDanmaku): number {\n    if (this.mDuplicateMergingEnable && DanmakuUtils.isDuplicate(obj1, obj2)) {\n      return 0;\n    }\n    return DanmakuUtils.compare(obj1, obj2);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int compare(BaseDanmaku obj1, BaseDanmaku obj2) {\n            if (mDuplicateMergingEnable && DanmakuUtils.isDuplicate(obj1, obj2)) {\n                return 0;\n            }\n            return Float.compare(obj1.getTop(), obj2.getTop());\n        }",
        "TranslatedCode": "public compare(obj1: BaseDanmaku, obj2: BaseDanmaku): number {\n    if (this.mDuplicateMergingEnable && DanmakuUtils.isDuplicate(obj1, obj2)) {\n      return 0;\n    }\n    return Math.sign(obj1.getTop() - obj2.getTop());\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int compare(BaseDanmaku obj1, BaseDanmaku obj2) {\n            if (mDuplicateMergingEnable && DanmakuUtils.isDuplicate(obj1, obj2)) {\n                return 0;\n            }\n            return Float.compare(obj2.getTop(), obj1.getTop());\n        }",
        "TranslatedCode": "public compare(obj1: BaseDanmaku, obj2: BaseDanmaku): number {\n    if (this.mDuplicateMergingEnable && DanmakuUtils.isDuplicate(obj1, obj2)) {\n      return 0;\n    }\n    return Math.sign(obj2.getTop() - obj1.getTop());\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getDistance(Point p) {\n            float _x = Math.abs(this.x - p.x);\n            float _y = Math.abs(this.y - p.y);\n            return (float) Math.sqrt(_x * _x + _y * _y);\n        }",
        "TranslatedCode": "public getDistance(p: Point): number {\n    let _x: number = Math.abs(this.x - p.x);\n    let _y: number = Math.abs(this.y - p.y);\n    return Math.sqrt(_x * _x + _y * _y);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setPoints(Point pBegin, Point pEnd) {\n            this.pBegin = pBegin;\n            this.pEnd = pEnd;\n            this.delatX = pEnd.x - pBegin.x;\n            this.deltaY = pEnd.y - pBegin.y;\n        }",
        "TranslatedCode": "public setPoints(pBegin: Point, pEnd: Point) {\n    this.pBegin = pBegin;\n    this.pEnd = pEnd;\n    this.delatX = pEnd.x - pBegin.x;\n    this.deltaY = pEnd.y - pBegin.y;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float[] getBeginPoint() {\n            return new float[]{\n                    pBegin.x, pBegin.y\n            };\n        }",
        "TranslatedCode": "public getBeginPoint(): number[] {\n    return [this.pBegin.x, this.pBegin.y];\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void measure(IDisplayer displayer, boolean fromWorkerThread) {\n        super.measure(displayer, fromWorkerThread);\n        if (mCurrentWidth == 0 || mCurrentHeight == 0) {\n            mCurrentWidth = displayer.getWidth();\n            mCurrentHeight = displayer.getHeight();\n        }\n    }",
        "TranslatedCode": "public measure(displayer: IDisplayer, fromWorkerThread: boolean) {\n    super.measure(displayer, fromWorkerThread);\n    if (this.mCurrentWidth == 0 || this.mCurrentHeight == 0) {\n      this.mCurrentWidth = displayer.getWidth();\n      this.mCurrentHeight = displayer.getHeight();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float[] getRectAtTime(IDisplayer displayer, long currTime) {\n\n        if (!isMeasured())\n            return null;\n\n        if (mScaleFactor.isUpdated(this.mScaleFactorChangedFlag, mCurrentWidth, mCurrentHeight)) {\n            float scaleX = mScaleFactor.scaleX;\n            float scaleY = mScaleFactor.scaleY;\n            setTranslationData(beginX * scaleX, beginY * scaleY, endX * scaleX, endY * scaleY, translationDuration, translationStartDelay);\n            if (linePaths != null && linePaths.length > 0) {\n                int length = linePaths.length;\n                float[][] points = new float[length + 1][2];\n                for (int j = 0; j < length; j++) {\n                    points[j] = linePaths[j].getBeginPoint();\n                    points[j + 1] = linePaths[j].getEndPoint();\n                }\n                for (int i = 0; i < points.length; i++) {\n                    points[i][0] *= scaleX;\n                    points[i][1] *= scaleY;\n                }\n                setLinePathData(points);\n            }\n            this.mScaleFactorChangedFlag = mScaleFactor.flag;\n            this.mCurrentWidth = mScaleFactor.width;\n            this.mCurrentHeight = mScaleFactor.height;\n        }\n\n        long deltaTime = currTime - getActualTime();\n\n        // caculate alpha\n        if (alphaDuration > 0 && deltaAlpha != 0) {\n            if (deltaTime >= alphaDuration) {\n                alpha = endAlpha;\n            } else {\n                float alphaProgress = deltaTime / (float) alphaDuration;\n                int vectorAlpha = (int) (deltaAlpha * alphaProgress);\n                alpha = beginAlpha + vectorAlpha;\n            }\n        }\n\n        // caculate x y\n        float currX = beginX;\n        float currY = beginY;\n        long dtime = deltaTime - translationStartDelay;\n        if (translationDuration > 0 && dtime >= 0 && dtime <= translationDuration) {\n            float tranalationProgress = 0f;\n            if (linePaths != null) {\n                LinePath currentLinePath = null;\n                for (LinePath line : linePaths) {\n                    if (dtime >= line.beginTime && dtime < line.endTime) {\n                        currentLinePath = line;\n                        break;\n                    } else {\n                        currX = line.pEnd.x;\n                        currY = line.pEnd.y;\n                    }\n                }\n                if (currentLinePath != null) {\n                    float deltaX = currentLinePath.delatX;\n                    float deltaY = currentLinePath.deltaY;\n                    tranalationProgress = (deltaTime - currentLinePath.beginTime) / (float) currentLinePath.duration;\n                    float beginX = currentLinePath.pBegin.x;\n                    float beginY = currentLinePath.pBegin.y;\n                    if (deltaX != 0) {\n                        float vectorX = deltaX * tranalationProgress;\n                        currX = beginX + vectorX;\n                    }\n                    if (deltaY != 0) {\n                        float vectorY = deltaY * tranalationProgress;\n                        currY = beginY + vectorY;\n                    }\n                }\n            } else {\n                tranalationProgress = isQuadraticEaseOut ? getQuadEaseOutProgress(dtime, translationDuration) : dtime / (float) translationDuration;\n                if (deltaX != 0) {\n                    float vectorX = deltaX * tranalationProgress;\n                    currX = beginX + vectorX;\n                }\n                if (deltaY != 0) {\n                    float vectorY = deltaY * tranalationProgress;\n                    currY = beginY + vectorY;\n                }\n            }\n        } else if (dtime > translationDuration) {\n            currX = endX;\n            currY = endY;\n        }\n\n        currStateValues[0] = currX;\n        currStateValues[1] = currY;\n        currStateValues[2] = currX + paintWidth;\n        currStateValues[3] = currY + paintHeight;\n\n        this.setVisibility(!isOutside());\n\n        return currStateValues;\n    }",
        "TranslatedCode": "public getRectAtTime(displayer: IDisplayer, currTime: number): number[]|ESObject {\n\n    if (!this.isMeasured()) {\n      return null;\n    }\n    if (this.mScaleFactor.isUpdated(this.mScaleFactorChangedFlag, this.mCurrentWidth, this.mCurrentHeight)) {\n      let scaleX: number = this.mScaleFactor.scaleX;\n      let scaleY: number = this.mScaleFactor.scaleY;\n      this.setTranslationData(this.beginX * scaleX, this.beginY * scaleY, this.endX * scaleX, this.endY * scaleY, this.translationDuration, this.translationStartDelay);\n      if (this.linePaths != null && this.linePaths.length > 0) {\n        let length: number = this.linePaths.length;\n        let points: number[][] = new Array<number[]>(length + 1).fill(new Array<number>(2).fill(0));\n        for (let j: number = 0; j < length; j++) {\n          points[j] = this.linePaths[j].getBeginPoint();\n          points[j + 1] = this.linePaths[j].getEndPoint();\n        }\n        for (let i: number = 0; i < points.length; i++) {\n          points[i][0] *= scaleX;\n          points[i][1] *= scaleY;\n        }\n        this.setLinePathData(points);\n      }\n      this.mScaleFactorChangedFlag = this.mScaleFactor.flag;\n      this.mCurrentWidth = this.mScaleFactor.width;\n      this.mCurrentHeight = this.mScaleFactor.height;\n    }\n\n    let deltaTime: number = currTime - this.getActualTime();\n\n    // calculate alpha\n    if (this.alphaDuration > 0 && this.deltaAlpha != 0) {\n      if (deltaTime >= this.alphaDuration) {\n        this.alpha = this.endAlpha;\n      } else {\n        let alphaProgress: number = deltaTime / this.alphaDuration;\n        let vectorAlpha: number = Math.floor(this.deltaAlpha * alphaProgress);\n        this.alpha = this.beginAlpha + vectorAlpha;\n      }\n    }\n    // calculate x y\n    let currX: number = this.beginX;\n    let currY: number = this.beginY;\n    let dtime: number = deltaTime - this.translationStartDelay;\n    if (this.translationDuration > 0 && dtime >= 0 && dtime <= this.translationDuration) {\n      let tranalationProgress: number = 0;\n      if (this.linePaths != null) {\n        let currentLinePath: LinePath|ESObject = null;\n        this.linePaths.forEach((line:ESObject) => {\n          if (dtime >= line.beginTime && dtime < line.endTime) {\n            currentLinePath = line;\n          } else {\n            currX = line.pEnd.x;\n            currY = line.pEnd.y;\n          }\n        });\n        if (currentLinePath != null) {\n          let deltaX: number = currentLinePath.delatX;\n          let deltaY: number = currentLinePath.deltaY;\n          tranalationProgress = (deltaTime - currentLinePath.beginTime) / currentLinePath.duration;\n          let beginX: number = currentLinePath.pBegin.x;\n          let beginY: number = currentLinePath.pBegin.y;\n          if (deltaX != 0) {\n            let vectorX: number = deltaX * tranalationProgress;\n            currX = beginX + vectorX;\n          }\n          if (deltaY != 0) {\n            let vectorY: number = deltaY * tranalationProgress;\n            currY = beginY + vectorY;\n          }\n        }\n\n      } else {\n        tranalationProgress = this.isQuadraticEaseOut ? SpecialDanmaku.getQuadEaseOutProgress(dtime, this.translationDuration) : dtime / this.translationDuration;\n        if (this.deltaX != 0) {\n          let vectorX: number = this.deltaX * tranalationProgress;\n          currX = this.beginX + vectorX;\n        }\n        if (this.deltaY != 0) {\n          let vectorY: number = this.deltaY * tranalationProgress;\n          currY = this.beginY + vectorY;\n        }\n      }\n\n    } else if (dtime > this.translationDuration) {\n      currX = this.endX;\n      currY = this.endY;\n    }\n\n    this.currStateValues[0] = currX;\n    this.currStateValues[1] = currY;\n    this.currStateValues[2] = currX + this.paintWidth;\n    this.currStateValues[3] = currY + this.paintHeight;\n\n    this.setVisibility(!this.isOutside());\n    return this.currStateValues;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private final static float getQuadEaseOutProgress(long ctime, long duration) {\n        float t = ctime;\n        float c = 1.0f;\n        float d = duration;\n        return -c * (t /= d) * (t - 2); // + b;\n    }",
        "TranslatedCode": "private static getQuadEaseOutProgress(ctime: number, duration: number): number {\n    let t: number = ctime;\n    let c: number = 1.0;\n    let d: number = duration;\n    return -c * (t /= d) * (t - 2); // + b;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setLinePathData(float[][] points) {\n        if (points != null) {\n            int length = points.length;\n            this.beginX = points[0][0];\n            this.beginY = points[0][1];\n            this.endX = points[length - 1][0];\n            this.endY = points[length - 1][1];\n            if (points.length > 1) {\n                linePaths = new LinePath[points.length - 1];\n                for (int i = 0; i < linePaths.length; i++) {\n                    linePaths[i] = new LinePath();\n                    linePaths[i].setPoints(new Point(points[i][0], points[i][1]), new Point(\n                            points[i + 1][0], points[i + 1][1]));\n                }\n                float totalDistance = 0;\n                for (LinePath line : linePaths) {\n                    totalDistance += line.getDistance();\n                }\n                LinePath lastLine = null;\n                for (LinePath line : linePaths) {\n                    line.duration = (long) ((line.getDistance() / totalDistance) * translationDuration);\n                    line.beginTime = (lastLine == null ? 0 : lastLine.endTime);\n                    line.endTime = line.beginTime + line.duration;\n                    lastLine = line;\n                }\n\n            }\n        }\n    }",
        "TranslatedCode": "public setLinePathData(points: number[][]) {\n    if (points != null) {\n      let length: number = points.length;\n      let linePath:LinePath|ESObject;\n      this.beginX = points[0][0];\n      this.beginY = points[0][1];\n      this.endX = points[length - 1][0];\n      this.endY = points[length - 1][1];\n      if (points.length > 1) {\n        this.linePaths = linePath[points.length - 1];\n        for (let i = 0; i < this.linePaths.length; i++) {\n          this.linePaths[i] = new LinePath();\n          this.linePaths[i].setPoints(new Point(points[i][0], points[i][1]), new Point(\n            points[i + 1][0], points[i + 1][1]));\n        }\n        let totalDistance: number = 0;\n\n        this.linePaths.forEach((line:ESObject) => {\n          totalDistance += line.getDistance();\n        });\n        let lastLine: LinePath|ESObject = null;\n        this.linePaths.forEach((line:ESObject) => {\n          line.duration = Math.floor((line.getDistance() / totalDistance) * this.translationDuration);\n          line.beginTime = (lastLine == null ? 0 : lastLine.endTime);\n          line.endTime = line.beginTime + line.duration;\n          lastLine = line;\n        });\n\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setScaleFactor(ScaleFactor scaleFactor) {\n        this.mScaleFactor = scaleFactor;\n        this.mScaleFactorChangedFlag = scaleFactor.flag;\n    }",
        "TranslatedCode": "public setScaleFactor(scaleFactor: ScaleFactor) {\n    this.mScaleFactor = scaleFactor;\n    this.mScaleFactorChangedFlag = scaleFactor.flag;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DanmakuContext setTypeface(Typeface font) {\n        if (mFont != font) {\n            mFont = font;\n            mDisplayer.clearTextHeightCache();\n            mDisplayer.setTypeFace(font);\n            notifyConfigureChanged(DanmakuConfigTag.TYPEFACE);\n        }\n        return this;\n    }",
        "TranslatedCode": "public setTypeface(font: string): DanmakuContext {\n    if (this.mFont != font) {\n      this.mFont = font;\n      this.mDisplayer.clearTextHeightCache();\n      this.mDisplayer.setTypeFace(font);\n      this.notifyConfigureChanged(DanmakuConfigTag.TYPEFACE);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DanmakuContext setDanmakuTransparency(float p) {\n        int newTransparency = (int) (p * AlphaValue.MAX);\n        if (newTransparency != transparency) {\n            transparency = newTransparency;\n            mDisplayer.setTransparency(newTransparency);\n            notifyConfigureChanged(DanmakuConfigTag.TRANSPARENCY, p);\n        }\n        return this;\n    }",
        "TranslatedCode": "public setDanmakuTransparency(p: number): DanmakuContext {\n    let newTransparency: number = (p * AlphaValue.MAX);\n    if (newTransparency != this.transparency) {\n      this.transparency = newTransparency;\n      this.mDisplayer.setTransparency(newTransparency);\n      this.notifyConfigureChanged(DanmakuConfigTag.TRANSPARENCY, p);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DanmakuContext setScaleTextSize(float p) {\n        if (scaleTextSize != p) {\n            scaleTextSize = p;\n            mDisplayer.clearTextHeightCache();\n            mDisplayer.setScaleTextSizeFactor(p);\n            mGlobalFlagValues.updateMeasureFlag();\n            mGlobalFlagValues.updateVisibleFlag();\n            notifyConfigureChanged(DanmakuConfigTag.SCALE_TEXTSIZE, p);\n        }\n        return this;\n    }",
        "TranslatedCode": "public setScaleTextSize(p: number): DanmakuContext {\n    if (this.scaleTextSize != p) {\n      this.scaleTextSize = p;\n      this.mDisplayer.clearTextHeightCache();\n      this.mDisplayer.setScaleTextSizeFactor(p);\n      this.mGlobalFlagValues.updateMeasureFlag();\n      this.mGlobalFlagValues.updateVisibleFlag();\n      this.notifyConfigureChanged(DanmakuConfigTag.SCALE_TEXTSIZE, p);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DanmakuContext setDanmakuMargin(int m) {\n        if (margin != m) {\n            margin = m;\n            mDisplayer.setMargin(m);\n            mGlobalFlagValues.updateFilterFlag();\n            mGlobalFlagValues.updateVisibleFlag();\n            notifyConfigureChanged(DanmakuConfigTag.DANMAKU_MARGIN, m);\n        }\n        return this;\n    }",
        "TranslatedCode": "public setDanmakuMargin(m: number): DanmakuContext {\n    if (this.margin != m) {\n      this.margin = m;\n      this.mDisplayer.setMargin(m);\n      this.mGlobalFlagValues.updateFilterFlag();\n      this.mGlobalFlagValues.updateVisibleFlag();\n      this.notifyConfigureChanged(DanmakuConfigTag.DANMAKU_MARGIN, m);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private <T> void setFilterData(String tag, T data) {\n        setFilterData(tag, data, true);\n    }\nprivate <T> void setFilterData(String tag, T data, boolean primary) {\n        @SuppressWarnings(\"unchecked\")\n        IDanmakuFilter<T> filter = (IDanmakuFilter<T>) mDanmakuFilters.get(tag, primary);\n        filter.setData(data);\n    }",
        "TranslatedCode": "private setFilterData<T>(tag: string, data: T, primary?: boolean) {\n    if (primary === undefined) {\n      this.setFilterData(tag, data, true);\n    } else {\n      let filter: IDanmakuFilter<T> = this.mDanmakuFilters.get(tag, primary) as IDanmakuFilter<T> ;\n      filter.setData(data);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void setDanmakuVisible(boolean visible, int type) {\n        if (visible) {\n            mFilterTypes.remove(Integer.valueOf(type));\n        } else if (!mFilterTypes.contains(Integer.valueOf(type))) {\n            mFilterTypes.add(type);\n        }\n    }",
        "TranslatedCode": "private setDanmakuVisible(visible: boolean, filterType: number) {\n    let index: number = this.mFilterTypes.indexOf(filterType);\n    if (visible) {\n      if (index >= 0) {\n        this.mFilterTypes.splice(index, 1)\n      }\n    } else if (index < 0 && index == undefined) {\n      this.mFilterTypes.push(filterType);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置是否显示左右滚动弹幕\n     *\n     * @param visible\n     */\n    public DanmakuContext setL2RDanmakuVisibility(boolean visible) {\n        setDanmakuVisible(visible, BaseDanmaku.TYPE_SCROLL_LR);\n        setFilterData(DanmakuFilters.TAG_TYPE_DANMAKU_FILTER, mFilterTypes);\n        mGlobalFlagValues.updateFilterFlag();\n        if(L2RDanmakuVisibility != visible){\n            L2RDanmakuVisibility = visible;\n            notifyConfigureChanged(DanmakuConfigTag.L2R_DANMAKU_VISIBILITY, visible);\n        }\n        return this;\n    }",
        "TranslatedCode": "public setL2RDanmakuVisibility(visible: boolean): DanmakuContext {\n    this.setDanmakuVisible(visible, BaseDanmaku.TYPE_SCROLL_LR);\n    this.setFilterData(DanmakuFilters.TAG_TYPE_DANMAKU_FILTER, this.mFilterTypes);\n    this.mGlobalFlagValues.updateFilterFlag();\n    if (this.L2RDanmakuVisibility != visible) {\n      this.L2RDanmakuVisibility = visible;\n      this.notifyConfigureChanged(DanmakuConfigTag.L2R_DANMAKU_VISIBILITY, visible);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置同屏弹幕密度 -1自动 0无限制\n     *\n     * @param maxSize\n     * @return\n     */\n    public DanmakuContext setMaximumVisibleSizeInScreen(int maxSize) {\n        maximumNumsInScreen = maxSize;\n        // 无限制\n        if (maxSize == 0) {\n            mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_QUANTITY_DANMAKU_FILTER);\n            mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_ELAPSED_TIME_FILTER);\n            notifyConfigureChanged(DanmakuConfigTag.MAXIMUM_NUMS_IN_SCREEN, maxSize);\n            return this;\n        }\n        // 自动调整\n        if (maxSize == -1) {\n            mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_QUANTITY_DANMAKU_FILTER);\n            mDanmakuFilters.registerFilter(DanmakuFilters.TAG_ELAPSED_TIME_FILTER);\n            notifyConfigureChanged(DanmakuConfigTag.MAXIMUM_NUMS_IN_SCREEN, maxSize);\n            return this;\n        }\n        setFilterData(DanmakuFilters.TAG_QUANTITY_DANMAKU_FILTER, maxSize);\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.MAXIMUM_NUMS_IN_SCREEN, maxSize);\n        return this;\n    }",
        "TranslatedCode": "public setMaximumVisibleSizeInScreen(maxSize: number): DanmakuContext {\n    this.maximumNumsInScreen = maxSize;\n\n    if (maxSize == 0) {\n      this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_QUANTITY_DANMAKU_FILTER });\n      this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_ELAPSED_TIME_FILTER });\n      this.notifyConfigureChanged(DanmakuConfigTag.MAXIMUM_NUMS_IN_SCREEN, maxSize);\n      return this;\n    }\n\n    if (maxSize == -1) {\n      this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_QUANTITY_DANMAKU_FILTER });\n      this.mDanmakuFilters.registerFilter({ tag: DanmakuFilters.TAG_ELAPSED_TIME_FILTER });\n      this.notifyConfigureChanged(DanmakuConfigTag.MAXIMUM_NUMS_IN_SCREEN, maxSize);\n      return this;\n    }\n    this.setFilterData(DanmakuFilters.TAG_QUANTITY_DANMAKU_FILTER, maxSize);\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.MAXIMUM_NUMS_IN_SCREEN, maxSize);\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置色彩过滤弹幕白名单\n     * @param colors\n     * @return\n     */\n    public DanmakuContext setColorValueWhiteList(Integer... colors) {\n        mColorValueWhiteList.clear();\n        if (colors == null || colors.length == 0) {\n            mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_TEXT_COLOR_DANMAKU_FILTER);\n        } else {\n            Collections.addAll(mColorValueWhiteList, colors);\n            setFilterData(DanmakuFilters.TAG_TEXT_COLOR_DANMAKU_FILTER, mColorValueWhiteList);\n        }\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.COLOR_VALUE_WHITE_LIST, mColorValueWhiteList);\n        return this;\n    }",
        "TranslatedCode": "public setColorValueWhiteList(colors: number[]): DanmakuContext {\n    this.mColorValueWhiteList.splice(0, this.mColorValueWhiteList.length);\n    if (colors == null || colors.length == 0) {\n      this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_TEXT_COLOR_DANMAKU_FILTER });\n    } else {\n      this.mColorValueWhiteList.push(...colors);\n      this.setFilterData(DanmakuFilters.TAG_TEXT_COLOR_DANMAKU_FILTER, this.mColorValueWhiteList);\n    }\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.COLOR_VALUE_WHITE_LIST, this.mColorValueWhiteList);\n    return this;\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置屏蔽弹幕用户hash\n     * @param hashes\n     * @return\n     */\n    public DanmakuContext setUserHashBlackList(String... hashes) {\n        mUserHashBlackList.clear();\n        if (hashes == null || hashes.length == 0) {\n            mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_USER_HASH_FILTER);\n        } else {\n            Collections.addAll(mUserHashBlackList, hashes);\n            setFilterData(DanmakuFilters.TAG_USER_HASH_FILTER, mUserHashBlackList);\n        }\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.USER_HASH_BLACK_LIST, mUserHashBlackList);\n        return this;\n    }",
        "TranslatedCode": "public setUserHashBlackList(hashes: string[]): DanmakuContext {\n    this.mUserHashBlackList.splice(0, this.mUserHashBlackList.length)\n    if (hashes == null || hashes.length == 0) {\n      this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_USER_HASH_FILTER });\n    } else {\n      this.mUserHashBlackList.push(...hashes);\n      this.setFilterData(DanmakuFilters.TAG_USER_HASH_FILTER, this.mUserHashBlackList);\n    }\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.USER_HASH_BLACK_LIST, this.mUserHashBlackList);\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DanmakuContext removeUserHashBlackList(String... hashes){\n        if(hashes == null || hashes.length == 0) {\n            return this;\n        }\n        for (String hash : hashes) {\n            mUserHashBlackList.remove(hash);\n        }\n        setFilterData(DanmakuFilters.TAG_USER_HASH_FILTER, mUserHashBlackList);\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.USER_HASH_BLACK_LIST, mUserHashBlackList);\n        return this;\n    }",
        "TranslatedCode": "public removeUserHashBlackList(hashes: string[]): DanmakuContext{\n    if (hashes == null || hashes.length == 0) {\n      return this;\n    }\n    hashes.forEach((hash: string) => {\n      if (hash == null) {\n        let index: number = 0\n        for (index; index < this.mUserHashBlackList.length; index++)\n          if (this.mUserHashBlackList[index] == null) {\n            this.mUserHashBlackList.splice(index, 1);\n            return true;\n          }\n      } else {\n        let index: number = 0\n        for (index; index < this.mUserHashBlackList.length; index++)\n          if (this.mUserHashBlackList[index] == hash) {\n            this.mUserHashBlackList.splice(index, 1);\n            return true;\n          }\n      }\n      return false;\n    })\n    this.setFilterData(DanmakuFilters.TAG_USER_HASH_FILTER, this.mUserHashBlackList);\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.USER_HASH_BLACK_LIST, this.mUserHashBlackList);\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 添加屏蔽用户\n     * @param hashes\n     * @return\n     */\n    public DanmakuContext addUserHashBlackList(String... hashes){\n        if(hashes == null || hashes.length == 0) {\n            return this;\n        }\n        Collections.addAll(mUserHashBlackList, hashes);\n        setFilterData(DanmakuFilters.TAG_USER_HASH_FILTER, mUserHashBlackList);\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.USER_HASH_BLACK_LIST, mUserHashBlackList);\n        return this;\n    }",
        "TranslatedCode": "public addUserHashBlackList(hashes: string[]): DanmakuContext{\n    if (hashes == null || hashes.length == 0) {\n      return this;\n    }\n    this.mUserHashBlackList.push(...hashes);\n    this.setFilterData(DanmakuFilters.TAG_USER_HASH_FILTER, this.mUserHashBlackList);\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.USER_HASH_BLACK_LIST, this.mUserHashBlackList);\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置屏蔽弹幕用户id , 0 表示游客弹幕\n     * @param ids\n     * @return\n     */\n    public DanmakuContext setUserIdBlackList(Integer... ids) {\n        mUserIdBlackList.clear();\n        if (ids == null || ids.length == 0) {\n            mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_USER_ID_FILTER);\n        } else {\n            Collections.addAll(mUserIdBlackList, ids);\n            setFilterData(DanmakuFilters.TAG_USER_ID_FILTER, mUserIdBlackList);\n        }\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.USER_ID_BLACK_LIST, mUserIdBlackList);\n        return this;\n    }",
        "TranslatedCode": "public setUserIdBlackList(ids: number[]): DanmakuContext {\n\n    this.mUserIdBlackList.splice(0, this.mUserIdBlackList.length);\n\n    if (ids == null || ids.length == 0) {\n\n      this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_USER_ID_FILTER });\n\n    } else {\n\n      this.mUserIdBlackList.push(...ids)\n\n      this.setFilterData(DanmakuFilters.TAG_USER_ID_FILTER, this.mUserIdBlackList);\n\n    }\n\n    this.mGlobalFlagValues.updateFilterFlag();\n\n    this.notifyConfigureChanged(DanmakuConfigTag.USER_ID_BLACK_LIST, this.mUserIdBlackList);\n\n    return this;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public DanmakuContext removeUserIdBlackList(Integer... ids){\n        if(ids == null || ids.length == 0) {\n            return this;\n        }\n        for (Integer id : ids) {\n            mUserIdBlackList.remove(id);\n        }\n        setFilterData(DanmakuFilters.TAG_USER_ID_FILTER, mUserIdBlackList);\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.USER_ID_BLACK_LIST, mUserIdBlackList);\n        return this;\n    }",
        "TranslatedCode": "public removeUserIdBlackList(ids: number[]): DanmakuContext{\n    if (ids == null || ids.length == 0) {\n      return this;\n    }\n    ids.forEach((id: number) => {\n      let index: number = this.mUserIdBlackList.indexOf(id)\n      if (index >= 0) {\n        this.mUserIdBlackList.splice(index, 1);\n      }\n    })\n    this.setFilterData(DanmakuFilters.TAG_USER_ID_FILTER, this.mUserIdBlackList);\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.USER_ID_BLACK_LIST, this.mUserIdBlackList);\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 添加屏蔽用户\n     * @param ids\n     * @return\n     */\n    public DanmakuContext addUserIdBlackList(Integer... ids){\n        if(ids == null || ids.length == 0) {\n            return this;\n        }\n        Collections.addAll(mUserIdBlackList, ids);\n        setFilterData(DanmakuFilters.TAG_USER_ID_FILTER, mUserIdBlackList);\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.USER_ID_BLACK_LIST, mUserIdBlackList);\n        return this;\n    }",
        "TranslatedCode": "public addUserIdBlackList(ids: number[]): DanmakuContext{\n    if (ids == null || ids.length == 0) {\n      return this;\n    }\n    this.mUserIdBlackList.push(...ids)\n    this.setFilterData(DanmakuFilters.TAG_USER_ID_FILTER, this.mUserIdBlackList);\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.USER_ID_BLACK_LIST, this.mUserIdBlackList);\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置是否屏蔽游客弹幕\n     * @param block true屏蔽，false不屏蔽\n     * @return\n     */\n    public DanmakuContext blockGuestDanmaku(boolean block) {\n        if (mBlockGuestDanmaku != block) {\n            mBlockGuestDanmaku = block;\n            if (block) {\n                setFilterData(DanmakuFilters.TAG_GUEST_FILTER, block);\n            } else {\n                mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_GUEST_FILTER);\n            }\n            mGlobalFlagValues.updateFilterFlag();\n            notifyConfigureChanged(DanmakuConfigTag.BLOCK_GUEST_DANMAKU, block);\n        }\n        return this;\n    }",
        "TranslatedCode": "public blockGuestDanmaku(block: boolean): DanmakuContext {\n    if (this.mBlockGuestDanmaku != block) {\n      this.mBlockGuestDanmaku = block;\n      if (block) {\n        this.setFilterData(DanmakuFilters.TAG_GUEST_FILTER, block);\n      } else {\n        this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_GUEST_FILTER });\n      }\n      this.mGlobalFlagValues.updateFilterFlag();\n      this.notifyConfigureChanged(DanmakuConfigTag.BLOCK_GUEST_DANMAKU, block);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置弹幕滚动速度系数,只对滚动弹幕有效\n     * @param p\n     * @return\n     */\n    public DanmakuContext setScrollSpeedFactor(float p){\n        if (scrollSpeedFactor != p) {\n            scrollSpeedFactor = p;\n            mDanmakuFactory.updateDurationFactor(p);\n            mGlobalFlagValues.updateMeasureFlag();\n            mGlobalFlagValues.updateVisibleFlag();\n            notifyConfigureChanged(DanmakuConfigTag.SCROLL_SPEED_FACTOR, p);\n        }\n        return this;\n    }",
        "TranslatedCode": "public setScrollSpeedFactor(p: number): DanmakuContext{\n    if (this.scrollSpeedFactor != p) {\n      this.scrollSpeedFactor = p;\n      this.mDanmakuFactory.updateDurationFactor(p);\n      this.mGlobalFlagValues.updateMeasureFlag();\n      this.mGlobalFlagValues.updateVisibleFlag();\n      this.notifyConfigureChanged(DanmakuConfigTag.SCROLL_SPEED_FACTOR, p);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置是否启用合并重复弹幕\n     * @param enable\n     * @return\n     */\n    public DanmakuContext setDuplicateMergingEnabled(boolean enable) {\n        if (mDuplicateMergingEnable != enable) {\n            mDuplicateMergingEnable = enable;\n            mGlobalFlagValues.updateFilterFlag();\n            notifyConfigureChanged(DanmakuConfigTag.DUPLICATE_MERGING_ENABLED, enable);\n        }\n        return this;\n    }",
        "TranslatedCode": "public setDuplicateMergingEnabled(enable: boolean): DanmakuContext {\n    if (this.mDuplicateMergingEnable != enable) {\n      this.mDuplicateMergingEnable = enable;\n      this.mGlobalFlagValues.updateFilterFlag();\n      this.notifyConfigureChanged(DanmakuConfigTag.DUPLICATE_MERGING_ENABLED, enable);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置最大显示行数\n     * @param pairs map<K,V> 设置null取消行数限制\n     * K = (BaseDanmaku.TYPE_SCROLL_RL|BaseDanmaku.TYPE_SCROLL_LR|BaseDanmaku.TYPE_FIX_TOP|BaseDanmaku.TYPE_FIX_BOTTOM)\n     * V = 最大行数\n     * @return\n     */\n    public DanmakuContext setMaximumLines(Map<Integer, Integer> pairs) {\n        mIsMaxLinesLimited = (pairs != null);\n        if (pairs == null) {\n            mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_MAXIMUN_LINES_FILTER, false);\n        } else {\n            setFilterData(DanmakuFilters.TAG_MAXIMUN_LINES_FILTER, pairs, false);\n        }\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.MAXIMUN_LINES, pairs);\n        return this;\n    }",
        "TranslatedCode": "public setMaximumLines(pairs: Map<number, number>): DanmakuContext {\n    this.mIsMaxLinesLimited = (pairs != null);\n    if (pairs == null) {\n      this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_MAXIMUN_LINES_FILTER, primary: false });\n    } else {\n      this.setFilterData(DanmakuFilters.TAG_MAXIMUN_LINES_FILTER, pairs, false);\n    }\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.MAXIMUN_LINES, pairs);\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置防弹幕重叠\n     * @param pairs map<K,V> 设置null恢复默认设置,默认为允许重叠\n     * K = (BaseDanmaku.TYPE_SCROLL_RL|BaseDanmaku.TYPE_SCROLL_LR|BaseDanmaku.TYPE_FIX_TOP|BaseDanmaku.TYPE_FIX_BOTTOM)\n     * V = true|false 是否重叠\n     * @return\n     */\n    public DanmakuContext preventOverlapping(Map<Integer, Boolean> pairs) {\n        mIsPreventOverlappingEnabled = (pairs != null);\n        if (pairs == null) {\n            mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_OVERLAPPING_FILTER, false);\n        } else {\n            setFilterData(DanmakuFilters.TAG_OVERLAPPING_FILTER, pairs, false);\n        }\n        mGlobalFlagValues.updateFilterFlag();\n        notifyConfigureChanged(DanmakuConfigTag.OVERLAPPING_ENABLE, pairs);\n        return this;\n    }",
        "TranslatedCode": "public preventOverlapping(pairs: Map<number, boolean>): DanmakuContext {\n    this.mIsPreventOverlappingEnabled = (pairs != null);\n    if (pairs == null) {\n      this.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_OVERLAPPING_FILTER, primary: false });\n    } else {\n      this.setFilterData(DanmakuFilters.TAG_OVERLAPPING_FILTER, pairs, false);\n    }\n    this.mGlobalFlagValues.updateFilterFlag();\n    this.notifyConfigureChanged(DanmakuConfigTag.OVERLAPPING_ENABLE, pairs);\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 设置缓存绘制填充器，默认使用{@link SimpleTextCacheStuffer}只支持纯文字显示, 如果需要图文混排请设置{@link SpannedCacheStuffer}\n     * 如果需要定制其他样式请扩展{@link SimpleTextCacheStuffer}|{@link SpannedCacheStuffer}\n     * @param cacheStuffer\n     * @param cacheStufferAdapter\n     */\n    public DanmakuContext setCacheStuffer(BaseCacheStuffer cacheStuffer, BaseCacheStuffer.Proxy cacheStufferAdapter) {\n        this.mCacheStuffer = cacheStuffer;\n        if (this.mCacheStuffer != null) {\n            this.mCacheStuffer.setProxy(cacheStufferAdapter);\n            mDisplayer.setCacheStuffer(this.mCacheStuffer);\n        }\n        return this;\n    }",
        "TranslatedCode": "public setCacheStuffer(cacheStuffer: BaseCacheStuffer, cacheStufferAdapter: Proxy): DanmakuContext {\n    this.mCacheStuffer = cacheStuffer;\n    if (this.mCacheStuffer != null) {\n      this.mCacheStuffer.setProxy(cacheStufferAdapter);\n      this.mDisplayer.setCacheStuffer(this.mCacheStuffer);\n    }\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void registerConfigChangedCallback(ConfigChangedCallback listener) {\n        if (listener == null || mCallbackList == null) {\n            mCallbackList = Collections.synchronizedList(new ArrayList<WeakReference<ConfigChangedCallback>>());\n        }\n        for (WeakReference<ConfigChangedCallback> configReferer : mCallbackList) {\n            if (listener.equals(configReferer.get())) {\n                return;\n            }\n        }\n        mCallbackList.add(new WeakReference<ConfigChangedCallback>(listener));\n    }",
        "TranslatedCode": "public registerConfigChangedCallback(listener: ConfigChangedCallback): void {\n    if (listener == null || this.mCallbackList == null) {\n      this.mCallbackList = new Array<ConfigChangedCallback>();\n    }\n    for (let i: number = 0;i < this.mCallbackList.length; i++) {\n      if (listener == this.mCallbackList[i]) {\n        return;\n      }\n    }\n    this.mCallbackList.push(listener);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void unregisterConfigChangedCallback(ConfigChangedCallback listener) {\n        if (listener == null || mCallbackList == null)\n            return;\n        for (WeakReference<ConfigChangedCallback> configReferer : mCallbackList) {\n            if (listener.equals(configReferer.get())) {\n                mCallbackList.remove(listener);\n                return;\n            }\n        }\n    }",
        "TranslatedCode": "public unregisterConfigChangedCallback(listener: ConfigChangedCallback): void {\n    if (listener == null || this.mCallbackList === null)\n      return;\n    for (let i: number = 0;i < this.mCallbackList.length; i++) {\n      if (listener == this.mCallbackList[i]) {\n        this.mCallbackList.splice(i, 1);\n        return;\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void unregisterAllConfigChangedCallbacks() {\n        if (mCallbackList != null) {\n            mCallbackList.clear();\n            mCallbackList = null;\n        }\n    }",
        "TranslatedCode": "public unregisterAllConfigChangedCallbacks(): void {\n    if (this.mCallbackList != null) {\n      this.mCallbackList.length = 0;\n      this.mCallbackList = null;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void notifyConfigureChanged(DanmakuConfigTag tag, Object... values) {\n        if (mCallbackList != null) {\n            for (WeakReference<ConfigChangedCallback> configReferer : mCallbackList) {\n                ConfigChangedCallback cb = configReferer.get();\n                if (cb != null) {\n                    cb.onDanmakuConfigChanged(this, tag, values);\n                }\n            }\n        }\n    }",
        "TranslatedCode": "private notifyConfigureChanged(tag: DanmakuConfigTag, ...values: ESObject[]) {\n    if (this.mCallbackList != null) {\n      for (let i: number = 0; i < this.mCallbackList.length; i++) {\n        if (this.mCallbackList[i] != null) {\n          this.mCallbackList[i].onDanmakuConfigChanged(this, tag, values);\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": " public DanmakuContext registerFilter(DanmakuFilters.BaseDanmakuFilter filter) {\n        mDanmakuFilters.registerFilter(filter);\n        mGlobalFlagValues.updateFilterFlag();\n        return this;\n    }",
        "TranslatedCode": "public registerFilter(filter: BaseDanmakuFilter<ESObject>): DanmakuContext {\n    this.mDanmakuFilters.registerFilter({ filter: filter });\n    this.mGlobalFlagValues.updateFilterFlag();\n    return this;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * 创建弹幕数据请尽量使用此方法,参考BiliDanmakuParser或AcfunDanmakuParser\n     *\n     * @param type               弹幕类型\n     * @param viewportWidth      danmakuview宽度,会影响滚动弹幕的存活时间(duration)\n     * @param viewportHeight     danmakuview高度\n     * @param viewportSizeFactor 会影响滚动弹幕的速度/存活时间(duration)\n     * @return\n     */\n    public BaseDanmaku createDanmaku(int type, float viewportWidth, float viewportHeight,\n                                     float viewportSizeFactor, float scrollSpeedFactor) {\n        int oldDispWidth = CURRENT_DISP_WIDTH;\n        int oldDispHeight = CURRENT_DISP_HEIGHT;\n        boolean sizeChanged = updateViewportState(viewportWidth, viewportHeight, viewportSizeFactor);\n        if (MAX_Duration_Scroll_Danmaku == null) {\n            MAX_Duration_Scroll_Danmaku = new Duration(REAL_DANMAKU_DURATION);\n            MAX_Duration_Scroll_Danmaku.setFactor(scrollSpeedFactor);\n        } else if (sizeChanged) {\n            MAX_Duration_Scroll_Danmaku.setValue(REAL_DANMAKU_DURATION);\n        }\n\n        if (MAX_Duration_Fix_Danmaku == null) {\n            MAX_Duration_Fix_Danmaku = new Duration(COMMON_DANMAKU_DURATION);\n        }\n\n        float scaleX = 1f;\n        float scaleY = 1f;\n        if (sizeChanged && viewportWidth > 0) {\n            updateMaxDanmakuDuration();\n            if (oldDispWidth > 0 && oldDispHeight > 0) {\n                scaleX = viewportWidth / (float) oldDispWidth;\n                scaleY = viewportHeight / (float) oldDispHeight;\n            }\n            updateScaleFactor((int) viewportWidth, (int) viewportHeight, scaleX, scaleY);\n            if (viewportHeight > 0) {\n                updateSpecialDanmakusDate((int) viewportWidth, (int) viewportHeight, scaleX, scaleY);\n            }\n        }\n\n        BaseDanmaku instance = null;\n        switch (type) {\n            case 1: // 从右往左滚动\n                instance = new R2LDanmaku(MAX_Duration_Scroll_Danmaku);\n                break;\n            case 4: // 底端固定\n                instance = new FBDanmaku(MAX_Duration_Fix_Danmaku);\n                break;\n            case 5: // 顶端固定\n                instance = new FTDanmaku(MAX_Duration_Fix_Danmaku);\n                break;\n            case 6: // 从左往右滚动\n                instance = new L2RDanmaku(MAX_Duration_Scroll_Danmaku);\n                break;\n            case 7: // 特殊弹幕\n                instance = new SpecialDanmaku();\n                updateScaleFactor((int) viewportWidth, (int) viewportHeight, scaleX, scaleY);\n                ((SpecialDanmaku) instance).setScaleFactor(mScaleFactor);\n                break;\n        }\n        return instance;\n    }",
        "TranslatedCode": "public createDanmakuByAll(type: number, viewportWidth?: number|ESObject, viewportHeight?: number|ESObject,\n                            viewportScale?: number|ESObject, scrollSpeedFactor?: number|ESObject): BaseDanmaku{\n    let oldDispWidth: number = this.CURRENT_DISP_WIDTH;\n    let oldDispHeight: number = this.CURRENT_DISP_HEIGHT;\n    let sizeChanged: boolean = this.updateViewportState(viewportWidth, viewportHeight, viewportScale);\n    if (this.MAX_Duration_Scroll_Danmaku == null) {\n      this.MAX_Duration_Scroll_Danmaku = new Duration(this.REAL_DANMAKU_DURATION);\n      this.MAX_Duration_Scroll_Danmaku.setFactor(scrollSpeedFactor);\n    } else if (sizeChanged) {\n      this.MAX_Duration_Scroll_Danmaku.setValue(this.REAL_DANMAKU_DURATION);\n    }\n\n    if (this.MAX_Duration_Fix_Danmaku == null) {\n      this.MAX_Duration_Fix_Danmaku = new Duration(DanmakuFactory.COMMON_DANMAKU_DURATION);\n    }\n\n    let scaleX: number = 1;\n    let scaleY: number = 1;\n    if (sizeChanged && viewportWidth > 0) {\n      this.updateMaxDanmakuDuration();\n      if (oldDispWidth > 0 && oldDispHeight > 0) {\n        scaleX = viewportWidth / oldDispWidth;\n        scaleY = viewportHeight / oldDispHeight;\n      }\n      this.updateScaleFactor(viewportWidth, viewportHeight, scaleX, scaleY);\n      if (viewportHeight > 0) {\n        this.updateSpecialDanmakusDate(viewportWidth, viewportHeight, scaleX, scaleY);\n      }\n    }\n\n    let instance: BaseDanmaku |ESObject= null;\n    switch (type) {\n      case 1: // 从右往左滚动\n        instance = new R2LDanmaku(this.MAX_Duration_Scroll_Danmaku);\n        break;\n      case 4: // 底端固定\n        instance = new FBDanmaku(this.MAX_Duration_Fix_Danmaku);\n        break;\n      case 5: // 顶端固定\n        instance = new FTDanmaku(this.MAX_Duration_Fix_Danmaku);\n        break;\n      case 6: // 从左往右滚动\n        instance = new L2RDanmaku(this.MAX_Duration_Scroll_Danmaku);\n        break;\n      case 7: // 特殊弹幕\n        instance = new SpecialDanmaku();\n        this.updateScaleFactor(viewportWidth, viewportHeight, scaleX, scaleY);\n        ( instance as SpecialDanmaku).setScaleFactor(this.mScaleFactor);\n        break;\n    }\n    return instance;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void updateScaleFactor(int width, int height, float scaleX, float scaleY) {\n        if (mScaleFactor == null) {\n            mScaleFactor = new SpecialDanmaku.ScaleFactor(width, height, scaleX, scaleY);\n        }\n        mScaleFactor.update(width, height, scaleX, scaleY);\n    }",
        "TranslatedCode": "private updateScaleFactor(width: number, height: number, scaleX: number, scaleY: number) {\n    if (this.mScaleFactor == null) {\n      this.mScaleFactor = new ScaleFactor(width, height, scaleX, scaleY);\n    }\n    this.mScaleFactor.update(width, height, scaleX, scaleY);\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean updateViewportState(float viewportWidth, float viewportHeight,\n                                       float viewportSizeFactor) {\n        boolean sizeChanged = false;\n        if (CURRENT_DISP_WIDTH != (int) viewportWidth\n                || CURRENT_DISP_HEIGHT != (int) viewportHeight\n                || CURRENT_DISP_SIZE_FACTOR != viewportSizeFactor) {\n            sizeChanged = true;\n            REAL_DANMAKU_DURATION = (long) (COMMON_DANMAKU_DURATION * (viewportSizeFactor\n                    * viewportWidth / BILI_PLAYER_WIDTH));\n            REAL_DANMAKU_DURATION = Math.min(MAX_DANMAKU_DURATION_HIGH_DENSITY,\n                    REAL_DANMAKU_DURATION);\n            REAL_DANMAKU_DURATION = Math.max(MIN_DANMAKU_DURATION, REAL_DANMAKU_DURATION);\n\n            CURRENT_DISP_WIDTH = (int) viewportWidth;\n            CURRENT_DISP_HEIGHT = (int) viewportHeight;\n            CURRENT_DISP_SIZE_FACTOR = viewportSizeFactor;\n        }\n        return sizeChanged;\n    }",
        "TranslatedCode": "public updateViewportState(viewportWidth: number|ESObject, viewportHeight: number,\n                             viewportSizeFactor: number): boolean {\n    let sizeChanged: boolean = false;\n    if (this.CURRENT_DISP_WIDTH != viewportWidth\n    || this.CURRENT_DISP_HEIGHT != viewportHeight\n    || this.CURRENT_DISP_SIZE_FACTOR != viewportSizeFactor) {\n      sizeChanged = true;\n      this.REAL_DANMAKU_DURATION = (DanmakuFactory.COMMON_DANMAKU_DURATION * (viewportSizeFactor\n      * viewportWidth / DanmakuFactory.BILI_PLAYER_WIDTH));\n      this.REAL_DANMAKU_DURATION = Math.min(DanmakuFactory.MAX_DANMAKU_DURATION_HIGH_DENSITY,\n        this.REAL_DANMAKU_DURATION);\n      this.REAL_DANMAKU_DURATION = Math.max(DanmakuFactory.MIN_DANMAKU_DURATION, this.REAL_DANMAKU_DURATION);\n\n      this.CURRENT_DISP_WIDTH = viewportWidth;\n      this.CURRENT_DISP_HEIGHT = viewportHeight;\n      this.CURRENT_DISP_SIZE_FACTOR = viewportSizeFactor;\n    }\n    return sizeChanged;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void updateDurationFactor(float f) {\n        if (MAX_Duration_Scroll_Danmaku == null || MAX_Duration_Fix_Danmaku == null)\n            return;\n        MAX_Duration_Scroll_Danmaku.setFactor(f);\n        updateMaxDanmakuDuration();\n    }",
        "TranslatedCode": "public updateDurationFactor(f: number) {\n    if (this.MAX_Duration_Scroll_Danmaku == null || this.MAX_Duration_Fix_Danmaku == null) {\n      return;\n    }\n    this.MAX_Duration_Scroll_Danmaku.setFactor(f);\n    this.updateMaxDanmakuDuration();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Initial translation data of the special danmaku\n     *\n     * @param item\n     * @param beginX\n     * @param beginX\n     * @param beginY\n     * @param endX\n     * @param endY\n     * @param translationDuration\n     * @param translationStartDelay\n     */\n    public void fillTranslationData(BaseDanmaku item, float beginX, float beginY,\n                                    float endX, float endY, long translationDuration, long translationStartDelay,\n                                    float scaleX, float scaleY) {\n        if (item.getType() != BaseDanmaku.TYPE_SPECIAL)\n            return;\n        ((SpecialDanmaku) item).setTranslationData(beginX * scaleX, beginY * scaleY, endX * scaleX,\n                endY * scaleY, translationDuration, translationStartDelay);\n        updateSpecicalDanmakuDuration(item);\n    }",
        "TranslatedCode": "/**\n     * Initial translation data of the special danmaku\n     *\n     * @param item\n     * @param beginX\n     * @param beginX\n     * @param beginY\n     * @param endX\n     * @param endY\n     * @param translationDuration\n     * @param translationStartDelay\n     */\n  public fillTranslationData(item: BaseDanmaku, beginX: number, beginY: number,\n                             endX: number, endY: number, translationDuration: number, translationStartDelay: number,\n                             scaleX: number, scaleY: number) {\n    if (item.getType() != BaseDanmaku.TYPE_SPECIAL)\n      return;\n    (item as SpecialDanmaku).setTranslationData(beginX * scaleX, beginY * scaleY, endX * scaleX,\n      endY * scaleY, translationDuration, translationStartDelay);\n    this.updateSpecicalDanmakuDuration(item);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public static void fillLinePathData(BaseDanmaku item, float[][] points, float scaleX,\n                                        float scaleY) {\n        if (item.getType() != BaseDanmaku.TYPE_SPECIAL || points.length == 0\n                || points[0].length != 2)\n            return;\n        for (int i = 0; i < points.length; i++) {\n            points[i][0] *= scaleX;\n            points[i][1] *= scaleY;\n        }\n        ((SpecialDanmaku) item).setLinePathData(points);\n    }",
        "TranslatedCode": "public static fillLinePathData(item: BaseDanmaku, points: number[][], scaleX: number,\n                                 scaleY: number) {\n    if (item.getType() != BaseDanmaku.TYPE_SPECIAL || points.length == 0 || points[0].length != 2) {\n      return;\n    }\n    for (let i = 0; i < points.length; i++) {\n      points[i][0] *= scaleX;\n      points[i][1] *= scaleY;\n    }\n    (item as SpecialDanmaku).setLinePathData(points);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Initial alpha data of the special danmaku\n     *\n     * @param item\n     * @param beginAlpha\n     * @param endAlpha\n     * @param alphaDuraion\n     */\n    public void fillAlphaData(BaseDanmaku item, int beginAlpha, int endAlpha,\n                              long alphaDuraion) {\n        if (item.getType() != BaseDanmaku.TYPE_SPECIAL)\n            return;\n        ((SpecialDanmaku) item).setAlphaData(beginAlpha, endAlpha, alphaDuraion);\n        updateSpecicalDanmakuDuration(item);\n    }",
        "TranslatedCode": "/**\n     * Initial alpha data of the special danmaku\n     *\n     * @param item\n     * @param beginAlpha\n     * @param endAlpha\n     * @param alphaDuraion\n     */\n  public fillAlphaData(item: BaseDanmaku, beginAlpha: number, endAlpha: number,\n                       alphaDuraion: number) {\n    if (item.getType() != BaseDanmaku.TYPE_SPECIAL) {\n      return;\n    }\n    (item as SpecialDanmaku).setAlphaData(beginAlpha, endAlpha, alphaDuraion);\n    this.updateSpecicalDanmakuDuration(item);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void updateSpecicalDanmakuDuration(BaseDanmaku item) {\n        if (MAX_Duration_Special_Danmaku == null || (item.duration != null && item.duration.value > MAX_Duration_Special_Danmaku.value)) {\n            MAX_Duration_Special_Danmaku = item.duration;\n            updateMaxDanmakuDuration();\n        }\n    }",
        "TranslatedCode": "private updateSpecicalDanmakuDuration(item: BaseDanmaku) {\n    if (this.MAX_Duration_Special_Danmaku == null || (item.duration != null && item.duration.value > this.MAX_Duration_Special_Danmaku.value)) {\n      this.MAX_Duration_Special_Danmaku = item.duration;\n      this.updateMaxDanmakuDuration();\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public Danmakus() {\n        this(ST_BY_TIME, false);\n    }\n\n    public Danmakus(int sortType) {\n        this(sortType, false);\n    }\n\n    public Danmakus(int sortType, boolean duplicateMergingEnabled) {\n        this(sortType, duplicateMergingEnabled, null);\n    }\n\n    public Danmakus(int sortType, boolean duplicateMergingEnabled, BaseComparator baseComparator) {\n        BaseComparator comparator = null;\n        if (sortType == ST_BY_TIME) {\n            comparator = baseComparator == null ? new TimeComparator(duplicateMergingEnabled) : baseComparator;\n        } else if (sortType == ST_BY_YPOS) {\n            comparator = new YPosComparator(duplicateMergingEnabled);\n        } else if (sortType == ST_BY_YPOS_DESC) {\n            comparator = new YPosDescComparator(duplicateMergingEnabled);\n        }\n        if (sortType == ST_BY_LIST) {\n            items = new LinkedList<>();\n        } else {\n            mDuplicateMergingEnabled = duplicateMergingEnabled;\n            comparator.setDuplicateMergingEnabled(duplicateMergingEnabled);\n            items = new TreeSet<>(comparator);\n            mComparator = comparator;\n        }\n        mSortType = sortType;\n        mSize.set(0);\n    }\n\n    public Danmakus(Collection<BaseDanmaku> items) {\n        setItems(items);\n    }\n\n    public Danmakus(boolean duplicateMergingEnabled) {\n        this(ST_BY_TIME, duplicateMergingEnabled);\n    }",
        "TranslatedCode": "constructor(args:Args) {\n    if (args.items !== undefined) {\n      this.setItems(args.items);\n    } else {\n      if (args.sortType === undefined) {\n        args.sortType = ST_BY_TIME\n      }\n      if (args.duplicateMergingEnabled == undefined) {\n        args.duplicateMergingEnabled = false\n      }\n      if (args.baseComparator === undefined) {\n        args.baseComparator = null\n      }\n      let comparator: BaseComparator|null = null;\n      if (args.sortType == ST_BY_TIME) {\n        comparator = args.baseComparator == null ? new TimeComparator(args.duplicateMergingEnabled) : args.baseComparator;\n      } else if (args.sortType == ST_BY_YPOS) {\n        comparator = new YPosComparator(args.duplicateMergingEnabled);\n      } else if (args.sortType == ST_BY_YPOS_DESC) {\n        comparator = new YPosDescComparator(args.duplicateMergingEnabled);\n      }\n      if (args.sortType == ST_BY_LIST) {\n        this.items = new Array();\n      } else {\n        this.mDuplicateMergingEnabled = args.duplicateMergingEnabled;\n        if(comparator!=null){\n          comparator.setDuplicateMergingEnabled(args.duplicateMergingEnabled);\n          this.items = new SortedSet(comparator);\n          this.mComparator = comparator;\n        }\n      }\n      this.mSortType = args.sortType;\n      this.mSize = 0;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setItems(Collection<BaseDanmaku> items) {\n        if (mDuplicateMergingEnabled && mSortType != ST_BY_LIST) {\n            synchronized (this.mLockObject) {\n                this.items.clear();\n                this.items.addAll(items);\n                items = this.items;\n            }\n        } else {\n            this.items = items;\n        }\n        if (items instanceof List) {\n            mSortType = ST_BY_LIST;\n        }\n        mSize.set(items == null ? 0 : items.size());\n    }",
        "TranslatedCode": "public setItems(items: Array<BaseDanmaku>) {\n    if (this.mDuplicateMergingEnabled && this.mSortType != ST_BY_LIST) {\n      this.items = [];\n      this.items.push.apply(this.items, items);\n      items = this.items;\n    } else {\n      this.items = items;\n    }\n    if (items instanceof List) {\n      this.mSortType = ST_BY_LIST;\n    }\n    this.mSize = (items == null ? 0 : items.length)\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean addItem(BaseDanmaku item) {\n        synchronized (this.mLockObject) {\n            if (items != null) {\n                try {\n                    if (items.add(item)) {\n                        mSize.incrementAndGet();\n                        return true;\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return false;\n    }",
        "TranslatedCode": "public addItem(item: BaseDanmaku): boolean {\n    if (this.items != null) {\n      try {\n        if (this.items.push(item) > 0) {\n          this.mSize++;\n          return true;\n        }\n      } catch (e) {\n        console.info(e)\n      }\n    }\n\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean removeItem(BaseDanmaku item) {\n        if (item == null) {\n            return false;\n        }\n        if (item.isOutside()) {\n            item.setVisibility(false);\n        }\n        synchronized (this.mLockObject) {\n            if (items.remove(item)) {\n                mSize.decrementAndGet();\n                return true;\n            }\n        }\n        return false;\n    }",
        "TranslatedCode": "public removeItem(item: BaseDanmaku): boolean {\n    if (item == null) {\n      return false;\n    }\n    if (item.isOutside()) {\n      item.setVisibility(false);\n    }\n    if (this.items.indexOf(item) >= 0) {\n      this.items.splice(this.items.indexOf(item), 1)\n      this.mSize--;\n      return true;\n    }\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private Collection<BaseDanmaku> subset(long startTime, long endTime) {\n        if (mSortType == ST_BY_LIST || items == null || items.size() == 0) {\n            return null;\n        }\n        if (subItems == null) {\n            subItems = new Danmakus(mDuplicateMergingEnabled);\n            subItems.mLockObject = this.mLockObject;\n        }\n        if (startSubItem == null) {\n            startSubItem = createItem(\"start\");\n        }\n        if (endSubItem == null) {\n            endSubItem = createItem(\"end\");\n        }\n\n        startSubItem.setTime(startTime);\n        endSubItem.setTime(endTime);\n        return ((SortedSet<BaseDanmaku>) items).subSet(startSubItem, endSubItem);\n    }",
        "TranslatedCode": "private subset(startTime: number, endTime: number): Array<BaseDanmaku>|ESObject {\n    if (this.mSortType == ST_BY_LIST || this.items == null || this.items.length == 0) {\n      return null;\n    }\n    if (this.subItems == null) {\n      this.subItems = new Danmakus({ duplicateMergingEnabled: this.mDuplicateMergingEnabled });\n\n    }\n    if (this.startSubItem == null) {\n      this.startSubItem = this.createItem(\"start\");\n    }\n    if (this.endSubItem == null) {\n      this.endSubItem = this.createItem(\"end\");\n    }\n\n    this.startSubItem.setTime(startTime);\n    this.endSubItem.setTime(endTime);\n    return (this.items as SortedSet<BaseDanmaku>).subSet(this.startSubItem, this.endSubItem);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public IDanmakus subnew(long startTime, long endTime) {\n        Collection<BaseDanmaku> subset = subset(startTime, endTime);\n        if (subset == null || subset.isEmpty()) {\n            return null;\n        }\n        LinkedList<BaseDanmaku> newSet = new LinkedList<BaseDanmaku>(subset);\n        return new Danmakus(newSet);\n    }",
        "TranslatedCode": "public subnew(startTime: number, endTime: number): IDanmakus|ESObject {\n    let subset: Array<BaseDanmaku> = this.subset(startTime, endTime);\n    if (subset == null || subset.length === 0) {\n      return null;\n    }\n    let newSet: BaseDanmaku[] = Array.from(subset);\n    return new Danmakus({ items: newSet });\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public IDanmakus sub(long startTime, long endTime) {\n        if (items == null || items.size() == 0) {\n            return null;\n        }\n        if (subItems == null) {\n            if(mSortType == ST_BY_LIST) {\n                subItems = new Danmakus(Danmakus.ST_BY_LIST);\n                subItems.mLockObject = this.mLockObject;\n                synchronized (this.mLockObject) {\n                    subItems.setItems(items);\n                }\n            } else {\n                subItems = new Danmakus(mDuplicateMergingEnabled);\n                subItems.mLockObject = this.mLockObject;\n            }\n        }\n        if (mSortType == ST_BY_LIST) {\n            return subItems;\n        }\n        if (startItem == null) {\n            startItem = createItem(\"start\");\n        }\n        if (endItem == null) {\n            endItem = createItem(\"end\");\n        }\n\n        if (subItems != null) {\n            long dtime = startTime - startItem.getActualTime();\n            if (dtime >= 0 && endTime <= endItem.getActualTime()) {\n                return subItems;\n            }\n        }\n\n        startItem.setTime(startTime);\n        endItem.setTime(endTime);\n        synchronized (this.mLockObject) {\n            subItems.setItems(((SortedSet<BaseDanmaku>) items).subSet(startItem, endItem));\n        }\n        return subItems;\n    }",
        "TranslatedCode": "public sub(startTime: number, endTime: number): IDanmakus|ESObject {\n    if (this.items == null || this.items.length == 0) {\n      return null;\n    }\n    if (this.subItems == null) {\n      if (this.mSortType == ST_BY_LIST) {\n        let subItems = new Danmakus({ sortType: ST_BY_LIST });\n        //        subItems.mLockObject = this.mLockObject;\n        subItems.setItems(this.items);\n      } else {\n        this.subItems = new Danmakus({ duplicateMergingEnabled: this.mDuplicateMergingEnabled });\n        //        this.subItems.mLockObject = this.mLockObject;\n      }\n    }\n    if (this.mSortType == ST_BY_LIST) {\n      return this.subItems;\n    }\n    if (this.startItem == null) {\n      this.startItem = this.createItem(\"start\");\n    }\n    if (this.endItem == null) {\n      this.endItem = this.createItem(\"end\");\n    }\n\n    if (this.subItems != null) {\n      let dtime: number = startTime - this.startItem.getActualTime();\n      if (dtime >= 0 && endTime <= this.endItem.getActualTime()) {\n        return this.subItems;\n      }\n    }\n    this.startItem.setTime(startTime);\n    this.endItem.setTime(endTime);\n    this.subItems.setItems((this.items as SortedSet<BaseDanmaku>).subSet(this.startItem, this.endItem));\n    return this.subItems;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int size() {\n        return mSize.get();\n    }",
        "TranslatedCode": "public size(): number {\n    return this.mSize;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void clear() {\n        synchronized (this.mLockObject) {\n            if (items != null) {\n                items.clear();\n                mSize.set(0);\n            }\n        }\n        if (subItems != null) {\n            subItems = null;\n            startItem = createItem(\"start\");\n            endItem = createItem(\"end\");\n        }\n    }",
        "TranslatedCode": "public clear() {\n    if (this.items != null) {\n      this.items.splice(0, this.items.length);\n      this.mSize = 0;\n    }\n    if (this.subItems != null) {\n      this.subItems = null;\n      this.startItem = this.createItem(\"start\");\n      this.endItem = this.createItem(\"end\");\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BaseDanmaku first() {\n        if (items != null && !items.isEmpty()) {\n            if (mSortType == ST_BY_LIST) {\n                return ((LinkedList<BaseDanmaku>) items).peek();\n            }\n            return ((SortedSet<BaseDanmaku>) items).first();\n        }\n        return null;\n    }",
        "TranslatedCode": "public first(): BaseDanmaku|ESObject {\n    if (this.items != null && !(this.items.length == 0)) {\n      return this.items[0];\n    }\n    return null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public BaseDanmaku last() {\n        if (items != null && !items.isEmpty()) {\n            if (mSortType == ST_BY_LIST) {\n                return ((LinkedList<BaseDanmaku>) items).peekLast();\n            }\n            return ((SortedSet<BaseDanmaku>) items).last();\n        }\n        return null;\n    }",
        "TranslatedCode": "public last(): BaseDanmaku|ESObject {\n    if (this.items != null && !(this.items.length == 0)) {\n      return this.items[this.items.length - 1]\n    }\n    return null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean contains(BaseDanmaku item) {\n        return this.items != null && this.items.contains(item);\n    }",
        "TranslatedCode": "public contains(item: BaseDanmaku): boolean {\n    return this.items != null && (this.items.indexOf(item) >= 0);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isEmpty() {\n        return this.items == null || this.items.isEmpty();\n    }",
        "TranslatedCode": "public isEmpty(): boolean {\n    return this.items == null || this.items.length == 0;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void setDuplicateMergingEnabled(boolean enable) {\n        mComparator.setDuplicateMergingEnabled(enable);\n        mDuplicateMergingEnabled = enable;\n    }",
        "TranslatedCode": "private setDuplicateMergingEnabled(enable: boolean) {\n    this.mComparator.setDuplicateMergingEnabled(enable);\n    this.mDuplicateMergingEnabled = enable;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setSubItemsDuplicateMergingEnabled(boolean enable) {\n        mDuplicateMergingEnabled = enable;\n        startItem = endItem = null;\n        if (subItems == null) {\n            subItems = new Danmakus(enable);\n            subItems.mLockObject = this.mLockObject;\n        }\n        subItems.setDuplicateMergingEnabled(enable);\n    }",
        "TranslatedCode": "public setSubItemsDuplicateMergingEnabled(enable: boolean) {\n    this.mDuplicateMergingEnabled = enable;\n    this.startItem = this.endItem = null;\n    if (this.subItems == null) {\n      this.subItems = new Danmakus({ duplicateMergingEnabled: enable });\n    }\n    this.subItems.setDuplicateMergingEnabled(enable);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public Collection<BaseDanmaku> getCollection() {\n        return this.items;\n    }",
        "TranslatedCode": "public getCollection(): Array<BaseDanmaku> {\n    return this.items;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void forEachSync(Consumer<? super BaseDanmaku, ?> consumer) {\n        synchronized (this.mLockObject) {\n            forEach(consumer);\n        }\n    }",
        "TranslatedCode": "public forEachSync(consumer: Consumer<BaseDanmaku, ESObject>): void {\n\n    this.forEach(consumer);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void forEach(Consumer<? super BaseDanmaku, ?> consumer) {\n        consumer.before();\n        Iterator<BaseDanmaku> it = items.iterator();\n        while (it.hasNext()) {\n            BaseDanmaku next = it.next();\n            if (next == null) {\n                continue;\n            }\n            int action = consumer.accept(next);\n            if (action == DefaultConsumer.ACTION_BREAK) {\n                break;\n            } else if (action == DefaultConsumer.ACTION_REMOVE) {\n                it.remove();\n                mSize.decrementAndGet();\n            } else if (action == DefaultConsumer.ACTION_REMOVE_AND_BREAK) {\n                it.remove();\n                mSize.decrementAndGet();\n                break;\n            }\n        }\n        consumer.after();\n    }",
        "TranslatedCode": "public forEach(consumer: Consumer<BaseDanmaku, ESObject>): void {\n    consumer.before();\n    for (let i = 0;i < this.items.length; i++) {\n      let next: BaseDanmaku = this.items[i]\n      if (next == null) {\n        continue;\n      }\n      let action: number = consumer.accept(next);\n      if (action == DefaultConsumer.ACTION_BREAK) {\n        break;\n      } else if (action == Consumer.ACTION_REMOVE) {\n        this.items.splice(i, 1)\n        this.mSize--;\n        i--;\n      } else if (action == DefaultConsumer.ACTION_REMOVE_AND_BREAK) {\n        this.items.splice(i, 1)\n        this.mSize--;\n        break;\n      }\n    }\n    consumer.after();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setProjectionConfig(float offsetX, float offsetY, int alpha) {\n            if (sProjectionOffsetX != offsetX || sProjectionOffsetY != offsetY || sProjectionAlpha != alpha) {\n                sProjectionOffsetX = (offsetX > 1.0f) ? offsetX : 1.0f;\n                sProjectionOffsetY = (offsetY > 1.0f) ? offsetY : 1.0f;\n                sProjectionAlpha = (alpha < 0) ? 0 : ((alpha > 255) ? 255 : alpha);\n            }\n        }",
        "TranslatedCode": "public setProjectionConfig(offsetX: number, offsetY: number, alpha: number): void {\n    if (this.sProjectionOffsetX != offsetX || this.sProjectionOffsetY != offsetY || this.sProjectionAlpha != alpha) {\n      this.sProjectionOffsetX = (offsetX > 1.0) ? offsetX : 1.0;\n      this.sProjectionOffsetY = (offsetY > 1.0) ? offsetY : 1.0;\n      this.sProjectionAlpha = (alpha < 0) ? 0 : ((alpha > 255) ? 255 : alpha);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setScaleTextSizeFactor(float factor) {\n            isTextScaled = (factor != 1f);\n            scaleTextSize = factor;\n        }",
        "TranslatedCode": "public setScaleTextSizeFactor(factor: number): void {\n\n    this.isTextScaled = (factor != 1);\n\n    this.scaleTextSize = factor;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void applyTextScaleConfig(BaseDanmaku danmaku, Paint paint) {\n            if (!isTextScaled) {\n                return;\n            }\n            Float size = sCachedScaleSize.get(danmaku.textSize);\n            if (size == null || sLastScaleTextSize != scaleTextSize) {\n                sLastScaleTextSize = scaleTextSize;\n                size = danmaku.textSize * scaleTextSize;\n                sCachedScaleSize.put(danmaku.textSize, size);\n            }\n            paint.setTextSize(size);\n        }",
        "TranslatedCode": "private applyTextScaleConfig(danmaku: BaseDanmaku, paint: Paint): void {\n    if (!this.isTextScaled) {\n      return;\n    }\n    let size: number|undefined = this.sCachedScaleSize.get(danmaku.textSize);\n    if (size == null || this.sLastScaleTextSize != this.scaleTextSize) {\n      this.sLastScaleTextSize = this.scaleTextSize;\n      size = danmaku.textSize * this.scaleTextSize;\n      this.sCachedScaleSize.set(danmaku.textSize, size);\n    }\n    paint.setTextSize(size);\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public TextPaint getPaint(BaseDanmaku danmaku, boolean fromWorkerThread) {\n            TextPaint paint;\n            if (fromWorkerThread) {\n                paint = PAINT;\n            } else {\n                paint = PAINT_DUPLICATE;\n                paint.set(PAINT);\n            }\n            paint.setTextSize(danmaku.textSize);\n            applyTextScaleConfig(danmaku, paint);\n\n            //ignore the transparent textShadowColor\n            if (!HAS_SHADOW || SHADOW_RADIUS <= 0 || danmaku.textShadowColor == 0) {\n                paint.clearShadowLayer();\n            } else {\n                paint.setShadowLayer(SHADOW_RADIUS, 0, 0, danmaku.textShadowColor);\n            }\n            paint.setAntiAlias(ANTI_ALIAS);\n            return paint;\n        }",
        "TranslatedCode": "public getPaint(danmaku: BaseDanmaku, fromWorkerThread: boolean): Paint{\n    let paint: Paint;\n    if (fromWorkerThread) {\n      paint = this.PAINT;\n    } else {\n      paint = this.PAINT_DUPLICATE;\n      paint.set(this.PAINT);\n    }\n    paint.setTextSize(danmaku.textSize);\n    this.applyTextScaleConfig(danmaku, paint);\n\n    //ignore the transparent textShadowColor\n    if (!this.HAS_SHADOW || this.SHADOW_RADIUS <= 0 || danmaku.textShadowColor == 0) {\n      paint.clearShadowLayer();\n    } else {\n      paint.setShadowLayer(this.SHADOW_RADIUS, 0, 0, danmaku.textShadowColor);\n    }\n\n    return paint;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void applyPaintConfig(BaseDanmaku danmaku, Paint paint, boolean stroke) {\n\n            if (isTranslucent) {\n                if (stroke) {\n                    paint.setStyle(HAS_PROJECTION ? Style.FILL : Style.FILL_AND_STROKE);\n                    paint.setColor(danmaku.textShadowColor & 0x00FFFFFF);\n                    int alpha = HAS_PROJECTION ? (int) (sProjectionAlpha * ((float) transparency / AlphaValue.MAX))\n                            : transparency;\n                    paint.setAlpha(alpha);\n                } else {\n                    paint.setStyle(Style.FILL);\n                    paint.setColor(danmaku.textColor & 0x00FFFFFF);\n                    paint.setAlpha(transparency);\n                }\n            } else {\n                if (stroke) {\n                    paint.setStyle(HAS_PROJECTION ? Style.FILL : Style.FILL_AND_STROKE);\n                    paint.setColor(danmaku.textShadowColor & 0x00FFFFFF);\n                    int alpha = HAS_PROJECTION ? sProjectionAlpha : AlphaValue.MAX;\n                    paint.setAlpha(alpha);\n                } else {\n                    paint.setStyle(Style.FILL);\n                    paint.setColor(danmaku.textColor & 0x00FFFFFF);\n                    paint.setAlpha(AlphaValue.MAX);\n                }\n            }\n\n            if (danmaku.getType() == BaseDanmaku.TYPE_SPECIAL) {\n                paint.setAlpha(danmaku.getAlpha());\n            }\n\n        }",
        "TranslatedCode": "public applyPaintConfig(danmaku: BaseDanmaku, paint: Paint, stroke: boolean): void {\n\n    if (this.isTranslucent) {\n      if (stroke) {\n        paint.setStyle(this.HAS_PROJECTION ? Style.FILL : Style.FILL_AND_STROKE);\n        paint.setColor(danmaku.textShadowColor & 0x00FFFFFF);\n        let alpha: number = this.HAS_PROJECTION ? this.sProjectionAlpha * (this.transparency / AlphaValue.MAX)\n                                                : this.transparency;\n        paint.setAlpha(alpha);\n      } else {\n        paint.setStyle(Style.FILL);\n        paint.setColor(danmaku.textColor & 0x00FFFFFF);\n        paint.setAlpha(this.transparency);\n      }\n    } else {\n      if (stroke) {\n        paint.setStyle(this.HAS_PROJECTION ? Style.FILL : Style.FILL_AND_STROKE);\n        paint.setColor(danmaku.textShadowColor & 0x00FFFFFF);\n        let alpha: number = this.HAS_PROJECTION ? this.sProjectionAlpha : AlphaValue.MAX;\n        paint.setAlpha(alpha);\n      } else {\n        paint.setStyle(Style.FILL);\n        paint.setColor(danmaku.textColor & 0x00FFFFFF);\n        paint.setAlpha(AlphaValue.MAX);\n      }\n    }\n\n    if (danmaku.getType() == BaseDanmaku.TYPE_SPECIAL) {\n      paint.setAlpha(danmaku.getAlpha());\n    }\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getStrokeWidth() {\n            if (HAS_SHADOW && HAS_STROKE) {\n                return Math.max(SHADOW_RADIUS, STROKE_WIDTH);\n            }\n            if (HAS_SHADOW) {\n                return SHADOW_RADIUS;\n            }\n            if (HAS_STROKE) {\n                return STROKE_WIDTH;\n            }\n            return 0f;\n        }",
        "TranslatedCode": "public getStrokeWidth(): number {\n    if (this.HAS_SHADOW && this.HAS_STROKE) {\n      return Math.max(this.SHADOW_RADIUS, this.STROKE_WIDTH);\n    }\n    if (this.HAS_SHADOW) {\n      return this.SHADOW_RADIUS;\n    }\n    if (this.HAS_STROKE) {\n      return this.STROKE_WIDTH;\n    }\n    return 0;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected Float getCacheHeight(BaseDanmaku danmaku, Paint paint) {\n        Float textSize = paint.getTextSize();\n        Float textHeight = sTextHeightCache.get(textSize);\n        if (textHeight == null) {\n            Paint.FontMetrics fontMetrics = paint.getFontMetrics();\n            textHeight = fontMetrics.descent - fontMetrics.ascent + fontMetrics.leading;\n            sTextHeightCache.put(textSize, textHeight);\n        }\n        return textHeight;\n    }",
        "TranslatedCode": "protected getCacheHeight(danmaku: BaseDanmaku, paint: Paint): number {\n    let textSize: number = paint.getTextSize();\n    let textHeight: number|ESObject = SimpleTextCacheStuffer.sTextHeightCache.get(textSize);\n    if (textHeight == null) {\n      textHeight = measureTextHeight(paint)\n      SimpleTextCacheStuffer.sTextHeightCache.set(textSize, textHeight);\n    }\n    return textHeight;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void measure(BaseDanmaku danmaku, TextPaint paint, boolean fromWorkerThread) {\n        float w = 0;\n        Float textHeight = 0f;\n        if (danmaku.lines == null) {\n            if (danmaku.text == null) {\n                w = 0;\n            } else {\n                w = paint.measureText(danmaku.text.toString());\n                textHeight = getCacheHeight(danmaku, paint);\n            }\n            danmaku.paintWidth = w;\n            danmaku.paintHeight = textHeight;\n        } else {\n            textHeight = getCacheHeight(danmaku, paint);\n            for (String tempStr : danmaku.lines) {\n                if (tempStr.length() > 0) {\n                    float tr = paint.measureText(tempStr);\n                    w = Math.max(tr, w);\n                }\n            }\n            danmaku.paintWidth = w;\n            danmaku.paintHeight = danmaku.lines.length * textHeight;\n        }\n    }",
        "TranslatedCode": "public measure(danmaku: BaseDanmaku, paint: Paint, fromWorkerThread: boolean) {\n    let w: number = 0;\n    let textHeight: number = 0;\n    if (danmaku.lines == null) {\n      if (danmaku.text == null) {\n        w = 0;\n      } else {\n        w = measureTextWidth(danmaku.text.toString(), paint);\n        textHeight = this.getCacheHeight(danmaku, paint);\n      }\n      danmaku.paintWidth = w;\n      danmaku.paintHeight = textHeight;\n    } else {\n      textHeight = this.getCacheHeight(danmaku, paint);\n      danmaku.lines.forEach((tempStr: string) => {\n        if (tempStr.length > 0) {\n          let tr: number = measureTextWidth(tempStr, paint);\n          w = Math.max(tr, w);\n        }\n      })\n      danmaku.paintWidth = w;\n      danmaku.paintHeight = danmaku.lines.length * textHeight;\n    }\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void drawStroke(BaseDanmaku danmaku, String lineText, Canvas canvas, float left, float top, Paint paint) {\n        if (lineText != null) {\n            canvas.drawText(lineText, left, top, paint);\n        } else {\n            canvas.drawText(danmaku.text.toString(), left, top, paint);\n        }\n    }",
        "TranslatedCode": "protected drawStroke(danmaku: BaseDanmaku, lineText: string|null, canvas: CanvasRenderingContext2D, left: number, top: number, paint: Paint) {\n    if (lineText != null) {\n      applyPaintToCanvas(paint, canvas)\n      canvas.fillText(lineText, left, top);\n    } else {\n      applyPaintToCanvas(paint, canvas)\n      canvas.fillText(danmaku.text.toString(), left, top);\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void drawText(BaseDanmaku danmaku, String lineText, Canvas canvas, float left, float top, TextPaint paint, boolean fromWorkerThread) {\n        if (fromWorkerThread && danmaku instanceof SpecialDanmaku) {\n            paint.setAlpha(255);\n        }\n        if (lineText != null) {\n            canvas.drawText(lineText, left, top, paint);\n        } else {\n            canvas.drawText(danmaku.text.toString(), left, top, paint);\n        }\n    }",
        "TranslatedCode": "protected drawText(danmaku: BaseDanmaku, lineText: string|null, canvas: CanvasRenderingContext2D, left: number, top: number, paint: Paint, fromWorkerThread: boolean,  displayerConfig: DisplayerConfig) {\n    if (fromWorkerThread && danmaku instanceof SpecialDanmaku) {\n      paint.setAlpha(255);\n    }\n    if (lineText != null) {\n      applyPaintToCanvas(paint, canvas)\n      canvas.fillText(lineText, left, top);\n    } else {\n      applyPaintToCanvas(paint, canvas)\n      canvas.fillText(danmaku.text.toString(), left, top);\n    }\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void drawDanmaku(BaseDanmaku danmaku, Canvas canvas, float left, float top, boolean fromWorkerThread, AndroidDisplayer.DisplayerConfig displayerConfig) {\n        float _left = left;\n        float _top = top;\n        left += danmaku.padding;\n        top += danmaku.padding;\n        if (danmaku.borderColor != 0) {\n            left += displayerConfig.BORDER_WIDTH;\n            top += displayerConfig.BORDER_WIDTH;\n        }\n\n        displayerConfig.definePaintParams(fromWorkerThread);\n        TextPaint paint = displayerConfig.getPaint(danmaku, fromWorkerThread);\n        drawBackground(danmaku, canvas, _left, _top);\n        if (danmaku.lines != null) {\n            String[] lines = danmaku.lines;\n            if (lines.length == 1) {\n                if (displayerConfig.hasStroke(danmaku)) {\n                    displayerConfig.applyPaintConfig(danmaku, paint, true);\n                    float strokeLeft = left;\n                    float strokeTop = top - paint.ascent();\n                    if (displayerConfig.HAS_PROJECTION) {\n                        strokeLeft += displayerConfig.sProjectionOffsetX;\n                        strokeTop += displayerConfig.sProjectionOffsetY;\n                    }\n                    drawStroke(danmaku, lines[0], canvas, strokeLeft, strokeTop, paint);\n                }\n                displayerConfig.applyPaintConfig(danmaku, paint, false);\n                drawText(danmaku, lines[0], canvas, left, top - paint.ascent(), paint, fromWorkerThread);\n            } else {\n                float textHeight = (danmaku.paintHeight - 2 * danmaku.padding) / lines.length;\n                for (int t = 0; t < lines.length; t++) {\n                    if (lines[t] == null || lines[t].length() == 0) {\n                        continue;\n                    }\n                    if (displayerConfig.hasStroke(danmaku)) {\n                        displayerConfig.applyPaintConfig(danmaku, paint, true);\n                        float strokeLeft = left;\n                        float strokeTop = t * textHeight + top - paint.ascent();\n                        if (displayerConfig.HAS_PROJECTION) {\n                            strokeLeft += displayerConfig.sProjectionOffsetX;\n                            strokeTop += displayerConfig.sProjectionOffsetY;\n                        }\n                        drawStroke(danmaku, lines[t], canvas, strokeLeft, strokeTop, paint);\n                    }\n                    displayerConfig.applyPaintConfig(danmaku, paint, false);\n                    drawText(danmaku, lines[t], canvas, left, t * textHeight + top - paint.ascent(), paint, fromWorkerThread);\n                }\n            }\n        } else {\n            if (displayerConfig.hasStroke(danmaku)) {\n                displayerConfig.applyPaintConfig(danmaku, paint, true);\n                float strokeLeft = left;\n                float strokeTop = top - paint.ascent();\n\n                if (displayerConfig.HAS_PROJECTION) {\n                    strokeLeft += displayerConfig.sProjectionOffsetX;\n                    strokeTop += displayerConfig.sProjectionOffsetY;\n                }\n                drawStroke(danmaku, null, canvas, strokeLeft, strokeTop, paint);\n            }\n\n            displayerConfig.applyPaintConfig(danmaku, paint, false);\n            drawText(danmaku, null, canvas, left, top - paint.ascent(), paint, fromWorkerThread);\n        }\n\n        // draw underline\n        if (danmaku.underlineColor != 0) {\n            Paint linePaint = displayerConfig.getUnderlinePaint(danmaku);\n            float bottom = _top + danmaku.paintHeight - displayerConfig.UNDERLINE_HEIGHT;\n            canvas.drawLine(_left, bottom, _left + danmaku.paintWidth, bottom, linePaint);\n        }\n\n        //draw border\n        if (danmaku.borderColor != 0) {\n            Paint borderPaint = displayerConfig.getBorderPaint(danmaku);\n            canvas.drawRect(_left, _top, _left + danmaku.paintWidth, _top + danmaku.paintHeight,\n                    borderPaint);\n        }\n\n    }",
        "TranslatedCode": "public drawDanmaku(danmaku: BaseDanmaku, canvas: CanvasRenderingContext2D, left: number, top: number, fromWorkerThread: boolean, displayerConfig: DisplayerConfig) {\n    let _left: number = left;\n    let _top: number = top;\n    left += danmaku.padding;\n    top += danmaku.padding;\n    if (danmaku.borderColor != 0) {\n      left += displayerConfig.BORDER_WIDTH;\n      top += displayerConfig.BORDER_WIDTH;\n    }\n\n\n    displayerConfig.definePaintParams(fromWorkerThread);\n    let paint: Paint = displayerConfig.getPaint(danmaku, fromWorkerThread);\n    this.drawBackground(danmaku, canvas, _left, _top);\n    let ascent = measureTextHeight(paint) * -0.9\n    if (danmaku.lines != null) {\n      let lines: string[] = danmaku.lines;\n      if (lines.length == 1) {\n        if (displayerConfig.hasStroke(danmaku)) {\n          displayerConfig.applyPaintConfig(danmaku, paint, true);\n          let strokeLeft: number = left;\n          let strokeTop: number = top - ascent;\n          if (displayerConfig.HAS_PROJECTION) {\n            strokeLeft += displayerConfig.sProjectionOffsetX;\n            strokeTop += displayerConfig.sProjectionOffsetY;\n          }\n          this.drawStroke(danmaku, lines[0], canvas, strokeLeft, strokeTop, paint);\n        }\n        displayerConfig.applyPaintConfig(danmaku, paint, false);\n        this.drawText(danmaku, lines[0], canvas, left, top - ascent, paint, fromWorkerThread, displayerConfig);\n      } else {\n        let textHeight: number = (danmaku.paintHeight - 2 * danmaku.padding) / lines.length;\n        let t: number = 0\n        for (t; t < lines.length; t++) {\n          if (lines[t] == null || lines[t].length == 0) {\n            continue;\n          }\n          if (displayerConfig.hasStroke(danmaku)) {\n            displayerConfig.applyPaintConfig(danmaku, paint, true);\n            let strokeLeft: number = left;\n            let strokeTop: number = t * textHeight + top - ascent;\n            if (displayerConfig.HAS_PROJECTION) {\n              strokeLeft += displayerConfig.sProjectionOffsetX;\n              strokeTop += displayerConfig.sProjectionOffsetY;\n            }\n            this.drawStroke(danmaku, lines[t], canvas, strokeLeft, strokeTop, paint);\n          }\n          displayerConfig.applyPaintConfig(danmaku, paint, false);\n          this.drawText(danmaku, lines[t], canvas, left, t * textHeight + top - ascent, paint, fromWorkerThread, displayerConfig);\n        }\n      }\n    } else {\n      if (displayerConfig.hasStroke(danmaku)) {\n        displayerConfig.applyPaintConfig(danmaku, paint, true);\n        let strokeLeft: number = left;\n        let strokeTop: number = top - ascent;\n\n        if (displayerConfig.HAS_PROJECTION) {\n          strokeLeft += displayerConfig.sProjectionOffsetX;\n          strokeTop += displayerConfig.sProjectionOffsetY;\n        }\n        this.drawStroke(danmaku, null, canvas, strokeLeft, strokeTop, paint);\n      }\n\n      displayerConfig.applyPaintConfig(danmaku, paint, false);\n      this.drawText(danmaku, null, canvas, left, top - ascent, paint, fromWorkerThread, displayerConfig);\n    }\n\n    // draw underline\n    if (danmaku.underlineColor != 0) {\n      let linePaint: Paint = displayerConfig.getUnderlinePaint(danmaku);\n      let bottom: number = _top + danmaku.paintHeight - displayerConfig.UNDERLINE_HEIGHT;\n      let path: Path2D = new Path2D('M' + vp2px(_left) + ' ' + vp2px(bottom) + ' ' + 'L' + vp2px(_left + danmaku.paintWidth) + ' ' + vp2px(bottom))\n      applyPaintToCanvas(linePaint, canvas)\n      canvas.stroke(path)\n    }\n    //draw border\n    if (danmaku.borderColor != 0) {\n      let borderPaint: Paint = displayerConfig.getBorderPaint(danmaku);\n      applyPaintToCanvas(borderPaint, canvas)\n      canvas.strokeRect(_left, _top, danmaku.paintWidth, danmaku.paintHeight)\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void handleMessage(Message msg) {\n        int what = msg.what;\n        switch (what) {\n            case PREPARE:\n                mTimeBase = SystemClock.uptimeMillis();\n                if (mParser == null || !mDanmakuView.isViewReady()) {\n                    sendEmptyMessageDelayed(PREPARE, 100);\n                } else {\n                    prepare(new Runnable() {\n                        @Override\n                        public void run() {\n                            pausedPosition = 0;\n                            mReady = true;\n                            if (mCallback != null) {\n                                mCallback.prepared();\n                            }\n                        }\n                    });\n                }\n                break;\n            case SHOW_DANMAKUS:\n                mDanmakusVisible = true;\n                Long start = (Long) msg.obj;\n                boolean resume = false;\n                if (drawTask != null) {\n                    if (start == null) {\n                        timer.update(getCurrentTime());\n                        drawTask.requestClear();\n                    } else {\n                        drawTask.start();\n                        drawTask.seek(start);\n                        drawTask.requestClear();\n                        resume = true;\n                    }\n                }\n                if (quitFlag && mDanmakuView != null) {\n                    mDanmakuView.drawDanmakus();\n                }\n                notifyRendering();\n                if (!resume) {\n                    break;\n                }\n            case START:\n                Long startTime = (Long) msg.obj;\n                if (startTime != null) {\n                    pausedPosition = startTime;\n                } else {\n                    pausedPosition = 0;\n                }\n            case SEEK_POS:\n                if (what == SEEK_POS) {\n                    quitFlag = true;\n                    quitUpdateThread();\n                    Long position = (Long) msg.obj;\n                    long deltaMs = position - timer.currMillisecond;\n                    mTimeBase -= deltaMs;\n                    timer.update(position);\n                    mContext.mGlobalFlagValues.updateMeasureFlag();\n                    if (drawTask != null)\n                        drawTask.seek(position);\n                    pausedPosition = position;\n                }\n            case RESUME:\n                removeMessages(DrawHandler.PAUSE);\n                quitFlag = false;\n                if (mReady) {\n                    mRenderingState.reset();\n                    mDrawTimes.clear();\n                    mTimeBase = SystemClock.uptimeMillis() - pausedPosition;\n                    timer.update(pausedPosition);\n                    removeMessages(RESUME);\n                    sendEmptyMessage(UPDATE);\n                    drawTask.start();\n                    notifyRendering();\n                    mInSeekingAction = false;\n                    if (drawTask != null) {\n                        drawTask.onPlayStateChanged(IDrawTask.PLAY_STATE_PLAYING);\n                    }\n                } else {\n                    sendEmptyMessageDelayed(RESUME, 100);\n                }\n                break;\n            case UPDATE:\n                if (mContext.updateMethod == 0) {\n                    updateInChoreographer();\n                } else if (mContext.updateMethod == 1) {\n                    updateInNewThread();\n                } else if (mContext.updateMethod == 2) {\n                    updateInCurrentThread();\n                }\n                break;\n            case NOTIFY_DISP_SIZE_CHANGED:\n                mContext.mDanmakuFactory.notifyDispSizeChanged(mContext);\n                Boolean updateFlag = (Boolean) msg.obj;\n                if (updateFlag != null && updateFlag) {\n                    mContext.mGlobalFlagValues.updateMeasureFlag();\n                    mContext.mGlobalFlagValues.updateVisibleFlag();\n                    drawTask.requestClearRetainer();\n                }\n                break;\n            case HIDE_DANMAKUS:\n                mDanmakusVisible = false;\n                if (mDanmakuView != null) {\n                    mDanmakuView.clear();\n                }\n                if(this.drawTask != null) {\n                    this.drawTask.requestClear();\n                    this.drawTask.requestHide();\n                }\n                Boolean quitDrawTask = (Boolean) msg.obj;\n                if (quitDrawTask && this.drawTask != null) {\n                    this.drawTask.quit();\n                }\n                if (!quitDrawTask) {\n                    break;\n                }\n            case PAUSE:\n                removeMessages(DrawHandler.RESUME);\n                removeMessages(UPDATE);\n                if (drawTask != null) {\n                    drawTask.onPlayStateChanged(IDrawTask.PLAY_STATE_PAUSE);\n                }\n            case QUIT:\n                if (what == QUIT) {\n                    removeCallbacksAndMessages(null);\n                }\n                quitFlag = true;\n                syncTimerIfNeeded();\n                pausedPosition = timer.currMillisecond;\n                if (mUpdateInSeparateThread) {\n                    notifyRendering();\n                    quitUpdateThread();\n                }\n                if (mFrameCallback != null) {\n                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {\n                        Choreographer.getInstance().removeFrameCallback(mFrameCallback);\n                    }\n                }\n                if (what == QUIT){\n                    if (this.drawTask != null){\n                        this.drawTask.quit();\n                    }\n                    if (mParser != null) {\n                        mParser.release();\n                    }\n                    if (this.getLooper() != Looper.getMainLooper())\n                        this.getLooper().quit();\n                }\n                break;\n            case NOTIFY_RENDERING:\n                notifyRendering();\n                break;\n            case UPDATE_WHEN_PAUSED:\n                if (quitFlag && mDanmakuView != null) {\n                    drawTask.requestClear();\n                    mDanmakuView.drawDanmakus();\n                    notifyRendering();\n                }\n                break;\n            case CLEAR_DANMAKUS_ON_SCREEN:\n                if (drawTask != null) {\n                    drawTask.clearDanmakusOnScreen(getCurrentTime());\n                }\n                break;\n            case FORCE_RENDER:\n                if (drawTask != null) {\n                    drawTask.requestRender();\n                }\n                break;\n        }\n    }",
        "TranslatedCode": "public handleMessage(msg: Message): void {\n    let what: number = msg.what;\n    switch (what) {\n      case PREPARE:\n        this.mTimeBase = SystemClock.uptimeMillis();\n        if (this.mParser == null || !this.mDanmakuView.isViewReady()) {\n          this.sendEmptyMessageDelayed(PREPARE, 100);\n        } else {\n          this.prepareInner(() => {\n            this.pausedPosition = 0;\n            this.mReady = true;\n            if (this.mCallback) {\n              this.mCallback.prepared();\n            }\n          }\n          );\n        }\n        break;\n      case SHOW_DANMAKUS:\n        this.mDanmakusVisible = true;\n        let start: number = msg.obj as number;\n        let resume: boolean = false;\n        if (this.drawTask != null) {\n          if (start === null) {\n            this.timer.update(this.getCurrentTime());\n            this.drawTask.requestClear();\n          } else {\n            this.drawTask.start();\n            this.drawTask.seek(start);\n            this.drawTask.requestClear();\n            resume = true;\n          }\n        }\n        if (this.quitFlag && this.mDanmakuView != null) {\n          this.mDanmakuView.drawDanmakus();\n        }\n        this.notifyRendering();\n        if (!resume) {\n          break;\n        }\n      case START:\n        let startTime: number = msg.obj as number;\n        if (startTime != null) {\n          this.pausedPosition = startTime;\n        } else {\n          this.pausedPosition = 0;\n        }\n      case SEEK_POS:\n        if (what == SEEK_POS) {\n          this.quitFlag = true;\n          let position: number = msg.obj as number;\n          let deltaMs: number = position - this.timer.currMillisecond;\n          this.mTimeBase -= deltaMs;\n          this.timer.update(position);\n          this.mContext.mGlobalFlagValues.updateMeasureFlag();\n          if (this.drawTask != null)\n          this.drawTask.seek(position);\n          this.pausedPosition = position;\n        }\n      case RESUME:\n        this.removeMessages(PAUSE);\n        this.quitFlag = false;\n        if (this.mReady) {\n          this.mRenderingState.reset();\n          this.mDrawTimes.length = 0;\n          this.mTimeBase = SystemClock.uptimeMillis() - this.pausedPosition;\n          this.timer.update(this.pausedPosition);\n          this.removeMessages(RESUME);\n          this.sendEmptyMessage(UPDATE);\n          this.drawTask.start();\n          this.notifyRendering();\n          this.mInSeekingAction = false;\n          if (this.drawTask != null) {\n            this.drawTask.onPlayStateChanged(PLAY_STATE_PLAYING);\n          }\n        } else {\n          this.sendEmptyMessageDelayed(RESUME, 100);\n        }\n        break;\n      case UPDATE:\n        this.updateInCurrentThread();\n        break;\n      case NOTIFY_DISP_SIZE_CHANGED:\n        this.mContext.mDanmakuFactory.notifyDispSizeChanged(this.mContext);\n        let updateFlag: boolean = msg.obj as boolean;\n        if (updateFlag != null && updateFlag) {\n          this.mContext.mGlobalFlagValues.updateMeasureFlag();\n          this.mContext.mGlobalFlagValues.updateVisibleFlag();\n          this.drawTask.requestClearRetainer();\n        }\n        break;\n      case HIDE_DANMAKUS:\n        this.mDanmakusVisible = false;\n        if (this.mDanmakuView != null) {\n          this.mDanmakuView.clear();\n        }\n        if (this.drawTask != null) {\n          this.drawTask.requestClear();\n          this.drawTask.requestHide();\n        }\n        let quitDrawTask: boolean = msg.obj as boolean;\n        if (quitDrawTask && this.drawTask != null) {\n          this.drawTask.quit();\n        }\n        if (!quitDrawTask) {\n          break;\n        }\n      case PAUSE:\n        this.removeMessages(RESUME);\n        this.removeMessages(UPDATE);\n        if (this.drawTask != null) {\n          this.drawTask.onPlayStateChanged(PLAY_STATE_PAUSE);\n        }\n      case QUIT:\n        if (what == QUIT) {\n          this.removeCallbacksAndMessages();\n        }\n        this.quitFlag = true;\n        this.syncTimerIfNeeded();\n        this.pausedPosition = this.timer.currMillisecond;\n        if (what == QUIT) {\n          if (this.drawTask != null) {\n            this.drawTask.quit();\n          }\n          if (this.mParser != null) {\n            this.mParser.release();\n          }\n        }\n        break;\n      case NOTIFY_RENDERING:\n        this.notifyRendering();\n        break;\n      case UPDATE_WHEN_PAUSED:\n        if (this.quitFlag && this.mDanmakuView != null) {\n          this.drawTask.requestClear();\n          this.mDanmakuView.drawDanmakus();\n          this.notifyRendering();\n        }\n        break;\n      case CLEAR_DANMAKUS_ON_SCREEN:\n        if (this.drawTask != null) {\n          this.drawTask.clearDanmakusOnScreen(this.getCurrentTime());\n        }\n        break;\n      case FORCE_RENDER:\n        if (this.drawTask != null) {\n          this.drawTask.requestRender();\n        }\n        break;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private void updateInCurrentThread() {\n        if (quitFlag) {\n            return;\n        }\n        long startMS = SystemClock.uptimeMillis();\n        long d = syncTimer(startMS);\n        if (d < 0 && !mNonBlockModeEnable) {\n            removeMessages(UPDATE);\n            sendEmptyMessageDelayed(UPDATE, 60 - d);\n            return;\n        }\n        d = mDanmakuView.drawDanmakus();\n        removeMessages(UPDATE);\n        if (d > mCordonTime2) {  // this situation may be cuased by ui-thread waiting of DanmakuView, so we sync-timer at once\n            timer.add(d);\n            mDrawTimes.clear();\n        }\n        if (!mDanmakusVisible) {\n            waitRendering(INDEFINITE_TIME);\n            return;\n        } else if (mRenderingState.nothingRendered && mIdleSleep) {\n            long dTime = mRenderingState.endTime - timer.currMillisecond;\n            if (dTime > 500) {\n                waitRendering(dTime - 10);\n                return;\n            }\n        }\n\n        if (d < mFrameUpdateRate) {\n            sendEmptyMessageDelayed(UPDATE, mFrameUpdateRate - d);\n            return;\n        }\n        sendEmptyMessage(UPDATE);\n    }",
        "TranslatedCode": "private updateInCurrentThread(): void {\n    if (this.quitFlag) {\n      return;\n    }\n    let startMS: number = SystemClock.uptimeMillis();\n    let d: number = this.syncTimer(startMS);\n    if (d < 0 && !this.mNonBlockModeEnable) {\n      this.removeMessages(UPDATE);\n      this.sendEmptyMessageDelayed(UPDATE, 60 - d);\n      return;\n    }\n    d = this.mDanmakuView.drawDanmakus();\n    this.removeMessages(UPDATE);\n    if (d > this.mCordonTime2) { // this situation may be cased by ui-thread waiting of DanmakuView, so we sync-timer at once\n      this.timer.add(d);\n      this.mDrawTimes.length = 0;\n    }\n    if (!this.mDanmakusVisible) {\n      this.waitRendering(INDEFINITE_TIME);\n      return;\n    }\n    else if (this.mRenderingState.nothingRendered) {\n      let dTime: number = this.mRenderingState.endTime - this.timer.currMillisecond;\n      if (dTime > 500) {\n        this.waitRendering(dTime - 10);\n        return;\n      }\n    }\n\n    if (d < this.mFrameUpdateRate) {\n      let date: Date = new Date()\n      this.sendEmptyMessageDelayed(UPDATE, this.mFrameUpdateRate - d);\n      return;\n    }\n    this.sendEmptyMessage(UPDATE);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private final long syncTimer(long startMS) {\n        if (mInSeekingAction || mInSyncAction) {\n            return 0;\n        }\n        mInSyncAction = true;\n        long d = 0;\n        long time = startMS - mTimeBase;\n        if (mNonBlockModeEnable) {\n            if (mCallback != null) {\n                mCallback.updateTimer(timer);\n                d = timer.lastInterval();\n            }\n        } else if (!mDanmakusVisible || mRenderingState.nothingRendered || mInWaitingState) {\n            timer.update(time);\n            mRemainingTime = 0;\n            if (mCallback != null) {\n                mCallback.updateTimer(timer);\n            }\n        } else {\n            long gapTime = time - timer.currMillisecond;\n            long averageTime = Math.max(mFrameUpdateRate, getAverageRenderingTime());\n            if (gapTime > 2000 || mRenderingState.consumingTime > mCordonTime || averageTime > mCordonTime) {\n                d = gapTime;\n                gapTime = 0;\n            } else {\n                d = averageTime + gapTime / mFrameUpdateRate;\n                d = Math.max(mFrameUpdateRate, d);\n                d = Math.min(mCordonTime, d);\n                long a = d - mLastDeltaTime;\n                if (a > 3 && a < 8 && mLastDeltaTime >= mFrameUpdateRate && mLastDeltaTime <= mCordonTime) {\n                    d = mLastDeltaTime;\n                }\n                gapTime -= d;\n                mLastDeltaTime = d;\n            }\n            mRemainingTime = gapTime;\n            timer.add(d);\n            if (mCallback != null) {\n                mCallback.updateTimer(timer);\n            }\n\n        }\n\n        mInSyncAction = false;\n        return d;\n    }",
        "TranslatedCode": "private syncTimer(startMS: number): number {\n    if (this.mInSeekingAction || this.mInSyncAction) {\n      return 0;\n    }\n    this.mInSyncAction = true;\n    let d: number = 0;\n    let time: number = startMS - this.mTimeBase;\n    if (this.mNonBlockModeEnable) {\n      if (this.mCallback != null) {\n        this.mCallback.updateTimer(this.timer);\n        d = this.timer.getLastInterval();\n      }\n    } else if (!this.mDanmakusVisible || this.mRenderingState.nothingRendered || this.mInWaitingState) {\n      this.timer.update(time);\n      this.mRemainingTime = 0;\n      if (this.mCallback != null) {\n        this.mCallback.updateTimer(this.timer);\n      }\n    } else {\n      let gapTime: number = time - this.timer.currMillisecond;\n      let averageTime: number = Math.max(this.mFrameUpdateRate, this.getAverageRenderingTime());\n      if (gapTime > 2000 || this.mRenderingState.consumingTime > this.mCordonTime || averageTime > this.mCordonTime) {\n        d = gapTime;\n        gapTime = 0;\n      } else {\n        d = averageTime + gapTime / this.mFrameUpdateRate;\n        d = Math.max(this.mFrameUpdateRate, d);\n        d = Math.min(this.mCordonTime, d);\n        let a: number = d - this.mLastDeltaTime;\n        if (a > 3 && a < 8 && this.mLastDeltaTime >= this.mFrameUpdateRate && this.mLastDeltaTime <= this.mCordonTime) {\n          d = this.mLastDeltaTime;\n        }\n        gapTime -= d;\n        this.mLastDeltaTime = d;\n      }\n      this.mRemainingTime = gapTime;\n      this.timer.add(d);\n      if (this.mCallback != null) {\n        this.mCallback.updateTimer(this.timer);\n      }\n    }\n\n    this.mInSyncAction = false;\n    return d;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void invalidateDanmaku(BaseDanmaku item, boolean remeasure) {\n        if (drawTask != null && item != null) {\n            drawTask.invalidateDanmaku(item, remeasure);\n        }\n        redrawIfNeeded();\n    }",
        "TranslatedCode": "public invalidateDanmaku(item: BaseDanmaku, remeasure: boolean): void {\n    if (this.drawTask != null && item != null) {\n      this.drawTask.invalidateDanmaku(item, remeasure);\n    }\n    this.redrawIfNeeded();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public long hideDanmakus(boolean quitDrawTask) {\n        if (!mDanmakusVisible)\n            return timer.currMillisecond;\n        mDanmakusVisible = false;\n        removeMessages(SHOW_DANMAKUS);\n        removeMessages(HIDE_DANMAKUS);\n        obtainMessage(HIDE_DANMAKUS, quitDrawTask).sendToTarget();\n        return timer.currMillisecond;\n    }",
        "TranslatedCode": "public hideDanmakus(quitDrawTask: boolean): number {\n    if (!this.mDanmakusVisible) {\n      return this.timer.currMillisecond;\n    }\n    this.mDanmakusVisible = false;\n    this.removeMessages(SHOW_DANMAKUS);\n    this.removeMessages(HIDE_DANMAKUS);\n    this.sendMessage(new Message({ what: HIDE_DANMAKUS, obj: quitDrawTask }))\n    return this.timer.currMillisecond;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private synchronized long getAverageRenderingTime() {\n        int frames = mDrawTimes.size();\n        if(frames <= 0)\n            return 0;\n        Long first = mDrawTimes.peekFirst();\n        Long last = mDrawTimes.peekLast();\n        if (first == null || last == null) {\n            return 0;\n        }\n        long dtime = last - first;\n        return dtime / frames;\n    }",
        "TranslatedCode": "private getAverageRenderingTime(): number {\n    let frames: number = this.mDrawTimes.length;\n    if (frames <= 0)\n    return 0;\n    let first: number = this.mDrawTimes[0]\n    let last: number = this.mDrawTimes[this.mDrawTimes.length-1];\n    let dtime: number = last - first;\n    return dtime / frames;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private synchronized void recordRenderingTime() {\n        long lastTime = SystemClock.uptimeMillis();\n        mDrawTimes.addLast(lastTime);\n        int frames = mDrawTimes.size();\n        if (frames > MAX_RECORD_SIZE) {\n            mDrawTimes.removeFirst();\n            frames = MAX_RECORD_SIZE;\n        }\n    }",
        "TranslatedCode": "private recordRenderingTime(): void {\n    let lastTime: number = SystemClock.uptimeMillis();\n    this.mDrawTimes.push(lastTime);\n    let frames = this.mDrawTimes.length;\n    if (frames > MAX_RECORD_SIZE) {\n      this.mDrawTimes.shift()\n      frames = MAX_RECORD_SIZE;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void notifyDispSizeChanged(int width, int height) {\n        if (mDisp == null) {\n            return;\n        }\n        if (mDisp.getWidth() != width || mDisp.getHeight() != height) {\n            mDisp.setSize(width, height);\n            obtainMessage(NOTIFY_DISP_SIZE_CHANGED, true).sendToTarget();\n        }\n    }\n",
        "TranslatedCode": "public notifyDispSizeChanged(width: number, height: number): void {\n    if (this.mDisp == null) {\n      return;\n    }\n    if (this.mDisp.getWidth() != width || this.mDisp.getHeight() != height) {\n      this.mDisp.setSize(width, height);\n      this.sendMessage(new Message({ what: NOTIFY_DISP_SIZE_CHANGED, obj: true }))\n    }\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public long getCurrentTime() {\n        if (!mReady) {\n            return 0;\n        }\n        if (mInSeekingAction) {\n            return mDesireSeekingTime;\n        }\n        if (quitFlag || !mInWaitingState) {\n            return timer.currMillisecond - mRemainingTime;\n        }\n        return SystemClock.uptimeMillis() - mTimeBase;\n    }",
        "TranslatedCode": "public getCurrentTime(): number {\n    if (!this.mReady) {\n      return 0;\n    }\n    if (this.mInSeekingAction) {\n      return this.mDesireSeekingTime;\n    }\n    if (this.quitFlag || !this.mInWaitingState) {\n      return this.timer.currMillisecond - this.mRemainingTime;\n    }\n    return SystemClock.uptimeMillis() - this.mTimeBase;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "private static void clearCanvas(Canvas canvas, RectF rect) {\n        if (rect.width() <= 0 || rect.height() <= 0) {\n            return;\n        }\n        canvas.drawRect(rect, PAINT);\n    }",
        "TranslatedCode": "private static clearCanvasByRectF(canvas: CanvasRenderingContext2D, rect: RectF): void {\n    if (rect.width() <= 0 || rect.height() <= 0) {\n      return;\n    }\n    canvas.clearRect(rect.left, rect.top, rect.width(), rect.height());\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void initTimer(DanmakuTimer timer) {\n        mTimer = timer;\n    }",
        "TranslatedCode": "protected initTimer(timer: DanmakuTimer): void {\n    this.mTimer = timer;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public synchronized void addDanmaku(BaseDanmaku item) {\n        if (danmakuList == null)\n            return;\n        if (item.isLive) {\n            mLiveDanmakus.addItem(item);\n            removeUnusedLiveDanmakusIn(10);\n        }\n        item.index = danmakuList.size();\n        boolean subAdded = true;\n        if (mLastBeginMills <= item.getActualTime() && item.getActualTime() <= mLastEndMills) {\n            synchronized (danmakus) {\n                subAdded = danmakus.addItem(item);\n            }\n        } else if (item.isLive) {\n            subAdded = false;\n        }\n        boolean added = false;\n        synchronized (danmakuList) {\n            added = danmakuList.addItem(item);\n        }\n        if (!subAdded || !added) {\n            mLastBeginMills = mLastEndMills = 0;\n        }\n        if (added && mTaskListener != null) {\n            mTaskListener.onDanmakuAdd(item);\n        }\n        if (mLastDanmaku == null || (item != null && mLastDanmaku != null && item.getActualTime() > mLastDanmaku.getActualTime())) {\n            mLastDanmaku = item;\n        }\n    }",
        "TranslatedCode": "public addDanmaku(item: BaseDanmaku): void {\n    if (this.danmakuList === null)\n      return;\n    if (item.isLive) {\n      this.mLiveDanmakus.addItem(item);\n      this.removeUnusedLiveDanmakusIn(10);\n    }\n    item.index = this.danmakuList.size();\n    let subAdded: boolean = true;\n    if (this.mLastBeginMills <= item.getActualTime() && item.getActualTime() <= this.mLastEndMills) {\n      subAdded = this.danmakus.addItem(item);\n    } else if (item.isLive) {\n      subAdded = false;\n    }\n    let added: boolean = false;\n    added = this.danmakuList.addItem(item);\n    if (!subAdded || !added) {\n      this.mLastBeginMills = this.mLastEndMills = 0;\n    }\n    if (added && this.mTaskListener != null) {\n      this.mTaskListener.onDanmakuAdd(item);\n    }\n    if (this.mLastDanmaku == null || (item != null && this.mLastDanmaku != null && item.getActualTime() > this.mLastDanmaku.getActualTime())) {\n      this.mLastDanmaku = item;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void invalidateDanmaku(BaseDanmaku item, boolean remeasure) {\n        mContext.getDisplayer().getCacheStuffer().clearCache(item);\n        item.requestFlags |= BaseDanmaku.FLAG_REQUEST_INVALIDATE;\n        if (remeasure) {\n            item.paintWidth = -1;\n            item.paintHeight = -1;\n            item.requestFlags |= BaseDanmaku.FLAG_REQUEST_REMEASURE;\n            item.measureResetFlag++;\n        }\n    }",
        "TranslatedCode": "public invalidateDanmaku(item: BaseDanmaku, remeasure: boolean): void {\n    this.mContext.getDisplayer().getCacheStuffer().clearCache(item);\n    item.requestFlags |= BaseDanmaku.FLAG_REQUEST_INVALIDATE;\n    if (remeasure) {\n      item.paintWidth = -1;\n      item.paintHeight = -1;\n      item.requestFlags |= BaseDanmaku.FLAG_REQUEST_REMEASURE;\n      item.measureResetFlag++;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public synchronized void removeAllDanmakus(boolean isClearDanmakusOnScreen) {\n        if (danmakuList == null || danmakuList.isEmpty())\n            return;\n        synchronized (danmakuList) {\n            if (!isClearDanmakusOnScreen) {\n                long beginMills = mTimer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - 100;\n                long endMills = mTimer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;\n                IDanmakus tempDanmakus = danmakuList.subnew(beginMills, endMills);\n                if (tempDanmakus != null)\n                    danmakus = tempDanmakus;\n            }\n            danmakuList.clear();\n        }\n    }",
        "TranslatedCode": "public removeAllDanmakus(isClearDanmakusOnScreen: boolean): void {\n    if (this.danmakuList === null || this.danmakuList.isEmpty())\n      return;\n    if (!isClearDanmakusOnScreen) {\n      let beginMills: number = this.mTimer.currMillisecond - this.mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - 100;\n      let endMills: number = this.mTimer.currMillisecond + this.mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;\n      let tempDanmakus: IDanmakus = this.danmakuList.subnew(beginMills, endMills);\n      if (tempDanmakus !== null)\n        this.danmakus = tempDanmakus;\n    }\n    this.danmakuList.clear();\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public IDanmakus getVisibleDanmakusOnTime(long time) {\n        long beginMills = time - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - 100;\n        long endMills = time + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;\n        IDanmakus subDanmakus = null;\n        int i = 0;\n        while (i++ < 3) {  //avoid ConcurrentModificationException\n            try {\n                subDanmakus = danmakuList.subnew(beginMills, endMills);\n                break;\n            } catch (Exception e) {\n\n            }\n        }\n        final IDanmakus visibleDanmakus = new Danmakus();\n        if (null != subDanmakus && !subDanmakus.isEmpty()) {\n            subDanmakus.forEachSync(new IDanmakus.DefaultConsumer<BaseDanmaku>() {\n                @Override\n                public int accept(BaseDanmaku danmaku) {\n                    if (danmaku.isShown() && !danmaku.isOutside()) {\n                        visibleDanmakus.addItem(danmaku);\n                    }\n                    return ACTION_CONTINUE;\n                }\n            });\n        }\n\n        return visibleDanmakus;\n    }",
        "TranslatedCode": "public getVisibleDanmakusOnTime(time: number): IDanmakus {\n    let beginMills: number = time - this.mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - 100;\n    let endMills: number = time + this.mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;\n    let subDanmakus: IDanmakus|ESObject = null;\n    let i: number = 0;\n    while (i++ < 3) { //avoid ConcurrentModificationException\n      try {\n        subDanmakus = this.danmakuList.subnew(beginMills, endMills);\n        break;\n      } catch (e) {\n\n      }\n    }\n    let visibleDanmakus: IDanmakus = new Danmakus({});\n    if (null != subDanmakus && !subDanmakus.isEmpty()) {\n      subDanmakus.forEachSync(new SubDanMu(visibleDanmakus));\n    }\n\n    return visibleDanmakus;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void prepare() {\n        if (mParser == null) {\n            return;\n        }\n        loadDanmakus(mParser);\n        mLastBeginMills = mLastEndMills = 0;\n        if (mTaskListener != null) {\n            mTaskListener.ready();\n            mReadyState = true;\n        }\n    }",
        "TranslatedCode": "public prepare(): void {\n    if (this.mParser == null) {\n      return;\n    }\n    this.loadDanmakus(this.mParser);\n    this.mLastBeginMills = this.mLastEndMills = 0;\n    if (this.mTaskListener != null) {\n      this.mTaskListener.ready();\n      this.mReadyState = true;\n    }\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected RenderingState drawDanmakus(AbsDisplayer disp, DanmakuTimer timer) {\n        if (clearRetainerFlag) {\n            mRenderer.clearRetainer();\n            clearRetainerFlag = false;\n        }\n        if (danmakuList != null) {\n            Canvas canvas = (Canvas) disp.getExtraData();\n            DrawHelper.clearCanvas(canvas);\n            if (mIsHidden && !mRequestRender) {\n                return mRenderingState;\n            }\n\n            mRequestRender = false;\n            RenderingState renderingState = mRenderingState;\n            // prepare screenDanmakus\n            long beginMills = timer.currMillisecond - mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - 100;\n            long endMills = timer.currMillisecond + mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;\n            IDanmakus screenDanmakus = danmakus;\n            if(mLastBeginMills > beginMills || timer.currMillisecond > mLastEndMills) {\n                screenDanmakus = danmakuList.sub(beginMills, endMills);\n                if (screenDanmakus != null) {\n                    danmakus = screenDanmakus;\n                }\n                mLastBeginMills = beginMills;\n                mLastEndMills = endMills;\n            } else {\n                beginMills = mLastBeginMills;\n                endMills = mLastEndMills;\n            }\n\n            // prepare runningDanmakus to draw (in sync-mode)\n            IDanmakus runningDanmakus = mRunningDanmakus;\n            beginTracing(renderingState, runningDanmakus, screenDanmakus);\n            if (runningDanmakus != null && !runningDanmakus.isEmpty()) {\n                mRenderingState.isRunningDanmakus = true;\n                mRenderer.draw(disp, runningDanmakus, 0, mRenderingState);\n            }\n\n            // draw screenDanmakus\n            mRenderingState.isRunningDanmakus = false;\n            if (screenDanmakus != null && !screenDanmakus.isEmpty()) {\n                mRenderer.draw(mDisp, screenDanmakus, mStartRenderTime, renderingState);\n                endTracing(renderingState);\n                if (renderingState.nothingRendered) {\n                    if(mLastDanmaku != null && mLastDanmaku.isTimeOut()) {\n                        mLastDanmaku = null;\n                        if (mTaskListener != null) {\n                            mTaskListener.onDanmakusDrawingFinished();\n                        }\n                    }\n                    if (renderingState.beginTime == RenderingState.UNKNOWN_TIME) {\n                        renderingState.beginTime = beginMills;\n                    }\n                    if (renderingState.endTime == RenderingState.UNKNOWN_TIME) {\n                        renderingState.endTime = endMills;\n                    }\n                }\n                return renderingState;\n            } else {\n                renderingState.nothingRendered = true;\n                renderingState.beginTime = beginMills;\n                renderingState.endTime = endMills;\n                return renderingState;\n            }\n        }\n        return null;\n    }\n",
        "TranslatedCode": "protected drawDanmakus(disp: AbsDisplayer<CanvasRenderingContext2D, string>, timer: DanmakuTimer): RenderingState|ESObject {\n    if (this.clearRetainerFlag) {\n      this.mRenderer.clearRetainer();\n      this.clearRetainerFlag = false;\n    }\n    if (this.danmakuList != null) {\n      let canvas: CanvasRenderingContext2D = disp.getExtraData() as CanvasRenderingContext2D;\n      //DrawHelper.clearCanvas(canvas);\n      if (this.mIsHidden && !this.mRequestRender) {\n        return this.mRenderingState;\n      }\n\n      this.mRequestRender = false;\n      let renderingState: RenderingState = this.mRenderingState;\n      // prepare screenDanmakus\n      let beginMills: number = timer.currMillisecond - this.mContext.mDanmakuFactory.MAX_DANMAKU_DURATION - 100;\n      let endMills: number = timer.currMillisecond + this.mContext.mDanmakuFactory.MAX_DANMAKU_DURATION;\n      let screenDanmakus: IDanmakus = this.danmakus;\n      if (this.mLastBeginMills > beginMills || timer.currMillisecond > this.mLastEndMills) {\n        screenDanmakus = this.danmakuList.sub(beginMills, endMills);\n        if (screenDanmakus != null) {\n          this.danmakus = screenDanmakus;\n        }\n        this.mLastBeginMills = beginMills;\n        this.mLastEndMills = endMills;\n      } else {\n        beginMills = this.mLastBeginMills;\n        endMills = this.mLastEndMills;\n      }\n\n      // prepare runningDanmakus to draw (in sync-mode)\n      let runningDanmakus: IDanmakus = this.mRunningDanmakus;\n      this.beginTracing(renderingState, runningDanmakus, screenDanmakus);\n      if (runningDanmakus != null && !runningDanmakus.isEmpty()) {\n        this.mRenderingState.isRunningDanmakus = true;\n        this.mRenderer.draw(disp, runningDanmakus, 0, this.mRenderingState);\n      }\n\n      // draw screenDanmakus\n      this.mRenderingState.isRunningDanmakus = false;\n      if (screenDanmakus != null && !screenDanmakus.isEmpty()) {\n        this.mRenderer.draw(this.mDisp, screenDanmakus, this.mStartRenderTime, renderingState);\n        this.endTracing(renderingState);\n        if (renderingState.nothingRendered) {\n          if (this.mLastDanmaku != null && this.mLastDanmaku.isTimeOut()) {\n            this.mLastDanmaku = null;\n            if (this.mTaskListener != null) {\n              this.mTaskListener.onDanmakusDrawingFinished();\n            }\n          }\n          if (renderingState.beginTime == RenderingState.UNKNOWN_TIME) {\n            renderingState.beginTime = beginMills;\n          }\n          if (renderingState.endTime == RenderingState.UNKNOWN_TIME) {\n            renderingState.endTime = endMills;\n          }\n        }\n        return renderingState;\n      } else {\n        renderingState.nothingRendered = true;\n        renderingState.beginTime = beginMills;\n        renderingState.endTime = endMills;\n        return renderingState;\n      }\n    }\n    return null;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean onDanmakuConfigChanged(DanmakuContext config, DanmakuConfigTag tag,\n            Object... values) {\n        boolean handled = handleOnDanmakuConfigChanged(config, tag, values);\n        if (mTaskListener != null) {\n            mTaskListener.onDanmakuConfigChanged();\n        }\n        return handled;\n    }",
        "TranslatedCode": "public onDanmakuConfigChanged(config: DanmakuContext, tag: DanmakuConfigTag,\n                                values: ESObject[]): boolean {\n    let handled: boolean = this.handleOnDanmakuConfigChanged(config, tag, values);\n    if (this.mTaskListener != null) {\n      this.mTaskListener.onDanmakuConfigChanged();\n    }\n    return handled;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected boolean handleOnDanmakuConfigChanged(DanmakuContext config, DanmakuConfigTag tag, Object[] values) {\n        boolean handled = false;\n        if (tag == null || DanmakuConfigTag.MAXIMUM_NUMS_IN_SCREEN.equals(tag)) {\n            handled = true;\n        } else if (DanmakuConfigTag.DUPLICATE_MERGING_ENABLED.equals(tag)) {\n            Boolean enable = (Boolean) values[0];\n            if (enable != null) {\n                if (enable) {\n                    mContext.mDanmakuFilters.registerFilter(DanmakuFilters.TAG_DUPLICATE_FILTER);\n                } else {\n                    mContext.mDanmakuFilters.unregisterFilter(DanmakuFilters.TAG_DUPLICATE_FILTER);\n                }\n                handled = true;\n            }\n        } else if (DanmakuConfigTag.SCALE_TEXTSIZE.equals(tag) || DanmakuConfigTag.SCROLL_SPEED_FACTOR.equals(tag) || DanmakuConfigTag.DANMAKU_MARGIN.equals(tag)) {\n            requestClearRetainer();\n            handled = false;\n        } else if (DanmakuConfigTag.MAXIMUN_LINES.equals(tag) || DanmakuConfigTag.OVERLAPPING_ENABLE.equals(tag)) {\n            if (mRenderer != null) {\n                mRenderer.setVerifierEnabled(mContext.isPreventOverlappingEnabled() || mContext.isMaxLinesLimited());\n            }\n            handled = true;\n        } else if (DanmakuConfigTag.ALIGN_BOTTOM.equals(tag)) {\n            Boolean enable = (Boolean) values[0];\n            if (enable != null) {\n                if (mRenderer != null) {\n                    mRenderer.alignBottom(enable);\n                }\n                handled = true;\n            }\n        }\n        return handled;\n    }",
        "TranslatedCode": "protected handleOnDanmakuConfigChanged(config: DanmakuContext, tag: DanmakuConfigTag, values: ESObject[]): boolean{\n    let handled: boolean = false;\n    if (tag === null || DanmakuConfigTag.MAXIMUM_NUMS_IN_SCREEN === tag) {\n      handled = true;\n    } else if (DanmakuConfigTag.DUPLICATE_MERGING_ENABLED === tag) {\n      let enable: boolean = values[0] as boolean;\n      if (enable) {\n        this.mContext.mDanmakuFilters.registerFilter({ tag: DanmakuFilters.TAG_DUPLICATE_FILTER });\n      } else {\n        this.mContext.mDanmakuFilters.unregisterFilter({ tag: DanmakuFilters.TAG_DUPLICATE_FILTER });\n      }\n      handled = true;\n    } else if (DanmakuConfigTag.SCALE_TEXTSIZE === tag || DanmakuConfigTag.SCROLL_SPEED_FACTOR === tag || DanmakuConfigTag.DANMAKU_MARGIN === tag) {\n      this.requestClearRetainer();\n      handled = false;\n    } else if (DanmakuConfigTag.MAXIMUN_LINES === tag || DanmakuConfigTag.OVERLAPPING_ENABLE === tag) {\n      if (this.mRenderer != null) {\n        this.mRenderer.setVerifierEnabled(this.mContext.isPreventOverlappingEnabled() || this.mContext.isMaxLinesLimited());\n      }\n      handled = true;\n    } else if (DanmakuConfigTag.ALIGN_BOTTOM === tag) {\n      let enable: boolean = values[0] as boolean;\n      if (this.mRenderer != null) {\n        this.mRenderer.alignBottom(enable);\n      }\n      handled = true;\n    }\n    return handled;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public interface OnDrawableChangeListener {\n        /**\n         * Callback invoked when a new drawable has been\n         * assigned to the view\n         *\n         * @param drawable\n         */\n        void onDrawableChanged(Drawable drawable);\n    }",
        "TranslatedCode": "export interface OnDrawableChangeListener {\n\n  onDrawableChanged(src: Resource | PixelMap | string): void;\n}",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public interface OnLayoutChangeListener {\n        /**\n         * Callback invoked when the layout bounds changed\n         */\n        void onLayoutChanged(boolean changed, int left, int top, int right, int bottom);\n    }",
        "TranslatedCode": "export interface OnLayoutChangeListener {\n\n  onLayoutChanged(changed: boolean, left: number, top: number, right: number, bottom: number): void;\n}",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setOnDrawableChangedListener(OnDrawableChangeListener listener) {\n        mDrawableChangeListener = listener;\n    }",
        "TranslatedCode": "public setOnDrawableChangedListener(listener: OnDrawableChangeListener): void {\n      this.drawableChangeListener = listener;\n    }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void setOnLayoutChangeListener(OnLayoutChangeListener listener) {\n        mOnLayoutChangeListener = listener;\n    }",
        "TranslatedCode": "public setOnLayoutChangeListener(listener: OnLayoutChangeListener): void {\n      this.onLayoutChangeListener = listener;\n    }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Change the display type\n     *\n     * @type\n     */\n    public void setDisplayType(DisplayType type) {\n        if (type != mScaleType) {\n            mUserScaled = false;\n            mScaleType = type;\n            mScaleTypeChanged = true;\n            requestLayout();\n        }\n    }",
        "TranslatedCode": "public setDisplayType(type: DisplayType): void {\n      if (type != this.scaleType) {\n        console.log(\"ImageViewTouch type: \" + type);\n        this.userScaled = false;\n        this.scaleType = type;\n        this.scaleTypeChanged = true;\n        this.setDefaultScale()\n      }\n    }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public ImageViewState(float scale, @NonNull PointF center, int orientation) {\n        this.scale = scale;\n        this.centerX = center.x;\n        this.centerY = center.y;\n        this.orientation = orientation;\n    }",
        "TranslatedCode": "public constructor(scale: number, centerX: number, centerY: number, orientation: number) {\n    this.scale = scale;\n    this.centerX = centerX;\n    this.centerY = centerY;\n    this.orientation = orientation;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public float getScale() {\n        return scale;\n    }",
        "TranslatedCode": "public getScale(): number{\n    return this.scale;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int getOrientation() {\n        return orientation;\n    }",
        "TranslatedCode": "public getOrientation(): number{\n    return this.orientation;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Convert screen to source x coordinate.\n     */\n    private float viewToSourceX(float vx) {\n        if (vTranslate == null) { return Float.NaN; }\n        return (vx - vTranslate.x)/scale;\n    }",
        "TranslatedCode": "public viewToSourceX(vx: number): number {\n      return (vx - this.offsetX) * this.scaledDensity / this.scale;\n    }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Convert screen to source y coordinate.\n     */\n    private float viewToSourceY(float vy) {\n        if (vTranslate == null) { return Float.NaN; }\n        return (vy - vTranslate.y)/scale;\n    }",
        "TranslatedCode": "/**\n     * Convert screen to source y coordinate.\n     */\n    public viewToSourceY(vy: number): number {\n      return (vy - this.offsetY) * this.scaledDensity / this.scale;\n    }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public final void setDoubleTapZoomScale(float doubleTapZoomScale) {\n        this.doubleTapZoomScale = doubleTapZoomScale;\n    }",
        "TranslatedCode": "public setDoubleTapZoomScale(doubleTapZoomScale: number): Model {\n      this.doubleTapZoomScale = doubleTapZoomScale;\n      return this;\n    }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * This is a screen density aware alternative to {@link #setMaxScale(float)}; it allows you to express the maximum\n     * allowed scale in terms of the minimum pixel density. This avoids the problem of 1:1 scale still being\n     * too small on a high density screen. A sensible starting point is 160 - the default used by this view.\n     * @param dpi Source image pixel density at maximum zoom.\n     */\n    public final void setMinimumDpi(int dpi) {\n        DisplayMetrics metrics = getResources().getDisplayMetrics();\n        float averageDpi = (metrics.xdpi + metrics.ydpi)/2;\n        setMaxScale(averageDpi/dpi);\n    }",
        "TranslatedCode": "/**\n     * This is a screen density aware alternative to {@link #setMaxScale(float)}; it allows you to express the maximum\n     * allowed scale in terms of the minimum pixel density. This avoids the problem of 1:1 scale still being\n     * too small on a high density screen. A sensible starting point is 160 - the default used by this view.\n     * @param dpi Source image pixel density at maximum zoom.\n     */\n    public setMinimumDpi(dpi: number): Model {\n      let screen = display.getDefaultDisplaySync()\n      let averageDpi: number = (screen.xDPI + screen.yDPI) / 2\n      this.setMaxScale(averageDpi / dpi);\n      return this;\n    }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * This is a screen density aware alternative to {@link #setMinScale(float)}; it allows you to express the minimum\n     * allowed scale in terms of the maximum pixel density.\n     * @param dpi Source image pixel density at minimum zoom.\n     */\n    public final void setMaximumDpi(int dpi) {\n        DisplayMetrics metrics = getResources().getDisplayMetrics();\n        float averageDpi = (metrics.xdpi + metrics.ydpi)/2;\n        setMinScale(averageDpi / dpi);\n    }",
        "TranslatedCode": "/**\n     * This is a screen density aware alternative to {@link #setMinScale(float)}; it allows you to express the minimum\n     * allowed scale in terms of the maximum pixel density.\n     * @param dpi Source image pixel density at minimum zoom.\n     */\n    public setMaximumDpi(dpi: number): Model {\n      let screen = display.getDefaultDisplaySync()\n      let averageDpi: number = (screen.xDPI + screen.yDPI) / 2\n      this.setMinScale(averageDpi / dpi);\n      return this;\n    }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Get the current state of the view (scale, center, orientation) for restoration after rotate. Will return null if\n     * the view is not ready.\n     * @return an {@link ImageViewState} instance representing the current position of the image. null if the view isn't ready.\n     */\n    @Nullable\n    public final ImageViewState getState() {\n        if (vTranslate != null && sWidth > 0 && sHeight > 0) {\n            //noinspection ConstantConditions\n            return new ImageViewState(getScale(), getCenter(), getOrientation());\n        }\n        return null;\n    }",
        "TranslatedCode": "public getState(): ImageViewState | null {\n      if (this.sWidth > 0 && this.sHeight > 0) {\n        //noinspection ConstantConditions\n        return new ImageViewState(this.getScale(), this.getCenterX(), this.getCenterY(), this.getOrientation());\n      }\n      return new ImageViewState(0, 0, 0, 0);\n    }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Set the pan limiting style. See static fields. Normally {@link #PAN_LIMIT_INSIDE} is best, for image galleries.\n     * @param panLimit a pan limit constant. See static fields.\n     */\n    public final void setPanLimit(int panLimit) {\n        if (!VALID_PAN_LIMITS.contains(panLimit)) {\n            throw new IllegalArgumentException(\"Invalid pan limit: \" + panLimit);\n        }\n        this.panLimit = panLimit;\n        if (isReady()) {\n            fitToBounds(true);\n            invalidate();\n        }\n    }",
        "TranslatedCode": "/**\n     * Set the pan limiting style. See static fields. Normally {@link #PAN_LIMIT_INSIDE} is best, for image galleries.\n     * @param panLimit a pan limit constant. See static fields.\n     */\n    public setPanLimit(panLimit: number): Model {\n      if (panLimit != this.PAN_LIMIT_INSIDE || panLimit != this.PAN_LIMIT_OUTSIDE || panLimit != this.PAN_LIMIT_CENTER) {\n        console.error(\"Invalid pan limit: \" + panLimit)\n      }\n      this.panLimit = panLimit;\n      return this;\n    }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Tests whether the given 32 bits character is valid in XML documents.\n     * Because the majority of code-points is covered by the table-lookup-test,\n     * we do it first.\n     * This method gives meaningful results only for c &gt;= 0.\n     */\n    public static boolean isXMLCharacter(int c) {\n\n        return ( ( ( XML_CHARACTER[c >>> 5 ] & (1 << (c & 0x1F ))) != 0 )\n                || (c >= 0x10000 && c <= 0x10ffff) );\n    }\n/**\n    * The bit array representing a valid XML character in the unicode range [0-FFFF].\n    */\n    public static final int[] XML_CHARACTER = {\n        9728,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,1073741823,\n        };",
        "TranslatedCode": "/*\n * 获取Unicode code\n * @param char 要获取Unicode码的字符\n * @return 对应字符的Unicode码\n */\nexport function getCodePoint(char: string): number {\n  return char.charCodeAt(0) || -1;\n}\n/*\n * 判断字符是否为XML字符\n * @param char 要判断的字符\n * @see https://www.w3.org/TR/xml/ 2.2节\n * @return 是否为XML字符\n */\nexport function isXmlChar(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  return cp === 0x9\n  || cp === 0xA\n  || cp === 0xD\n  || (cp >= 0x20 && cp <= 0xD7FF)\n  || (cp >= 0xE000 && cp <= 0xFFFD)\n  || (cp >= 0x10000 && cp <= 0x10FFFF);\n}",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Tests whether the given character is a valid space.\n     */\n    public static boolean isXMLSpace(char c) {\n      return (c <= 0x0020) &&\n             (((((1L << 0x0009) |\n                 (1L << 0x000A) |\n                 (1L << 0x000D) |\n                 (1L << 0x0020)) >> c) & 1L) != 0);\n    }",
        "TranslatedCode": "/*\n * 判断字符是否为空白\n * @param char 要判断的字符\n * @see https://www.w3.org/TR/xml/ 2.3节 Whitespace\n * @return 是否为空白字符\n */\nexport function isWhitespace(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  return cp === 0x20\n  || cp === 0x9\n  || cp === 0xA\n  || cp === 0xD;\n}",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Tests whether the given character is usable as the\n     * first character of an XML name.\n     */\n    public static boolean isXMLNameFirstCharacter(char c) {\n        return (NAME_FIRST_CHARACTER[c / 32] & (1 << (c % 32))) != 0;\n    }\npublic static final int[] NAME_FIRST_CHARACTER = {\n        0,67108864,-2013265922,134217726,0,0,-8388609,-8388609,-1,2146697215,\n        -514,2147483647,-1,-1,-8177,-63832065,16777215,0,-65536,-1,-1,\n        -134217217,3,0,0,0,0,0,-10432,-5,1417641983,1048573,-8194,-1,\n        -536936449,-1,-65533,-1,-58977,54513663,0,-131072,41943039,-2,127,0,\n        -65536,460799,0,134217726,2046,-131072,-1,2097151999,3112959,96,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,-32,603979775,-16777216,3,-417824,\n        63307263,-1342177280,196611,-423968,57540095,1577058304,1835008,\n        -282656,602799615,0,1,-417824,600702463,-1342177280,3,-700594208,\n        62899992,0,0,-139296,66059775,0,3,-139296,66059775,1073741824,3,\n        -139296,67108351,0,3,0,0,0,0,-2,884735,63,0,-17816170,537750702,31,0,\n        0,0,-257,1023,0,0,0,0,0,0,0,0,0,-1,-65473,8388607,514797,1342177280,\n        -2110697471,2908843,1073741824,-176109312,7,33622016,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,268435455,-1,-1,\n        67108863,1061158911,-1,-1426112705,1073741823,-1,1608515583,\n        265232348,534519807,0,0,0,0,0,0,0,0,0,19520,0,0,7,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,128,1022,-2,-1,2097151,-2,-1,134217727,-32,8191,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        };",
        "TranslatedCode": "/*\n * 是否为命名空间开始字符\n * Name 的第一个字符必须是NameStartChar，任何其他字符必须是NameChars；\n * @param char 要判断的字符\n * @see https://www.w3.org/TR/xml/ 2.3节 Names and Tokens\n * @return 是否为NameStartChar字符\n */\nexport function isNameStartChar(char: string): boolean {\n  let cp = getCodePoint(char);\n\n  return cp === 0x3A // :\n  || cp === 0x5F // _\n  || (cp >= 0x41 && cp <= 0x5A) // A-Z\n  || (cp >= 0x61 && cp <= 0x7A) // a-z\n  || (cp >= 0xC0 && cp <= 0xD6)\n  || (cp >= 0xD8 && cp <= 0xF6)\n  || (cp >= 0xF8 && cp <= 0x2FF)\n  || (cp >= 0x370 && cp <= 0x37D)\n  || (cp >= 0x37F && cp <= 0x1FFF)\n  || (cp >= 0x200C && cp <= 0x200D)\n  || (cp >= 0x2070 && cp <= 0x218F)\n  || (cp >= 0x2C00 && cp <= 0x2FEF)\n  || (cp >= 0x3001 && cp <= 0xD7FF)\n  || (cp >= 0xF900 && cp <= 0xFDCF)\n  || (cp >= 0xFDF0 && cp <= 0xFFFD)\n  || (cp >= 0x10000 && cp <= 0xEFFFF);\n}",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "/**\n     * Tests whether the given character is a valid XML name character.\n     */\n    public static boolean isXMLNameCharacter(char c) {\n        return (NAME_CHARACTER[c / 32] & (1 << (c % 32))) != 0;\n    }\n    /**\n     * The bit array representing a character compositing an XML name.\n     */\n    public static final int[] NAME_CHARACTER = {\n        0,134176768,-2013265922,134217726,0,8388608,-8388609,-8388609,-1,\n        2146697215,-514,2147483647,-1,-1,-8177,-63832065,16777215,0,-65536,\n        -1,-1,-134217217,196611,0,-1,-1,63,3,-10304,-5,1417641983,1048573,\n        -8194,-1,-536936449,-1,-65413,-1,-58977,54513663,0,-131072,41943039,\n        -2,-130945,-1140850693,-65514,460799,0,134217726,524287,-64513,-1,\n        2097151999,-1081345,67059199,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-18,\n        -201326593,-14794753,65487,-417810,-741999105,-1333773921,262095,\n        -423964,-747766273,1577073031,2097088,-282642,-202506753,15295,65473,\n        -417810,-204603905,-1329579633,65475,-700594196,-1010841832,8404423,\n        65408,-139282,-1007682049,6307295,65475,-139284,-1007682049,\n        1080049119,65475,-139284,-1006633473,8404431,65475,0,0,0,0,-2,\n        134184959,67076095,0,-17816170,1006595246,67059551,0,50331648,\n        -1029700609,-257,-130049,-21032993,50216959,0,0,0,0,0,0,0,-1,-65473,\n        8388607,514797,1342177280,-2110697471,2908843,1073741824,-176109312,\n        7,33622016,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,\n        -1,-1,-1,268435455,-1,-1,67108863,1061158911,-1,-1426112705,\n        1073741823,-1,1608515583,265232348,534519807,0,0,0,0,0,0,536805376,2,\n        0,19520,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,4128766,-2,-1,1713373183,\n        -2,-1,2013265919,-32,8191,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,63,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,\n        -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,15,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,\n        };\n",
        "TranslatedCode": "/*\n * 是否为命名空间字符\n * @param char 要判断的字符\n * @see https://www.w3.org/TR/xml/ 2.3节 Names and Tokens\n * @return 是否为NameChar字符\n */\nexport function isNameChar(char: string): boolean {\n  if (isNameStartChar(char)) {\n    return true;\n  }\n\n  let cp = getCodePoint(char);\n\n  return cp === 0x2D // -\n  || cp === 0x2E // .\n  || (cp >= 0x30 && cp <= 0x39) // 0-9\n  || cp === 0xB7\n  || (cp >= 0x300 && cp <= 0x36F)\n  || (cp >= 0x203F && cp <= 0x2040);\n}\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public static byte getNextState(nsVerifier v, byte b, byte s) {\n\n         return (byte) ( 0xFF &\n\t     (((v.states()[((\n\t\t   (s*v.stFactor()+(((v.cclass()[((b&0xFF)>>v.eidxSft4bits)])\n\t\t   >> ((b & v.eSftMsk4bits) << v.eBitSft4bits))\n\t\t   & v.eUnitMsk4bits ))&0xFF)\n\t\t>> v.eidxSft4bits) ]) >> (((\n\t\t   (s*v.stFactor()+(((v.cclass()[((b&0xFF)>>v.eidxSft4bits)])\n\t\t   >> ((b & v.eSftMsk4bits) << v.eBitSft4bits))\n\t\t   & v.eUnitMsk4bits ))&0xFF)\n\t\t& v.eSftMsk4bits) << v.eBitSft4bits)) & v.eUnitMsk4bits )\n\t ) ;\n\n     }",
        "TranslatedCode": "public static getNextState(v: nsVerifier, b: number, s: number): number {\n\n    return (0xFF &\n    (((v.states()[((\n      (s * v.stFactor() + (((v.cclass()[((b & 0xFF) >> nsVerifier.eidxSft4bits)])\n      >> ((b & nsVerifier.eSftMsk4bits) << nsVerifier.eBitSft4bits))\n      & nsVerifier.eUnitMsk4bits)) & 0xFF)\n    >> nsVerifier.eidxSft4bits)]) >> (((\n      (s * v.stFactor() + (((v.cclass()[((b & 0xFF) >> nsVerifier.eidxSft4bits)])\n      >> ((b & nsVerifier.eSftMsk4bits) << nsVerifier.eBitSft4bits))\n      & nsVerifier.eUnitMsk4bits)) & 0xFF)\n    & nsVerifier.eSftMsk4bits) << nsVerifier.eBitSft4bits)) & nsVerifier.eUnitMsk4bits)\n    );\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isUCS2() { return  false; } ;",
        "TranslatedCode": "public isUCS2(): boolean {\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int[]  cclass()   { return cclass ;   }",
        "TranslatedCode": "public cclass(): number[]   {\n    return nsUCS2LEVerifier.cclass;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int[]  states()   { return states ;   }",
        "TranslatedCode": "public states(): number[]   {\n    return nsUCS2LEVerifier.states;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int    stFactor() { return stFactor ; }",
        "TranslatedCode": "public stFactor(): number {\n    return nsUCS2LEVerifier.stFactor;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public String charset()  { return charset ;  }",
        "TranslatedCode": "public charset(): string  {\n    return nsUCS2LEVerifier.charset;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isUCS2() { return  true; } ;",
        "TranslatedCode": "public isUCS2(): boolean {\n    return true;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public nsUCS2LEVerifier() {\n\n      cclass = new int[256/8] ;\n\n      cclass[0] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[1] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((2) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (1))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[2] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[3] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((3) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[4] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[5] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((3) << 4) | ( 3))) ))) ) << 16) | (  ((int)(((  ((int)(((3) << 4) | (3))) ) << 8) | (   ((int)(((3) << 4) | (0))) )))))) ;\n      cclass[6] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[7] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[8] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[9] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[10] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[11] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[12] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[13] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[14] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[15] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[16] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[17] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[18] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[19] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[20] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[21] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[22] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[23] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[24] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[25] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[26] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[27] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[28] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[29] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[30] = ((int)(((  ((int)(((  ((int)((( 0) << 4) | (0)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n      cclass[31] = ((int)(((  ((int)(((  ((int)((( 5) << 4) | (4)))  ) << 8) | (((int)(((0) << 4) | ( 0))) ))) ) << 16) | (  ((int)(((  ((int)(((0) << 4) | (0))) ) << 8) | (   ((int)(((0) << 4) | (0))) )))))) ;\n\n\n\n      states = new int[7] ;\n\n      states[0] = ((int)(((  ((int)(((  ((int)((( eError) << 4) | (eError)))  ) << 8) | (((int)(((     3) << 4) | (      4))) ))) ) << 16) | (  ((int)(((  ((int)(((     6) << 4) | (     7))) ) << 8) | (   ((int)(((     6) << 4) | (     6))) )))))) ;\n      states[1] = ((int)(((  ((int)(((  ((int)((( eItsMe) << 4) | (eItsMe)))  ) << 8) | (((int)(((eItsMe) << 4) | ( eItsMe))) ))) ) << 16) | (  ((int)(((  ((int)(((eError) << 4) | (eError))) ) << 8) | (   ((int)(((eError) << 4) | (eError))) )))))) ;\n      states[2] = ((int)(((  ((int)(((  ((int)((( eError) << 4) | (eItsMe)))  ) << 8) | (((int)(((eError) << 4) | (      5))) ))) ) << 16) | (  ((int)(((  ((int)(((     5) << 4) | (     5))) ) << 8) | (   ((int)(((eItsMe) << 4) | (eItsMe))) )))))) ;\n      states[3] = ((int)(((  ((int)(((  ((int)(((      6) << 4) | (     6)))  ) << 8) | (((int)(((eError) << 4) | (      5))) ))) ) << 16) | (  ((int)(((  ((int)(((eError) << 4) | (     5))) ) << 8) | (   ((int)(((     5) << 4) | (     5))) )))))) ;\n      states[4] = ((int)(((  ((int)(((  ((int)((( eError) << 4) | (     5)))  ) << 8) | (((int)(((     5) << 4) | (      5))) ))) ) << 16) | (  ((int)(((  ((int)(((     8) << 4) | (     8))) ) << 8) | (   ((int)(((     6) << 4) | (     7))) )))))) ;\n      states[5] = ((int)(((  ((int)(((  ((int)(((      5) << 4) | (     5)))  ) << 8) | (((int)(((eError) << 4) | ( eError))) ))) ) << 16) | (  ((int)(((  ((int)(((eError) << 4) | (     5))) ) << 8) | (   ((int)(((     5) << 4) | (     5))) )))))) ;\n      states[6] = ((int)(((  ((int)(((  ((int)((( eStart) << 4) | (eStart)))  ) << 8) | (((int)(((eError) << 4) | (      5))) ))) ) << 16) | (  ((int)(((  ((int)(((eError) << 4) | (     5))) ) << 8) | (   ((int)(((     5) << 4) | (     5))) )))))) ;\n\n\n\n      charset =  \"UTF-16LE\";\n      stFactor =  6;\n\n   }",
        "TranslatedCode": "constructor() {\n    super();\n    nsUCS2LEVerifier.cclass = new Array(256 / 8);\n\n    nsUCS2LEVerifier.cclass[0] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[1] = ((((((((((((0) << 4) | (0)))) << 8) | (((((2) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (1)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[2] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[3] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((3) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[4] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[5] = ((((((((((((0) << 4) | (0)))) << 8) | (((((3) << 4) | (3))))))) << 16) | (((((((((3) << 4) | (3)))) << 8) | (((((3) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[6] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[7] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[8] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[9] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[10] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[11] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[12] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[13] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[14] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[15] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[16] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[17] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[18] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[19] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[20] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[21] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[22] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[23] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[24] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[25] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[26] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[27] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[28] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[29] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[30] = ((((((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n    nsUCS2LEVerifier.cclass[31] = ((((((((((((5) << 4) | (4)))) << 8) | (((((0) << 4) | (0))))))) << 16) | (((((((((0) << 4) | (0)))) << 8) | (((((0) << 4) | (0)))))))));\n\n\n    nsUCS2LEVerifier.states = new Array(7);\n\n    nsUCS2LEVerifier.states[0] = ((((((((((((nsUCS2LEVerifier.eError) << 4) | (nsUCS2LEVerifier.eError)))) << 8) | (((((3) << 4) | (4))))))) << 16) | (((((((((6) << 4) | (7)))) << 8) | (((((6) << 4) | (6)))))))));\n    nsUCS2LEVerifier.states[1] = ((((((((((((nsUCS2LEVerifier.eItsMe) << 4) | (nsUCS2LEVerifier.eItsMe)))) << 8) | (((((nsUCS2LEVerifier.eItsMe) << 4) | (nsUCS2LEVerifier.eItsMe))))))) << 16) | (((((((((nsUCS2LEVerifier.eError) << 4) | (nsUCS2LEVerifier.eError)))) << 8) | (((((nsUCS2LEVerifier.eError) << 4) | (nsUCS2LEVerifier.eError)))))))));\n    nsUCS2LEVerifier.states[2] = ((((((((((((nsUCS2LEVerifier.eError) << 4) | (nsUCS2LEVerifier.eItsMe)))) << 8) | (((((nsUCS2LEVerifier.eError) << 4) | (5))))))) << 16) | (((((((((5) << 4) | (5)))) << 8) | (((((nsUCS2LEVerifier.eItsMe) << 4) | (nsUCS2LEVerifier.eItsMe)))))))));\n    nsUCS2LEVerifier.states[3] = ((((((((((((6) << 4) | (6)))) << 8) | (((((nsUCS2LEVerifier.eError) << 4) | (5))))))) << 16) | (((((((((nsUCS2LEVerifier.eError) << 4) | (5)))) << 8) | (((((5) << 4) | (5)))))))));\n    nsUCS2LEVerifier.states[4] = ((((((((((((nsUCS2LEVerifier.eError) << 4) | (5)))) << 8) | (((((5) << 4) | (5))))))) << 16) | (((((((((8) << 4) | (8)))) << 8) | (((((6) << 4) | (7)))))))));\n    nsUCS2LEVerifier.states[5] = ((((((((((((5) << 4) | (5)))) << 8) | (((((nsUCS2LEVerifier.eError) << 4) | (nsUCS2LEVerifier.eError))))))) << 16) | (((((((((nsUCS2LEVerifier.eError) << 4) | (5)))) << 8) | (((((5) << 4) | (5)))))))));\n    nsUCS2LEVerifier.states[6] = ((((((((((((nsUCS2LEVerifier.eStart) << 4) | (nsUCS2LEVerifier.eStart)))) << 8) | (((((nsUCS2LEVerifier.eError) << 4) | (5))))))) << 16) | (((((((((nsUCS2LEVerifier.eError) << 4) | (5)))) << 8) | (((((5) << 4) | (5)))))))));\n\n\n    nsUCS2LEVerifier.charset = \"UTF-16LE\";\n    nsUCS2LEVerifier.stFactor = 6;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int[]  cclass()   { return cclass ;   }",
        "TranslatedCode": "public cclass(): number[]   {\n    return nsUCS2BEVerifier.cclass;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int[]  states()   { return states ;   }",
        "TranslatedCode": "public states(): number[]   {\n    return nsUCS2BEVerifier.states;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int    stFactor() { return stFactor ; }",
        "TranslatedCode": "public stFactor(): number {\n    return nsUCS2BEVerifier.stFactor;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public String charset()  { return charset ;  }",
        "TranslatedCode": "public charset(): string  {\n    return nsUCS2BEVerifier.charset;\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isUCS2() { return  true; } ;",
        "TranslatedCode": "public isUCS2(): boolean {\n    return true;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int[]  cclass()   { return cclass ;   }",
        "TranslatedCode": "public cclass(): number[]   {\n    return nsSJISVerifier.cclass;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int[]  states()   { return states ;   }",
        "TranslatedCode": "public states(): number[]   {\n\n    return nsSJISVerifier.states;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public int    stFactor() { return stFactor ; }",
        "TranslatedCode": "public stFactor(): number {\n    return nsSJISVerifier.stFactor;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public String charset()  { return charset ;  }",
        "TranslatedCode": "public charset(): string  {\n    return nsSJISVerifier.charset;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isUCS2() { return  false; } ;",
        "TranslatedCode": "public isUCS2(): boolean {\n    return false;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public nsPSMDetector() {\n\tinitVerifiers( nsPSMDetector.ALL );\n\tReset() ;\n   }\n\n   public nsPSMDetector(int langFlag) {\n\tinitVerifiers(langFlag);\n\tReset() ;\n   }\n\n   public nsPSMDetector(int aItems, nsVerifier[] aVerifierSet,\n\t\t\t\t\tnsEUCStatistics[] aStatisticsSet)  {\n\tmClassRunSampler = ( aStatisticsSet != null ) ;\n\tmStatisticsData = aStatisticsSet ;\n\tmVerifier = aVerifierSet ;\n\n\tmClassItems = aItems ;\n\tReset() ;\n   }",
        "TranslatedCode": "constructor(langFlag?: number, aItems?: number, aVerifierSet?: nsVerifier[],\n              aStatisticsSet?: Array<nsEUCStatistics| undefined>) {\n    if (langFlag || langFlag == 0) {\n      this.initVerifiers(langFlag);\n    } else {\n      if ((aItems || aItems == 0) || aVerifierSet || aStatisticsSet) {\n        this.mClassRunSampler = (aStatisticsSet != null);\n        this.mStatisticsData = aStatisticsSet;\n        this.mVerifier = aVerifierSet;\n\n        this.mClassItems = aItems?aItems:0;\n      } else {\n        this.initVerifiers(nsPSMDetector.ALL);\n\n      }\n    }\n    this.Reset();\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void Reset() {\n\tmRunSampler = mClassRunSampler ;\n\tmDone = false ;\n\tmItems = mClassItems ;\n\n\tfor(int i=0; i<mItems; i++) {\n\t   mState[i] = 0;\n\t   mItemIdx[i] = i;\n\t}\n\n\tmSampler.Reset() ;\n   }",
        "TranslatedCode": "public Reset(): void {\n    this.mRunSampler = this.mClassRunSampler;\n    this.mDone = false;\n    this.mItems = this.mClassItems;\n\n    if (this.mItems) {\n      for (let i = 0; i < this.mItems; i++) {\n        this.mState[i] = 0;\n        this.mItemIdx[i] = i;\n      }\n    }\n\n    this.mSampler.Reset();\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "protected void initVerifiers(int currVerSet) {\n\n\tint idx = 0 ;\n        int currVerifierSet ;\n\n\tif (currVerSet >=0 && currVerSet < NO_OF_LANGUAGES ) {\n\t   currVerifierSet = currVerSet ;\n\t}\n\telse {\n\t   currVerifierSet = nsPSMDetector.ALL ;\n\t}\n\n\tmVerifier = null ;\n\tmStatisticsData = null ;\n\n\tif ( currVerifierSet == nsPSMDetector.TRADITIONAL_CHINESE ) {\n\n\t   mVerifier = new nsVerifier[] {\n      \t\tnew nsUTF8Verifier(),\n      \t\tnew nsBIG5Verifier(),\n      \t\tnew nsISO2022CNVerifier(),\n      \t\tnew nsEUCTWVerifier(),\n      \t\tnew nsCP1252Verifier(),\n      \t\tnew nsUCS2BEVerifier(),\n      \t\tnew nsUCS2LEVerifier()\n\t   };\n\n\t   mStatisticsData = new nsEUCStatistics[] {\n      \t\tnull,\n      \t\tnew Big5Statistics(),\n      \t\tnull,\n      \t\tnew EUCTWStatistics(),\n      \t\tnull,\n      \t\tnull,\n      \t\tnull\n\t   };\n\t}\n\n\t//==========================================================\n\telse if ( currVerifierSet == nsPSMDetector.KOREAN ) {\n\n\t   mVerifier = new nsVerifier[] {\n      \t\tnew nsUTF8Verifier(),\n      \t\tnew nsEUCKRVerifier(),\n      \t\tnew nsISO2022KRVerifier(),\n      \t\tnew nsCP1252Verifier(),\n      \t\tnew nsUCS2BEVerifier(),\n      \t\tnew nsUCS2LEVerifier()\n\t   };\n\t}\n\n\t//==========================================================\n\telse if ( currVerifierSet == nsPSMDetector.SIMPLIFIED_CHINESE ) {\n\n\t   mVerifier = new nsVerifier[] {\n      \t\tnew nsUTF8Verifier(),\n      \t\tnew nsGB2312Verifier(),\n      \t\tnew nsGB18030Verifier(),\n      \t\tnew nsISO2022CNVerifier(),\n      \t\tnew nsHZVerifier(),\n      \t\tnew nsCP1252Verifier(),\n      \t\tnew nsUCS2BEVerifier(),\n      \t\tnew nsUCS2LEVerifier()\n\t   };\n\t}\n\n\t//==========================================================\n\telse if ( currVerifierSet == nsPSMDetector.JAPANESE ) {\n\n\t   mVerifier = new nsVerifier[] {\n      \t\tnew nsUTF8Verifier(),\n      \t\tnew nsSJISVerifier(),\n      \t\tnew nsEUCJPVerifier(),\n      \t\tnew nsISO2022JPVerifier(),\n      \t\tnew nsCP1252Verifier(),\n      \t\tnew nsUCS2BEVerifier(),\n      \t\tnew nsUCS2LEVerifier()\n\t   };\n\t}\n\t//==========================================================\n\telse if ( currVerifierSet == nsPSMDetector.CHINESE ) {\n\n\t   mVerifier = new nsVerifier[] {\n      \t\tnew nsUTF8Verifier(),\n      \t\tnew nsGB2312Verifier(),\n      \t\tnew nsGB18030Verifier(),\n      \t\tnew nsBIG5Verifier(),\n      \t\tnew nsISO2022CNVerifier(),\n      \t\tnew nsHZVerifier(),\n      \t\tnew nsEUCTWVerifier(),\n      \t\tnew nsCP1252Verifier(),\n      \t\tnew nsUCS2BEVerifier(),\n      \t\tnew nsUCS2LEVerifier()\n\t   };\n\n\t   mStatisticsData = new nsEUCStatistics[] {\n      \t\tnull,\n      \t\tnew GB2312Statistics(),\n\t\tnull,\n      \t\tnew Big5Statistics(),\n      \t\tnull,\n      \t\tnull,\n      \t\tnew EUCTWStatistics(),\n      \t\tnull,\n      \t\tnull,\n      \t\tnull\n\t   };\n\t}\n\n\t//==========================================================\n\telse if ( currVerifierSet == nsPSMDetector.ALL ) {\n\n\t   mVerifier = new nsVerifier[] {\n      \t\tnew nsUTF8Verifier(),\n      \t\tnew nsSJISVerifier(),\n      \t\tnew nsEUCJPVerifier(),\n      \t\tnew nsISO2022JPVerifier(),\n      \t\tnew nsEUCKRVerifier(),\n      \t\tnew nsISO2022KRVerifier(),\n      \t\tnew nsBIG5Verifier(),\n      \t\tnew nsEUCTWVerifier(),\n      \t\tnew nsGB2312Verifier(),\n      \t\tnew nsGB18030Verifier(),\n      \t\tnew nsISO2022CNVerifier(),\n      \t\tnew nsHZVerifier(),\n      \t\tnew nsCP1252Verifier(),\n      \t\tnew nsUCS2BEVerifier(),\n      \t\tnew nsUCS2LEVerifier()\n\t   };\n\n\t   mStatisticsData = new nsEUCStatistics[] {\n      \t\tnull,\n      \t\tnull,\n      \t\tnew EUCJPStatistics(),\n      \t\tnull,\n      \t\tnew EUCKRStatistics(),\n      \t\tnull,\n      \t\tnew Big5Statistics(),\n      \t\tnew EUCTWStatistics(),\n      \t\tnew GB2312Statistics(),\n      \t\tnull,\n      \t\tnull,\n      \t\tnull,\n      \t\tnull,\n      \t\tnull,\n      \t\tnull\n\t   };\n\t}\n\n\tmClassRunSampler = ( mStatisticsData != null ) ;\n       \tmClassItems = mVerifier.length ;\n\n   }",
        "TranslatedCode": "protected initVerifiers(currVerSet: number): void {\n\n    let idx = 0;\n    let currVerifierSet: number;\n\n    if (currVerSet >= 0 && currVerSet < nsPSMDetector.NO_OF_LANGUAGES) {\n      currVerifierSet = currVerSet;\n    }\n    else {\n      currVerifierSet = nsPSMDetector.ALL;\n    }\n\n    this.mVerifier = [];\n    this.mStatisticsData = [];\n\n    if (currVerifierSet == nsPSMDetector.TRADITIONAL_CHINESE) {\n\n      this.mVerifier = [\n        new nsUTF8Verifier(),\n        new nsBIG5Verifier(),\n        new nsISO2022CNVerifier(),\n        new nsEUCTWVerifier(),\n        new nsCP1252Verifier(),\n        new nsUCS2BEVerifier(),\n        new nsUCS2LEVerifier()\n      ];\n\n      this.mStatisticsData = [\n        ,\n        new Big5Statistics(),\n        ,\n        new EUCTWStatistics(),\n        ,\n        ,\n\n      ];\n    }\n\n    //==========================================================\n    else if (currVerifierSet == nsPSMDetector.KOREAN) {\n\n      this.mVerifier = [\n        new nsUTF8Verifier(),\n        new nsEUCKRVerifier(),\n        new nsISO2022KRVerifier(),\n        new nsCP1252Verifier(),\n        new nsUCS2BEVerifier(),\n        new nsUCS2LEVerifier()\n      ];\n    }\n\n    //==========================================================\n    else if (currVerifierSet == nsPSMDetector.SIMPLIFIED_CHINESE) {\n\n      this.mVerifier = [\n        new nsUTF8Verifier(),\n        new nsGB2312Verifier(),\n        new nsGB18030Verifier(),\n        new nsISO2022CNVerifier(),\n        new nsHZVerifier(),\n        new nsCP1252Verifier(),\n        new nsUCS2BEVerifier(),\n        new nsUCS2LEVerifier()\n      ];\n    }\n\n    //==========================================================\n    else if (currVerifierSet == nsPSMDetector.JAPANESE) {\n\n      this.mVerifier = [\n        new nsUTF8Verifier(),\n        new nsSJISVerifier(),\n        new nsEUCJPVerifier(),\n        new nsISO2022JPVerifier(),\n        new nsCP1252Verifier(),\n        new nsUCS2BEVerifier(),\n        new nsUCS2LEVerifier()\n      ];\n    }\n    //==========================================================\n    else if (currVerifierSet == nsPSMDetector.CHINESE) {\n\n      this.mVerifier = [\n        new nsUTF8Verifier(),\n        new nsGB2312Verifier(),\n        new nsGB18030Verifier(),\n        new nsBIG5Verifier(),\n        new nsISO2022CNVerifier(),\n        new nsHZVerifier(),\n        new nsEUCTWVerifier(),\n        new nsCP1252Verifier(),\n        new nsUCS2BEVerifier(),\n        new nsUCS2LEVerifier()\n      ];\n\n      this.mStatisticsData = [\n        ,\n        new GB2312Statistics(),\n        ,\n        new Big5Statistics(),\n        ,\n        ,\n        new EUCTWStatistics(),\n        ,\n        ,\n\n      ];\n    }\n\n    //==========================================================\n    else if (currVerifierSet == nsPSMDetector.ALL) {\n\n      this.mVerifier = [\n        new nsUTF8Verifier(),\n        new nsSJISVerifier(),\n        new nsEUCJPVerifier(),\n        new nsISO2022JPVerifier(),\n        new nsEUCKRVerifier(),\n        new nsISO2022KRVerifier(),\n        new nsBIG5Verifier(),\n        new nsEUCTWVerifier(),\n        new nsGB2312Verifier(),\n        new nsGB18030Verifier(),\n        new nsISO2022CNVerifier(),\n        new nsHZVerifier(),\n        new nsCP1252Verifier(),\n        new nsUCS2BEVerifier(),\n        new nsUCS2LEVerifier()\n      ];\n\n      this.mStatisticsData = [\n        ,\n        ,\n        new EUCJPStatistics(),\n        ,\n        new EUCKRStatistics(),\n        ,\n        new Big5Statistics(),\n        new EUCTWStatistics(),\n        new GB2312Statistics(),\n        ,\n        ,\n        ,\n        ,\n        ,\n\n      ];\n    }\n\n    this.mClassRunSampler = (this.mStatisticsData != null);\n    this.mClassItems = this.mVerifier?this.mVerifier.length:0;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean HandleData(byte[] aBuf, int len) {\n\n\n\tint i,j;\n\tbyte b, st;\n\n \tfor( i=0; i < len; i++) {\n\t   b = aBuf[i] ;\n\n\t   for (j=0; j < mItems; )\n\t   {\n\t\tst = nsVerifier.getNextState( mVerifier[mItemIdx[j]],\n\t\t\t\t\t\tb, mState[j]) ;\n//if (st != 0)\n//System.out.println( \"state(0x\" + Integer.toHexString(0xFF&b) +\") =>\"+ Integer.toHexString(st&0xFF)+ \" \" + mVerifier[mItemIdx[j]].charset());\n\n\t\tif (st == nsVerifier.eItsMe) {\n\n//System.out.println( \"eItsMe(0x\" + Integer.toHexString(0xFF&b) +\") =>\"+ mVerifier[mItemIdx[j]].charset());\n\n\t\t   Report( mVerifier[mItemIdx[j]].charset() );\n\t\t   mDone = true ;\n\t\t   return mDone ;\n\n\t        } else if (st == nsVerifier.eError ) {\n\n//System.out.println( \"eNotMe(0x\" + Integer.toHexString(0xFF&b) +\") =>\"+ mVerifier[mItemIdx[j]].charset());\n\t\t   mItems--;\n\t\t   if (j < mItems ) {\n\t\t\tmItemIdx[j] = mItemIdx[mItems];\n\t\t\tmState[j]   = mState[mItems];\n\t\t   }\n\n\t\t} else {\n\n\t\t    mState[j++] = st ;\n\n\t\t}\n\t   }\n\n\t   if ( mItems <= 1 ) {\n\n\t        if( 1 == mItems) {\n\t\t   Report( mVerifier[mItemIdx[0]].charset() );\n\t\t}\n\t\tmDone = true ;\n\t\treturn mDone ;\n\n\t   }\n\t   else {\n\n\t\tint nonUCS2Num=0;\n\t\tint nonUCS2Idx=0;\n\n\t\tfor(j=0; j<mItems; j++) {\n\t\t   if ( (!(mVerifier[mItemIdx[j]].isUCS2())) &&\n\t\t\t(!(mVerifier[mItemIdx[j]].isUCS2())) )\n\t\t   {\n\t\t\tnonUCS2Num++ ;\n\t\t\tnonUCS2Idx = j ;\n\t\t   }\n\t\t}\n\n\t\tif (1 == nonUCS2Num) {\n\t\t   Report( mVerifier[mItemIdx[nonUCS2Idx]].charset() );\n\t\t   mDone = true ;\n\t\t   return mDone ;\n\t\t}\n\t   }\n\n\n       } // End of for( i=0; i < len ...\n\n       if (mRunSampler)\n\t  Sample(aBuf, len);\n\n       return mDone ;\n   }\n",
        "TranslatedCode": "public HandleData(aBuf: Int8Array, len: number): boolean {\n\n    let i: number = 0;\n    let j: number = 0;\n    let b: number = 0;\n    let st: number = 0;\n\n    for (i = 0; i < len; i++) {\n      b = aBuf[i];\n\n      for (j = 0; j < this.mItems; ) {\n        if (this.mVerifier && this.mItemIdx) {\n          let verifier = this.mVerifier[this.mItemIdx[j]];\n          if (verifier) {\n            st = nsVerifier.getNextState(verifier, b, this.mState[j]);\n          }\n        }\n\n        if (st == nsVerifier.eItsMe) {\n\n\n          if (this.mVerifier && this.mItemIdx && this.mVerifier[this.mItemIdx[j]] && this.mVerifier[this.mItemIdx[j]]?.charset()) {\n            let charset = this.mVerifier[this.mItemIdx[j]]?.charset()\n            this.Report(charset);\n          }\n          this.mDone = true;\n          return this.mDone;\n\n        } else if (st == nsVerifier.eError) {\n\n          this.mItems--;\n          if (j < this.mItems) {\n            this.mItemIdx[j] = this.mItemIdx[this.mItems];\n            this.mState[j] = this.mState[this.mItems];\n          }\n\n        } else {\n\n          this.mState[j++] = st;\n\n        }\n      }\n\n      if (this.mItems <= 1) {\n\n        if (1 == this.mItems) {\n          if (this.mVerifier && this.mItemIdx && this.mVerifier[this.mItemIdx[0]] && this.mVerifier[this.mItemIdx[0]]?.charset()) {\n            let charset = this.mVerifier[this.mItemIdx[0]]?.charset()\n            this.Report(charset);\n          }\n        }\n        this.mDone = true;\n        return this.mDone;\n\n      }\n      else {\n\n        let nonUCS2Num: number = 0;\n        let nonUCS2Idx: number = 0;\n\n        for (j = 0; j < this.mItems; j++) {\n          if (this.mVerifier && (!(this.mVerifier[this.mItemIdx[j]]?.isUCS2())) &&\n          (!(this.mVerifier[this.mItemIdx[j]]?.isUCS2()))) {\n            nonUCS2Num++;\n            nonUCS2Idx = j;\n          }\n        }\n\n        if (1 == nonUCS2Num) {\n          if (this.mVerifier) {\n            if (this.mVerifier && this.mItemIdx && this.mVerifier[this.mItemIdx[nonUCS2Idx]] && this.mVerifier[this.mItemIdx[nonUCS2Idx]]?.charset()) {\n              let charset = this.mVerifier[this.mItemIdx[nonUCS2Idx]]?.charset()\n              this.Report(charset);\n            }\n          }\n          this.mDone = true;\n          return this.mDone;\n        }\n      }\n\n\n    }\n\n    if (this.mRunSampler)\n    this.Sample(aBuf, len);\n\n    return this.mDone;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void DataEnd() {\n\n\tif (mDone == true)\n\t    return ;\n\n\tif (mItems == 2) {\n\t    if ((mVerifier[mItemIdx[0]].charset()).equals(\"GB18030\")) {\n\t\tReport(mVerifier[mItemIdx[1]].charset()) ;\n\t\tmDone = true ;\n\t    } else if ((mVerifier[mItemIdx[1]].charset()).equals(\"GB18030\")) {\n\t\tReport(mVerifier[mItemIdx[0]].charset()) ;\n\t\tmDone = true ;\n\t    }\n\t}\n\n\tif (mRunSampler)\n\t   Sample(null, 0, true);\n   }",
        "TranslatedCode": "public DataEnd(): void {\n\n    if (this.mDone == true)\n    return;\n\n    if (this.mItems == 2) {\n      if (this.mVerifier && (this.mVerifier[this.mItemIdx[0]]?.charset()) == \"GB18030\") {\n        this.Report(this.mVerifier[this.mItemIdx[1]]?.charset());\n        this.mDone = true;\n      } else if (this.mVerifier && (this.mVerifier[this.mItemIdx[1]]?.charset()) == \"GB18030\") {\n        this.Report(this.mVerifier[this.mItemIdx[0]]?.charset());\n        this.mDone = true;\n      }\n    }\n\n    if (this.mRunSampler)\n    this.Sample(null, 0, true);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void Sample(byte[] aBuf, int aLen) {\n\t  Sample(aBuf, aLen, false) ;\n   }\n\n   public void Sample(byte[] aBuf, int aLen, boolean aLastChance)\n   {\n      \tint possibleCandidateNum  = 0;\n\tint j;\n\tint eucNum=0 ;\n\n\tfor (j=0; j< mItems; j++) {\n\t   if (null != mStatisticsData[mItemIdx[j]])\n\t\teucNum++ ;\n\t   if ((!mVerifier[mItemIdx[j]].isUCS2()) &&\n\t\t\t(!(mVerifier[mItemIdx[j]].charset()).equals(\"GB18030\")))\n\t\tpossibleCandidateNum++ ;\n\t}\n\n\tmRunSampler = (eucNum > 1) ;\n\n     \tif (mRunSampler) {\n            mRunSampler = mSampler.Sample(aBuf, aLen);\n            if(((aLastChance && mSampler.GetSomeData()) ||\n                mSampler.EnoughData())\n               && (eucNum == possibleCandidateNum)) {\n              mSampler.CalFreq();\n\n              int bestIdx = -1;\n              int eucCnt=0;\n              float bestScore = 0.0f;\n              for(j = 0; j < mItems; j++) {\n                 if((null != mStatisticsData[mItemIdx[j]])  &&\n                   (!(mVerifier[mItemIdx[j]].charset()).equals(\"Big5\")))\n                 {\n                    float score = mSampler.GetScore(\n                       mStatisticsData[mItemIdx[j]].mFirstByteFreq(),\n                       mStatisticsData[mItemIdx[j]].mFirstByteWeight(),\n                       mStatisticsData[mItemIdx[j]].mSecondByteFreq(),\n                       mStatisticsData[mItemIdx[j]].mSecondByteWeight() );\n//System.out.println(\"FequencyScore(\"+mVerifier[mItemIdx[j]].charset()+\")= \"+ score);\n                    if(( 0 == eucCnt++) || (bestScore > score )) {\n                       bestScore = score;\n                       bestIdx = j;\n                    } // if(( 0 == eucCnt++) || (bestScore > score ))\n                } // if(null != ...)\n             } // for\n             if (bestIdx >= 0)\n             {\n               Report( mVerifier[mItemIdx[bestIdx]].charset());\n               mDone = true;\n             }\n           } // if (eucNum == possibleCandidateNum)\n         } // if(mRunSampler)\n   }",
        "TranslatedCode": "public Sample(aBuf: Int8Array| null, aLen: number, aLastChance?: boolean): void\n  {\n    if (aLastChance == null) {\n      aLastChance = false;\n    }\n    let possibleCandidateNum: number = 0;\n    let j: number;\n    let eucNum: number = 0;\n\n    for (j = 0; j < this.mItems; j++) {\n      if (this.mStatisticsData && null != this.mStatisticsData[this.mItemIdx[j]])\n      eucNum++;\n      if (this.mVerifier && (!this.mVerifier[this.mItemIdx[j]]?.isUCS2()) &&\n      (!(this.mVerifier[this.mItemIdx[j]]?.charset() == \"GB18030\")))\n      possibleCandidateNum++;\n    }\n\n    this.mRunSampler = (eucNum > 1);\n\n    if (this.mRunSampler) {\n      this.mRunSampler = this.mSampler.Sample(aBuf, aLen);\n      if (((aLastChance && this.mSampler.GetSomeData()) ||\n      this.mSampler.EnoughData())\n      && (eucNum == possibleCandidateNum)) {\n        this.mSampler.CalFreq();\n\n        let bestIdx: number = -1;\n        let eucCnt: number = 0;\n        let bestScore: number = 0.0;\n        for (j = 0; j < this.mItems; j++) {\n          if (this.mStatisticsData && (null != this.mStatisticsData[this.mItemIdx[j]]) && this.mVerifier &&\n          (!(this.mVerifier[this.mItemIdx[j]]?.charset() == \"Big5\"))) {\n            if (this.mStatisticsData && this.mStatisticsData[this.mItemIdx[j]]) {\n\n              let firstByteFreq = this.mStatisticsData[this.mItemIdx[j]]?.mFirstByteFreq();\n              let firstByteWeight = this.mStatisticsData[this.mItemIdx[j]]?.mFirstByteWeight();\n              let secondByteFreq = this.mStatisticsData[this.mItemIdx[j]]?.mSecondByteFreq();\n              let secondByteWeight = this.mStatisticsData[this.mItemIdx[j]]?.mSecondByteWeight();\n\n              let score: number = this.mSampler.GetScore(\n                firstByteFreq?firstByteFreq:[],\n                firstByteWeight?firstByteWeight:0,\n                secondByteFreq?secondByteFreq:[],\n                secondByteWeight?secondByteWeight:0);\n              if ((0 == eucCnt++) || (bestScore > score)) {\n                bestScore = score;\n                bestIdx = j;\n              }\n            }\n          }\n        }\n        if (bestIdx >= 0) {\n          if (this.mVerifier) {\n            let charset = this.mVerifier[this.mItemIdx[bestIdx]];\n            if(charset) {\n              this.Report(charset.charset());\n            }\n          }\n          this.mDone = true;\n        }\n      }\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public String[] getProbableCharsets() {\n\n\tif (mItems <= 0) {\n\t   String[] nomatch = new String[1];\n\t   nomatch[0] = \"nomatch\" ;\n\t   return nomatch ;\n\t}\n\n\tString ret[] = new String[mItems] ;\n\tfor (int i=0; i<mItems; i++)\n\t\tret[i] = mVerifier[mItemIdx[i]].charset() ;\n\treturn ret ;\n   }",
        "TranslatedCode": "public getProbableCharsets(): Array<string> {\n\n    if (this.mItems <= 0) {\n\n      let nomatch: Array<string> = new Array(1);\n      nomatch[0] = \"nomatch\";\n      return nomatch;\n    }\n\n    let ret: Array<string> = new Array(this.mItems);\n    for (let i = 0; i < this.mItems; i++){\n      if (this.mVerifier) {\n        let tmp = this.mVerifier[this.mItemIdx[i]];\n        if (tmp) {\n          ret[i] = tmp.charset();\n        }\n      }\n    }\n    return ret;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void Reset() {\n\t\tmTotal = 0 ;\n\t\tmState = 0 ;\n\t\tfor(int i=0; i<94; i++)\n\t\t\tmFirstByteCnt[i] = mSecondByteCnt[i] = 0 ;\n\t}",
        "TranslatedCode": "public Reset(): void {\n    this.mTotal = 0;\n    this.mState = 0;\n    for (let i = 0; i < 94; i++)\n    this.mFirstByteCnt[i] = this.mSecondByteCnt[i] = 0;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "boolean EnoughData() { return mTotal > mThreshold; }",
        "TranslatedCode": "public EnoughData(): boolean {\n    return this.mTotal > this.mThreshold;\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "boolean GetSomeData() { return mTotal > 1; }",
        "TranslatedCode": "public GetSomeData(): boolean {\n    return this.mTotal > 1;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "boolean Sample(byte[] aIn, int aLen) {\n\n           if(mState == 1)\n               return false;\n\n           int p = 0;\n\n           // if(aLen + mTotal > 0x80000000)\n           //    aLen = 0x80000000 - mTotal;\n\n           int i;\n           for(i=0; (i<aLen) && (1 != mState) ;i++,p++)\n           {\n               switch(mState) {\n                  case 0:\n                    if( ( aIn[p] & 0x0080 ) != 0 )\n                    {\n                       if((0xff==(0xff&aIn[p])) || ( 0xa1>(0xff&aIn[p]))) {\n                          mState = 1;\n                       } else {\n                          mTotal++;\n                          mFirstByteCnt[(0xff&aIn[p]) - 0xa1]++;\n                          mState = 2;\n                       }\n                    }\n                    break;\n                  case 1:\n                    break;\n                  case 2:\n                    if( (aIn[p] & 0x0080)  != 0 )\n                    {\n                       if((0xff == (0xff&aIn[p]))\n\t\t\t\t|| ( 0xa1 > (0xff&aIn[p]))) {\n                          mState = 1;\n                       } else {\n                          mTotal++;\n                          mSecondByteCnt[(0xff&aIn[p]) - 0xa1]++;\n                          mState = 0;\n                       }\n                    } else {\n                       mState = 1;\n                    }\n                    break;\n                  default:\n                    mState = 1;\n               }\n            }\n            return (1 != mState  );\n        }",
        "TranslatedCode": "public Sample(aIn: Int8Array| null, aLen: number): boolean {\n    if(!!!aIn) {\n      return false;\n    }\n\n    if (this.mState == 1)\n    return false;\n\n    let p = 0;\n\n    for (let i = 0; (i < aLen) && (1 != this.mState); i++, p++) {\n      switch (this.mState) {\n        case 0:\n          if ((aIn[p] & 0x0080) != 0) {\n            if ((0xff == (0xff & aIn[p])) || (0xa1 > (0xff & aIn[p]))) {\n              this.mState = 1;\n            } else {\n              this.mTotal++;\n              this.mFirstByteCnt[(0xff & aIn[p]) - 0xa1]++;\n              this.mState = 2;\n            }\n          }\n          break;\n        case 1:\n          break;\n        case 2:\n          if ((aIn[p] & 0x0080) != 0) {\n            if ((0xff == (0xff & aIn[p]))\n            || (0xa1 > (0xff & aIn[p]))) {\n              this.mState = 1;\n            } else {\n              this.mTotal++;\n              this.mSecondByteCnt[(0xff & aIn[p]) - 0xa1]++;\n              this.mState = 0;\n            }\n          } else {\n            this.mState = 1;\n          }\n          break;\n        default:\n          this.mState = 1;\n      }\n    }\n    return (1 != this.mState);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "void CalFreq() {\n\t   for(int i = 0 ; i < 94; i++) {\n\t      mFirstByteFreq[i] = (float)mFirstByteCnt[i] / (float)mTotal;\n\t      mSecondByteFreq[i] = (float)mSecondByteCnt[i] / (float)mTotal;\n\t   }\n\t}",
        "TranslatedCode": "public CalFreq(): void  {\n    for (let i = 0; i < 94; i++) {\n      this.mFirstByteFreq[i] = this.mFirstByteCnt[i] / this.mTotal;\n      this.mSecondByteFreq[i] = this.mSecondByteCnt[i] / this.mTotal;\n    }\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "float   GetScore(float[] aFirstByteFreq, float aFirstByteWeight,\n                         float[] aSecondByteFreq, float aSecondByteWeight)\n\t{\n       \t   return aFirstByteWeight * GetScore(aFirstByteFreq, mFirstByteFreq) +\n              aSecondByteWeight * GetScore(aSecondByteFreq, mSecondByteFreq);\n\t}\n",
        "TranslatedCode": "public GetScore(aFirstByteFreq: number[], aFirstByteWeight: number,\n                  aSecondByteFreq: number[], aSecondByteWeight: number): number\n  {\n    return aFirstByteWeight * this.GetScoreIn(aFirstByteFreq, this.mFirstByteFreq) +\n    aSecondByteWeight * this.GetScoreIn(aSecondByteFreq, this.mSecondByteFreq);\n  }\n",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "float   GetScore(float[] array1, float[] array2) {\n           float s;\n           float sum=0.0f;\n\n       \t   for(int i=0;i<94;i++) {\n              s = array1[i] - array2[i];\n              sum += s * s;\n           }\n           return (float)java.lang.Math.sqrt((double)sum) / 94.0f;\n\t}",
        "TranslatedCode": "public GetScoreIn(array1: number[], array2: number[]): number {\n    let s = 0.0;\n    let sum = 0.0;\n\n    for (let i = 0;i < 94; i++) {\n      s = array1[i] - array2[i];\n      sum += s * s;\n    }\n    return Math.sqrt(sum) / 94.0;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void Init(nsICharsetDetectionObserver aObserver) {\n\n\t  \tmObserver = aObserver ;\n\t\treturn ;\n\n\t}",
        "TranslatedCode": "public Init(aObserver: nsICharsetDetectionObserver): void {\n    this.mObserver = aObserver;\n    return;\n\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean DoIt(byte[] aBuf, int aLen, boolean oDontFeedMe) {\n\n\t\tif (aBuf == null || oDontFeedMe )\n\t\t    return false ;\n\n\t\tthis.HandleData(aBuf, aLen) ;\n\t\treturn mDone ;\n\t}",
        "TranslatedCode": "public DoIt(aBuf: Int8Array| null, oDontFeedMe: boolean): boolean {\n    if (aBuf == null || oDontFeedMe)\n      return false;\n    super.HandleData(aBuf, aBuf.length);\n    return super.mDone;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void Done() {\n\t\tthis.DataEnd() ;\n\t\treturn ;\n\t}",
        "TranslatedCode": "public Done(): void {\n    super.DataEnd();\n    return;\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public void Report(String charset) {\n\t\tif (mObserver != null)\n\t\t    mObserver.Notify(charset)  ;\n\t}\n",
        "TranslatedCode": "public Report(charset: string): void {\n    if (this.mObserver != null)\n    this.mObserver.Notify(charset);\n  }",
        "Language": "ArkTS"
    },
    {
        "JavaCode": "public boolean isAscii(byte[] aBuf, int aLen) {\n\n                for(int i=0; i<aLen; i++) {\n                   if ((0x0080 & aBuf[i]) != 0) {\n                      return false ;\n                   }\n                }\n\t\treturn true ;\n\t}",
        "TranslatedCode": "public isAscii(aBuf: Int8Array): boolean {\n\n    for (let i = 0; i < aBuf.length; i++) {\n      if ((0x0080 & aBuf[i]) != 0) {\n        return false;\n      }\n    }\n    return true;\n  }",
        "Language": "ArkTS"
    }
]